# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import json
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import OrderNotFound


class kabus(Exchange):

    def describe(self):
        return self.deep_extend(super(kabus, self).describe(), {
            'id': 'kabus',
            'name': 'Kabus',
            'countries': ['JP'],
            'version': 'v1',
            'rateLimit': 1000,
            'timeframes': {
                '1m': '1m',
                '3m': '3m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '2h': '2h',
                '4h': '4h',
                '6h': '6h',
                '8h': '8h',
                '12h': '12h',
                '1d': '1d',
                '3d': '3d',
                '1w': '1w',
                '1M': '1M',
            },
            'urls': {
                'logo': 'https://pbs.twimg.com/profile_images/1476235905375813633/-jRNbwhv_400x400.jpg',
                'api': 'http://{ipaddr}/live/kabusapi',
                'www': 'https://twitter.com/KabutoTheBot',
                'doc': 'https://twitter.com/KabutoTheBot',
            },
            'has': {
                'CORS': None,
                'spot': True,
                'margin': None,
                'swap': None,
                'future': None,
                'option': None,
                'cancelOrder': True,
                'createOrder': True,
                'fetchBalance': True,
                'fetchOHLCV': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrders': True,
                'fetchTicker': True,
                'fetchTickers': True,
                'registerWhitelist': True,
            },
            'precision': {
                'amount': -2,
                'price': None,
            },
            'api': {
                'private': {
                    'get': [
                        'board/{symbol}',
                        'wallet/cash',
                        'orders',
                    ],
                    'post': [
                        'token',
                        'sendorder',  # FIXME: Not used. Directly calling fetch2
                    ],
                    'put': [
                        'register',  # FIXME: Not used. Directly calling fetch2
                        'cancelorder',
                    ],
                },
            },
            'requiredCredentials': {
                'ipaddr': True,
                'password': False,
                'apiKey': False,
                'secret': False,
                'uid': False,
                'login': False,
                'twofa': False,  # 2-factor authentication(one-time password key)
                'privateKey': False,  # a "0x"-prefixed hexstring private key for a wallet
                'walletAddress': False,  # the wallet address "0x"-prefixed hexstring
                'token': False,  # reserved for HTTP auth in some cases
            },
            'fees': {
                'trading': {
                    'maker': self.parse_number('0.0'),
                    'taker': self.parse_number('0.0'),
                },
            },
        })

    def sign(self, path, api='private', method='GET', params={}, headers=None, body=None):
        # Attach header and other necessary parameters to the API request.
        # This is called before a REST API request thrown to the server.
        # TODO: Handle differently 'public' call and 'private' call to improve security.
        self.check_required_credentials()
        if not self.apiKey:
            self.apiKey = self.fetch_token()
        request = '/' + self.implode_params(path, params)
        url = self.implode_params(self.urls['api'], {'ipaddr': self.ipaddr}) + request
        headers = {
            'X-API-KEY': self.apiKey,
            'Content-Type': 'application/json',
        }
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def prepare_order(self, pair, type, side, amount, price):
        # 現物株式取引用のパラメタ設定
        ticker = self.parse_ticker(pair)
        if type == 'market':
            price = 0  # 成行執行→price=0
        return {
            'Symbol': ticker['Symbol'],
            'Exchange': ticker['Exchange'],
            'Side': self.safe_string({'sell': '1', 'buy': '2'}, side),
            'DelivType': self.safe_integer({'sell': 0, 'buy': 2}, side),  # 現物買→預り金
            'FundType': self.safe_string({'sell': '  ', 'buy': 'AA'}, side),  # 現物買→信用代用
            'Qty': amount,
            'FrontOrderType': self.safe_integer({'market': 10, 'limit': 20}, type),
            'Price': price,
        }

    def create_order(self, pair, type, side, amount, price=None, params={}):
        # https://kabucom.github.io/kabusapi/reference/index.html#operation/sendorderPost
        self.load_markets()
        orderParam = self.prepare_order(pair, type, side, amount, price)
        body = {
            'Password': self.kabusapi_password,             # 注文パスワード: <string>
            'Symbol': orderParam['Symbol'],                 # 銘柄コード: <string>
            'Exchange': orderParam['Exchange'],             # 市場コード: <int> 1(東証), 3(名証), 5(福証), 6(札証)
            'SecurityType': 1,                              # 商品種別: <int> 1(株式)
            'Side': orderParam['Side'],                     # 売買区分: <string> 1(売), 2(買)
            'CashMargin': 1,                                # 信用区分: <int> 1(現物), 2(新規), 3(返済)
            'DelivType': orderParam['DelivType'],           # 受渡区分: <int> 0(指定なし), 1(自動振替), 2(預かり金) *現物買は必須/現物売は0
            'FundType': orderParam['FundType'],             # 資産区分: <string> '  '(現物売), 02(保護), AA(信用代用), 11(信用取引) *現物買は必須/現物売はスペース2つ
            'AccountType': 2,                               # 口座種別: <int> 2(一般), 4(特定), 12(法人)
            'Qty': orderParam['Qty'],                       # 注文数量: <int>
            'FrontOrderType': orderParam['FrontOrderType'],  # 執行順序: <int> 10(成行), 20(指値) *他多数
            'Price': orderParam['Price'],                   # 注文価格: <int>
            'ExpireDay': 0,                                 # 注文有効期限: <int> *0=本日中
        }
        body_str = json.dumps(body)
        response = self.fetch2('sendorder', 'private', 'POST', params, None, body_str, {}, {})
        # {'OrderId': '20220423A01N86096051', 'Result': 0}
        id = self.safe_string(response, 'OrderId')
        return {
            'info': response,
            'id': id,
        }

    def fetch_token(self):
        # Fetch one-time access token for Kabus API
        url = self.implode_params(self.urls['api'], {'ipaddr': self.ipaddr}) + '/token'
        headers = {
            'Content-Type': 'application/json',
        }
        # json.loads() is needed to load json module in transpiled Python script
        body = json.dumps({'APIPassword': self.password})
        response = self.fetch(url, 'POST', headers, body)
        if response['ResultCode'] == '0':
            return response['Token']
        else:
            # Temporary placeholder for exception when it fails to get a new token
            raise ExchangeError()

    def fetch_markets(self, params={}):
        # Return a list of stock code and its basic properties for trading
        # No API access for now
        markets = [
            '8306@1',
            '4689@1',
            '6501@1',
            '3826@1',
            '5020@1',
            '3632@1',
            '5191@1',
            '6440@1',
            '8897@1',
            '167060018@24',
        ]
        result = []
        for i in range(0, len(markets)):
            result.append({
                'id': i,
                'symbol': markets[i] + '/JPY',
                'base': 'JPY',
                'quote': 'JPY',
                'maker': 0.001,
                'taker': 0.001,
                'active': True,
                'min_unit': 100,
                # value limits when placing orders on self market
                'limits': {
                    'amount': {
                        # order amount should be > min
                        'min': 100,
                        # order amount should be < max
                        'max': 100000000,
                    },
                    'price': {
                        'min': 100,
                        'max': 100000000,
                    },
                    # order cost = price * amount
                    'cost': {
                        'min': 0,
                        'max': 100000000,
                    },
                },
            })
        return result

    def parse_order(self, order, market=None):
        #     {'AccountType': 2,
        #       'CumQty': 0.0,
        #       'DelivType': 2,
        #       'Details': [{'Commission': 0.0,
        #                    'CommissionTax': 0.0,
        #                    'DelivDay': 20220427,
        #                    'ExchangeID': None,
        #                    'ExecutionDay': None,
        #                    'ExecutionID': None,
        #                    'ID': '20220423A01N86096041',
        #                    'OrdType': 1,
        #                    'Price': 0.0,
        #                    'Qty': 100.0,
        #                    'RecType': 1,
        #                    'SeqNum': 1,
        #                    'State': 3,
        #                    'TransactTime': '2022-04-23T14:31:16.652838+09:00'},
        #                   {'Commission': 0.0,
        #                    'CommissionTax': 0.0,
        #                    'DelivDay': 20220427,
        #                    'ExchangeID': None,
        #                    'ExecutionDay': None,
        #                    'ExecutionID': None,
        #                    'ID': '20220423B01N86096042',
        #                    'OrdType': 1,
        #                    'Price': 0.0,
        #                    'Qty': 100.0,
        #                    'RecType': 4,
        #                    'SeqNum': 2,
        #                    'State': 1,
        #                    'TransactTime': '2022-04-23T14:31:16.652838+09:00'}],
        #       'Exchange': 1,
        #       'ExchangeName': '東証ス',
        #       'ExpireDay': 20220425,
        #       'ID': '20220423A01N86096041',
        #       'OrdType': 1,
        #       'OrderQty': 100.0,
        #       'OrderState': 1,
        #       'Price': 0.0,
        #       'RecvTime': '2022-04-23T14:31:16.652838+09:00',
        #       'Side': '2',
        #       'State': 1,
        #       'Symbol': '9318',
        #       'SymbolName': 'アジア開発キャピタル'},
        #     }
        id = self.safe_string(order, 'ID')
        price = self.safe_float(order, 'Price')
        amount = self.safe_float(order, 'OrderQty')
        cumQty = self.safe_float(order, 'CumQty')
        side = self.safe_string_lower({'1': 'sell', '2': 'buy'}, order['Side'])
        timestamp = self.parse8601(self.safe_string(order, 'RecvTime'))
        symbol = self.safe_string(order, 'Symbol')
        exchange = self.safe_string(order, 'Exchange')
        order_type = 'limit'
        if price == 0:
            order_type = 'market'
        # Order status is one of ['open', 'closed', 'canceled', 'expired', 'rejected']
        n_details = len(order['Details'])
        if n_details < 1:
            raise ExchangeError(self.id + ' expects to have at least 1 detail per order but 0 given')
        lastDetail = order['Details'][n_details - 1]
        # Get the latest state from the Details
        status = self.safe_string({'1': 'open', '3': 'closed', '5': 'closed'}, lastDetail['State'])
        return self.safe_order({
            'id': id,
            'clientOrderId': None,
            'info': order,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'status': status,
            'symbol': symbol + '@' + exchange + '/JPY',
            'type': order_type,
            'timeInForce': None,
            'postOnly': None,
            'side': side,
            'price': price,
            'stopPrice': None,
            'cost': None,
            'amount': amount,
            'filled': cumQty,
            'remaining': amount - cumQty,
            'fee': None,
            'average': None,
            'trades': None,
        }, market)

    def fetch_orders(self, symbol=None, since=None, limit=100, params={}):
        self.load_markets()
        params['product'] = 0
        response = self.privateGetOrders(params)
        return self.parse_orders(response)

    def fetch_order(self, id, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrder() requires a `symbol` argument')
        orders = self.fetch_orders(symbol)
        ordersById = self.index_by(orders, 'id')
        if id in ordersById:
            return ordersById[id]
        raise OrderNotFound(self.id + 'No order found with id ' + id)

    def cancel_order(self, id, symbol=None, params={}):
        self.load_markets()
        body = {
            'OrderID': id,
            'Password': self.kabusapi_password,
        }
        body_str = json.dumps(body)
        return self.fetch2('cancelorder', 'private', 'PUT', params, None, body_str, {}, {})

    def parse_balance(self, response):
        # Parse and organize balance information.
        result = {'info': response}
        account = self.account()
        account['free'] = self.safe_float(response, 'StockAccountWallet')
        result['JPY'] = account
        return result

    def fetch_balance(self, params={}):
        # Fetch account balance information
        self.load_markets()
        response = self.privateGetWalletCash(params)
        # {
        #      'StockAccountWallet': '497120.0'
        # }
        return self.parse_balance(response)

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        return []

    def parse_ticker(self, pair):
        # Parse ticker string to get symbol and exchange code
        identifier = pair.split('/')[0]
        symbol = identifier.split('@')[0]
        exchange = int(identifier.split('@')[1])
        return {'Symbol': symbol, 'Exchange': exchange}

    def fetch_ticker(self, symbol, params={}):
        # Fetch board informatio of a single symbol.
        self.load_markets()
        symbol = symbol[0:-4]
        request = {
            'symbol': symbol,
        }
        return self.privateGetBoardSymbol(self.extend(request, params))

    def fetch_tickers(self, symbol, params={}):
        # Coming soon
        return None

    def fetch_order_book(self, symbol, limit=None, params={}):
        # Fetch order book information of a single symbol
        ticker = self.fetch_ticker(symbol, params)
        keys = list(ticker.keys())
        buys = []
        sells = []
        for i in range(0, len(keys)):
            key = keys[i]
            if key.find('Buy') == 0:
                buys.append([ticker[key]['Price'], ticker[key]['Qty']])
            if key.find('Sell') == 0:
                sells.append([ticker[key]['Price'], ticker[key]['Qty']])
        orderbook = {'bids': buys, 'asks': sells}
        return self.parse_order_book(orderbook, symbol)

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        # Fetch latest OHLCV data of a single symbol from the local PriceServer
        symbol = symbol[0:-4]
        response = self.fetch('http://127.0.0.1:8999/charts/' + symbol + '/JPY/1m', 'GET')
        ohlcvs = json.loads(response[symbol])
        data = []
        for i in range(0, len(ohlcvs)):
            data.append(ohlcvs[i][0:-1])
        return data

    def register_whitelist(self, whitelist):
        # Register whitelist symbols.
        # FIXME: This cannnot be use from Worker due to the nature of the bot process.
        # PriceServer has a function for the same purpose and that is used instead.
        symbols = {'Symbols': []}
        for i in range(0, len(whitelist)):
            tickerVal = self.parse_ticker(whitelist[i])
            symbols['Symbols'].append(tickerVal)
        body = json.dumps(symbols)
        response = self.fetch2('register', 'private', 'PUT', {}, None, body, {}, {})
        return response['RegistList']
