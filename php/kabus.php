<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\ArgumentsRequired;
use \ccxt\OrderNotFound;

class kabus extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'kabus',
            'name' => 'Kabus',
            'countries' => array( 'JP' ),
            'version' => 'v1',
            'rateLimit' => 1000,
            'timeframes' => array(
                '1m' => '1m',
                '3m' => '3m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '2h' => '2h',
                '4h' => '4h',
                '6h' => '6h',
                '8h' => '8h',
                '12h' => '12h',
                '1d' => '1d',
                '3d' => '3d',
                '1w' => '1w',
                '1M' => '1M',
            ),
            'urls' => array(
                'logo' => 'https://pbs.twimg.com/profile_images/1476235905375813633/-jRNbwhv_400x400.jpg',
                'api' => 'http://{ipaddr}/live/kabusapi',
                'www' => 'https://twitter.com/KabutoTheBot',
                'doc' => 'https://twitter.com/KabutoTheBot',
            ),
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => null,
                'swap' => null,
                'future' => null,
                'option' => null,
                'cancelOrder' => true,
                'createOrder' => true,
                'fetchBalance' => true,
                'fetchOHLCV' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'registerWhitelist' => true,
            ),
            'precision' => array(
                'amount' => -2,
                'price' => null,
            ),
            'api' => array(
                'private' => array(
                    'get' => array(
                        'board/{symbol}',
                        'wallet/cash',
                        'orders',
                    ),
                    'post' => array(
                        'token',
                        'sendorder', // FIXME => Not used. Directly calling fetch2
                    ),
                    'put' => array(
                        'register', // FIXME => Not used. Directly calling fetch2
                        'cancelorder',
                    ),
                ),
            ),
            'requiredCredentials' => array(
                'ipaddr' => true,
                'password' => false,
                'apiKey' => false,
                'secret' => false,
                'uid' => false,
                'login' => false,
                'twofa' => false, // 2-factor authentication (one-time password key)
                'privateKey' => false, // a "0x"-prefixed hexstring private key for a wallet
                'walletAddress' => false, // the wallet address "0x"-prefixed hexstring
                'token' => false, // reserved for HTTP auth in some cases
            ),
            'fees' => array(
                'trading' => array(
                    'maker' => $this->parse_number('0.0'),
                    'taker' => $this->parse_number('0.0'),
                ),
            ),
        ));
    }

    public function sign($path, $api = 'private', $method = 'GET', $params = array (), $headers = null, $body = null) {
        // Attach header and other necessary parameters to the API $request->
        // This is called before a REST API $request thrown to the server.
        // TODO => Handle differently 'public' call and 'private' call to improve security.
        $this->check_required_credentials();
        if (!$this->apiKey) {
            $this->apiKey = $this->fetch_token();
        }
        $request = '/' . $this->implode_params($path, $params);
        $url = $this->implode_params($this->urls['api'], array( 'ipaddr' => $this->ipaddr )) . $request;
        $headers = array(
            'X-API-KEY' => $this->apiKey,
            'Content-Type' => 'application/json',
        );
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function prepare_order($pair, $type, $side, $amount, $price) {
        // 現物株式取引用のパラメタ設定
        $ticker = $this->parse_ticker($pair);
        if ($type === 'market') {
            $price = 0; // 成行執行→$price=0
        }
        return array(
            'Symbol' => $ticker['Symbol'],
            'Exchange' => $ticker['Exchange'],
            'Side' => $this->safe_string(array( 'sell' => '1', 'buy' => '2' ), $side),
            'DelivType' => $this->safe_integer(array( 'sell' => 0, 'buy' => 2 ), $side), // 現物買→預り金
            'FundType' => $this->safe_string(array( 'sell' => '  ', 'buy' => 'AA' ), $side), // 現物買→信用代用
            'Qty' => $amount,
            'FrontOrderType' => $this->safe_integer(array( 'market' => 10, 'limit' => 20 ), $type),
            'Price' => $price,
        );
    }

    public function create_order($pair, $type, $side, $amount, $price = null, $params = array ()) {
        // https://kabucom.github.io/kabusapi/reference/index.html#operation/sendorderPost
        $this->load_markets();
        $orderParam = $this->prepare_order($pair, $type, $side, $amount, $price);
        $body = array(
            'Password' => $this->kabusapi_password,             // 注文パスワード => <string>
            'Symbol' => $orderParam['Symbol'],                 // 銘柄コード => <string>
            'Exchange' => $orderParam['Exchange'],             // 市場コード => <int> 1 (東証), 3 (名証), 5 (福証), 6 (札証)
            'SecurityType' => 1,                              // 商品種別 => <int> 1 (株式)
            'Side' => $orderParam['Side'],                     // 売買区分 => <string> 1 (売), 2 (買)
            'CashMargin' => 1,                                // 信用区分 => <int> 1 (現物), 2 (新規), 3 (返済)
            'DelivType' => $orderParam['DelivType'],           // 受渡区分 => <int> 0 (指定なし), 1 (自動振替), 2 (預かり金) *現物買は必須/現物売は0
            'FundType' => $orderParam['FundType'],             // 資産区分 => <string> '  ' (現物売), 02 (保護), AA (信用代用), 11 (信用取引) *現物買は必須/現物売はスペース2つ
            'AccountType' => 2,                               // 口座種別 => <int> 2 (一般), 4 (特定), 12 (法人)
            'Qty' => $orderParam['Qty'],                       // 注文数量 => <int>
            'FrontOrderType' => $orderParam['FrontOrderType'], // 執行順序 => <int> 10 (成行), 20 (指値) *他多数
            'Price' => $orderParam['Price'],                   // 注文価格 => <int>
            'ExpireDay' => 0,                                 // 注文有効期限 => <int> *0=本日中
        );
        $body_str = json_encode ($body);
        $response = $this->fetch2('sendorder', 'private', 'POST', $params, null, $body_str, array(), array());
        // array('OrderId' => '20220423A01N86096051', 'Result' => 0)
        $id = $this->safe_string($response, 'OrderId');
        return array(
            'info' => $response,
            'id' => $id,
        );
    }

    public function fetch_token() {
        // Fetch one-time access token for Kabus API
        $url = $this->implode_params($this->urls['api'], array( 'ipaddr' => $this->ipaddr )) . '/token';
        $headers = array(
            'Content-Type' => 'application/json',
        );
        // JSON.parse() is needed to load json module in transpiled Python script
        $body = json_encode (array( 'APIPassword' => $this->password ));
        $response = $this->fetch($url, 'POST', $headers, $body);
        if ($response['ResultCode'] === '0') {
            return $response['Token'];
        } else {
            // Temporary placeholder for exception when it fails to get a new token
            throw new ExchangeError();
        }
    }

    public function fetch_markets($params = array ()) {
        // Return a list of stock code and its basic properties for trading
        // No API access for now
        $markets = array(
            '8306@1',
            '4689@1',
            '6501@1',
            '3826@1',
            '5020@1',
            '3632@1',
            '5191@1',
            '6440@1',
            '8897@1',
            '167060018@24',
        );
        $result = array();
        for ($i = 0; $i < count($markets); $i++) {
            $result[] = array(
                'id' => $i,
                'symbol' => $markets[$i] . '/JPY',
                'base' => 'JPY',
                'quote' => 'JPY',
                'maker' => 0.001,
                'taker' => 0.001,
                'active' => true,
                'min_unit' => 100,
                // value limits when placing orders on this market
                'limits' => array(
                    'amount' => array(
                        // order amount should be > min
                        'min' => 100,
                        // order amount should be < max
                        'max' => 100000000,
                    ),
                    'price' => array(
                        'min' => 100,
                        'max' => 100000000,
                    ),
                    // order cost = price * amount
                    'cost' => array(
                        'min' => 0,
                        'max' => 100000000,
                    ),
                ),
            );
        }
        return $result;
    }

    public function parse_order($order, $market = null) {
        //     array('AccountType' => 2,
        //       'CumQty' => 0.0,
        //       'DelivType' => 2,
        //       'Details' => [array('Commission' => 0.0,
        //                    'CommissionTax' => 0.0,
        //                    'DelivDay' => 20220427,
        //                    'ExchangeID' => None,
        //                    'ExecutionDay' => None,
        //                    'ExecutionID' => None,
        //                    'ID' => '20220423A01N86096041',
        //                    'OrdType' => 1,
        //                    'Price' => 0.0,
        //                    'Qty' => 100.0,
        //                    'RecType' => 1,
        //                    'SeqNum' => 1,
        //                    'State' => 3,
        //                    'TransactTime' => '2022-04-23T14:31:16.652838+09:00'),
        //                   array('Commission' => 0.0,
        //                    'CommissionTax' => 0.0,
        //                    'DelivDay' => 20220427,
        //                    'ExchangeID' => None,
        //                    'ExecutionDay' => None,
        //                    'ExecutionID' => None,
        //                    'ID' => '20220423B01N86096042',
        //                    'OrdType' => 1,
        //                    'Price' => 0.0,
        //                    'Qty' => 100.0,
        //                    'RecType' => 4,
        //                    'SeqNum' => 2,
        //                    'State' => 1,
        //                    'TransactTime' => '2022-04-23T14:31:16.652838+09:00')],
        //       'Exchange' => 1,
        //       'ExchangeName' => '東証ス',
        //       'ExpireDay' => 20220425,
        //       'ID' => '20220423A01N86096041',
        //       'OrdType' => 1,
        //       'OrderQty' => 100.0,
        //       'OrderState' => 1,
        //       'Price' => 0.0,
        //       'RecvTime' => '2022-04-23T14:31:16.652838+09:00',
        //       'Side' => '2',
        //       'State' => 1,
        //       'Symbol' => '9318',
        //       'SymbolName' => 'アジア開発キャピタル'),
        //     }
        $id = $this->safe_string($order, 'ID');
        $price = $this->safe_float($order, 'Price');
        $amount = $this->safe_float($order, 'OrderQty');
        $cumQty = $this->safe_float($order, 'CumQty');
        $side = $this->safe_string_lower(array( '1' => 'sell', '2' => 'buy' ), $order['Side']);
        $timestamp = $this->parse8601($this->safe_string($order, 'RecvTime'));
        $symbol = $this->safe_string($order, 'Symbol');
        $exchange = $this->safe_string($order, 'Exchange');
        $order_type = 'limit';
        if ($price === 0) {
            $order_type = 'market';
        }
        // Order $status is one of ['open', 'closed', 'canceled', 'expired', 'rejected']
        $n_details = is_array($order['Details']) ? count($order['Details']) : 0;
        if ($n_details < 1) {
            throw new ExchangeError($this->id . ' expects to have at least 1 detail per $order but 0 given');
        }
        $lastDetail = $order['Details'][$n_details - 1];
        // Get the latest state from the Details
        $status = $this->safe_string(array( '1' => 'open', '3' => 'closed' ), $lastDetail['State']);
        return $this->safe_order(array(
            'id' => $id,
            'clientOrderId' => null,
            'info' => $order,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'status' => $status,
            'symbol' => $symbol . '@' . $exchange . '/JPY',
            'type' => $order_type,
            'timeInForce' => null,
            'postOnly' => null,
            'side' => $side,
            'price' => $price,
            'stopPrice' => null,
            'cost' => null,
            'amount' => $amount,
            'filled' => $cumQty,
            'remaining' => $amount - $cumQty,
            'fee' => null,
            'average' => null,
            'trades' => null,
        ), $market);
    }

    public function fetch_orders($symbol = null, $since = null, $limit = 100, $params = array ()) {
        $this->load_markets();
        $params['product'] = 0;
        $response = $this->privateGetOrders ($params);
        return $this->parse_orders($response);
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrder() requires a `$symbol` argument');
        }
        $orders = $this->fetch_orders($symbol);
        $ordersById = $this->index_by($orders, 'id');
        if (is_array($ordersById) && array_key_exists($id, $ordersById)) {
            return $ordersById[$id];
        }
        throw new OrderNotFound($this->id . 'No order found with $id ' . $id);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        $body = array(
            'OrderID' => $id,
            'Password' => $this->kabusapi_password,
        );
        $body_str = json_encode ($body);
        return $this->fetch2('cancelorder', 'private', 'PUT', $params, null, $body_str, array(), array());
    }

    public function parse_balance($response) {
        // Parse and organize balance information.
        $result = array( 'info' => $response );
        $account = $this->account();
        $account['free'] = $this->safe_float($response, 'StockAccountWallet');
        $result['JPY'] = $account;
        return $result;
    }

    public function fetch_balance($params = array ()) {
        // Fetch account balance information
        $this->load_markets();
        $response = $this->privateGetWalletCash ($params);
        // {
        //      'StockAccountWallet' => '497120.0'
        // }
        return $this->parse_balance($response);
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        return array();
    }

    public function parse_ticker($pair) {
        // Parse ticker string to get $symbol and $exchange code
        $identifier = explode('/', $pair)[0];
        $symbol = explode('@', $identifier)[0];
        $exchange = intval(explode('@', $identifier)[1]);
        return array( 'Symbol' => $symbol, 'Exchange' => $exchange );
    }

    public function fetch_ticker($symbol, $params = array ()) {
        // Fetch board informatio of a single $symbol->
        $this->load_markets();
        $symbol = mb_substr($symbol, 0, -4 - 0);
        $request = array(
            'symbol' => $symbol,
        );
        return $this->privateGetBoardSymbol (array_merge($request, $params));
    }

    public function fetch_tickers($symbol, $params = array ()) {
        // Coming soon
        return null;
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        // Fetch order book information of a single $symbol
        $ticker = $this->fetch_ticker($symbol, $params);
        $keys = is_array($ticker) ? array_keys($ticker) : array();
        $buys = array();
        $sells = array();
        for ($i = 0; $i < count($keys); $i++) {
            $key = $keys[$i];
            if (mb_strpos($key, 'Buy') === 0) {
                $buys[] = [ $ticker[$key]['Price'], $ticker[$key]['Qty'] ];
            }
            if (mb_strpos($key, 'Sell') === 0) {
                $sells[] = [ $ticker[$key]['Price'], $ticker[$key]['Qty'] ];
            }
        }
        $orderbook = array( 'bids' => $buys, 'asks' => $sells );
        return $this->parse_order_book($orderbook, $symbol);
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        // Fetch latest OHLCV $data of a single $symbol from the local PriceServer
        $symbol = mb_substr($symbol, 0, -4 - 0);
        $response = $this->fetch('http://127.0.0.1:8999/charts/' . $symbol . '/JPY/1m', 'GET');
        $ohlcvs = json_decode($response[$symbol], $as_associative_array = true);
        $data = array();
        for ($i = 0; $i < count($ohlcvs); $i++) {
            $data[] = mb_substr($ohlcvs[$i], 0, -1 - 0);
        }
        return $data;
    }

    public function register_whitelist($whitelist) {
        // Register $whitelist $symbols->
        // FIXME => This cannnot be use from Worker due to the nature of the bot process.
        // PriceServer has a function for the same purpose and that is used instead.
        $symbols = array( 'Symbols' => array() );
        for ($i = 0; $i < count($whitelist); $i++) {
            $tickerVal = $this->parse_ticker($whitelist[$i]);
            $symbols['Symbols'][] = $tickerVal;
        }
        $body = json_encode ($symbols);
        $response = $this->fetch2('register', 'private', 'PUT', array(), null, $body, array(), array());
        return $response['RegistList'];
    }
}
