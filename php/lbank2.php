<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ArgumentsRequired;
use \ccxt\InvalidOrder;

class lbank2 extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'lbank2',
            'name' => 'LBank',
            'countries' => array( 'CN' ),
            'version' => 'v2',
            // 50 per second for making and cancelling orders 1000ms / 50 = 20
            // 20 per second for all other requests, cost = 50 / 20 = 2.5
            'rateLimit' => 20,
            'has' => array(
                'CORS' => false,
                'spot' => true,
                'margin' => false,
                'swap' => false,
                'future' => false,
                'option' => false,
                'addMargin' => false,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'createOrder' => true,
                'createReduceOnlyOrder' => false,
                'createStopLimitOrder' => false,
                'createStopMarketOrder' => false,
                'createStopOrder' => false,
                'fetchBalance' => true,
                'fetchBorrowRate' => false,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchBorrowRates' => false,
                'fetchBorrowRatesPerSymbol' => false,
                'fetchClosedOrders' => false,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchIsolatedPositions' => false,
                'fetchLeverage' => false,
                'fetchLeverageTiers' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchPosition' => false,
                'fetchPositions' => false,
                'fetchPositionsRisk' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchTicker' => true,
                'fetchTickers' => false,
                'fetchTrades' => true,
                'fetchTradingFees' => true,
                'fetchTransactionFees' => true,
                'reduceMargin' => false,
                'setLeverage' => false,
                'setMarginMode' => false,
                'setPositionMode' => false,
                'withdraw' => false,
            ),
            'timeframes' => array(
                '1m' => 'minute1',
                '5m' => 'minute5',
                '15m' => 'minute15',
                '30m' => 'minute30',
                '1h' => 'hour1',
                '2h' => 'hour2',
                '4h' => 'hour4',
                '6h' => 'hour6',
                '8h' => 'hour8',
                '12h' => 'hour12',
                '1d' => 'day1',
                '1w' => 'week1',
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/38063602-9605e28a-3302-11e8-81be-64b1e53c4cfb.jpg',
                'api' => 'https://api.lbank.info',
                'api2' => 'https://api.lbkex.com',
                'www' => 'https://www.lbank.info',
                'doc' => 'https://github.com/LBank-exchange/lbank-official-api-docs',
                'fees' => 'https://lbankinfo.zendesk.com/hc/en-gb/articles/360012072873-Trading-Fees',
                'referral' => 'https://www.lbex.io/invite?icode=7QCY',
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'currencyPairs' => 2.5,
                        'accuracy' => 2.5,
                        'usdToCny' => 2.5,
                        'withdrawConfigs' => 2.5,
                        'timestamp' => 2.5,
                        'ticker/24h' => 2.5, // down
                        'ticker' => 2.5,
                        'depth' => 2.5,
                        'incrDepth' => 2.5,
                        'trades' => 2.5,
                        'kline' => 2.5,
                        // new quote endpoints
                        'supplement/system_ping' => 2.5,
                        'supplement/incrDepth' => 2.5,
                        'supplement/trades' => 2.5,
                        'supplement/ticker/price' => 2.5,
                        'supplement/ticker/bookTicker' => 2.5,
                    ),
                    'post' => array(
                        'supplement/system_status' => 2.5,
                    ),
                ),
                'private' => array(
                    'post' => array(
                        // account
                        'user_info' => 2.5,
                        'subscribe/get_key' => 2.5,
                        'subscribe/refresh_key' => 2.5,
                        'subscribe/destroy_key' => 2.5,
                        'get_deposit_address' => 2.5,
                        'deposit_history' => 2.5,
                        // order
                        'create_order' => 1,
                        'batch_create_order' => 1,
                        'cancel_order' => 1,
                        'cancel_clientOrders' => 1,
                        'orders_info' => 2.5,
                        'orders_info_history' => 2.5,
                        'order_transaction_detail' => 2.5,
                        'transaction_history' => 2.5,
                        'orders_info_no_deal' => 2.5,
                        // withdraw
                        'withdraw' => 2.5,
                        'withdrawCancel' => 2.5,
                        'withdraws' => 2.5,
                        'supplement/user_info' => 2.5,
                        'supplement/withdraw' => 2.5,
                        'supplement/deposit_history' => 2.5,
                        'supplement/withdraws' => 2.5,
                        'supplement/get_deposit_address' => 2.5,
                        'supplement/asset_detail' => 2.5,
                        'supplement/customer_trade_fee' => 2.5,
                        'supplement/api_Restrictions' => 2.5,
                        // new quote endpoints
                        'supplement/system_ping' => 2.5,
                        // new order endpoints
                        'supplement/create_order_test' => 1,
                        'supplement/create_order' => 1,
                        'supplement/cancel_order' => 1,
                        'supplement/cancel_order_by_symbol' => 1,
                        'supplement/orders_info' => 2.5,
                        'supplement/orders_info_no_deal' => 2.5,
                        'supplement/orders_info_history' => 2.5,
                        'supplement/user_info_account' => 2.5,
                        'supplement/transaction_history' => 2.5,
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'maker' => $this->parse_number('0.001'),
                    'taker' => $this->parse_number('0.001'),
                ),
                'funding' => array(
                    'withdraw' => array(),
                ),
            ),
            'commonCurrencies' => array(
                'VET_ERC20' => 'VEN',
                'PNT' => 'Penta',
            ),
            'options' => array(
                'cacheSecretAsPem' => true,
                'createMarketBuyOrderRequiresPrice' => true,
                'fetchTrades' => array(
                    'method' => 'publicGetTrades', // or 'publicGetTradesSupplement'
                ),
                'fetchTransactionFees' => array(
                    'method' => 'fetchPrivateFundingFees', // or 'fetchPublicFundingFees'
                ),
                'fetchDepositAddress' => array(
                    'method' => 'fetchDepositAddressDefault', // or fetchDepositAddressSupplement
                ),
                'createOrder' => array(
                    'method' => 'privatePostSupplementCreateOrder', // or privatePostCreateOrder
                ),
                'fetchOrder' => array(
                    'method' => 'fetchOrderSupplement', // or fetchOrderDefault
                ),
                'fetchBalance' => array(
                    'method' => 'privatePostSupplementUserInfo', // or privatePostSupplementUserInfoAccount or privatePostUserInfo
                ),
                'networks' => array(
                    'ERC20' => 'erc20',
                    'ETH' => 'erc20',
                    'TRC20' => 'trc20',
                    'TRX' => 'trc20',
                    'OMNI' => 'omni',
                    'ASA' => 'asa',
                    'BEP20' => 'bep20(bsc)',
                    'BSC' => 'bep20(bsc)',
                    'HT' => 'heco',
                    'BNB' => 'bep2',
                    'BTC' => 'btc',
                    'DOGE' => 'dogecoin',
                    'MATIC' => 'matic',
                    'POLYGON' => 'matic',
                    'OEC' => 'oec',
                    'BTCTRON' => 'btctron',
                    'XRP' => 'xrp',
                    // other unusual chains with number of listed currencies supported
                    //     'avax c-chain' => 1,
                    //     klay => 12,
                    //     bta => 1,
                    //     fantom => 1,
                    //     celo => 1,
                    //     sol => 2,
                    //     zenith => 1,
                    //     ftm => 5,
                    //     bep20 => 1, (single token with mis-named chain) SSS
                    //     bitci => 1,
                    //     sgb => 1,
                    //     moonbeam => 1,
                    //     ekta => 1,
                    //     etl => 1,
                    //     arbitrum => 1,
                    //     tpc => 1,
                    //     ptx => 1
                    // }
                ),
                'inverse-networks' => array(
                    'erc20' => 'ERC20',
                    'trc20' => 'TRC20',
                    'omni' => 'OMNI',
                    'asa' => 'ASA',
                    'bep20(bsc)' => 'BSC',
                    'bep20' => 'BSC',
                    'heco' => 'HT',
                    'bep2' => 'BNB',
                    'btc' => 'BTC',
                    'dogecoin' => 'DOGE',
                    'matic' => 'MATIC',
                    'oec' => 'OEC',
                    'btctron' => 'BTCTRON',
                    'xrp' => 'XRP',
                ),
            ),
        ));
    }

    public function fetch_markets($params = array ()) {
        /**
         * retrieves $data on all markets for lbank2
         * @param {dict} $params extra parameters specific to the exchange api endpoint
         * @return {[dict]} an array of objects representing $market $data
         */
        // needs to return a list of unified $market structures
        $response = $this->publicGetAccuracy ();
        $data = $this->safe_value($response, 'data');
        //      array(
        //          {
        //              $symbol => 'snx3s_usdt',
        //              quantityAccuracy => '2',
        //              minTranQua => '0.01',
        //              priceAccuracy => '6'
        //          }
        //     )
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $market = $data[$i];
            $marketId = $this->safe_string($market, 'symbol');
            $parts = explode('_', $marketId);
            $baseId = $parts[0];
            $quoteId = $parts[1];
            $base = strtoupper($baseId);
            $quote = strtoupper($quoteId);
            $symbol = $base . '/' . $quote;
            $productTypes = array(
                '3l' => true,
                '5l' => true,
                '3s' => true,
                '5s' => true,
            );
            $ending = mb_substr($baseId, -2);
            $isLeveragedProduct = $this->safe_value($productTypes, $ending, false);
            if ($isLeveragedProduct) {
                $symbol .= ':' . $quote;
            }
            $linear = null;
            if ($isLeveragedProduct === true) {
                $linear = true;
            }
            $result[] = array(
                'id' => $marketId,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'settle' => null,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'settleId' => null,
                'type' => 'spot',
                'spot' => true,
                'margin' => false,
                'swap' => $isLeveragedProduct,
                'future' => false,
                'option' => false,
                'active' => true,
                'contract' => $isLeveragedProduct,
                'linear' => $linear, // all leveraged ETF products are in USDT
                'inverse' => null,
                'contractSize' => null,
                'expiry' => null,
                'expiryDatetime' => null,
                'strike' => null,
                'optionType' => null,
                'precision' => array(
                    'amount' => $this->safe_integer($market, 'quantityAccuracy'),
                    'price' => $this->safe_integer($market, 'priceAccuracy'),
                ),
                'limits' => array(
                    'leverage' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'amount' => array(
                        'min' => $this->safe_integer($market, 'minTranQua'),
                        'max' => null,
                    ),
                    'price' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
                'info' => $market,
            );
        }
        return $result;
    }

    public function parse_ticker($ticker, $market = null) {
        //
        //      {
        //          "symbol":"btc_usdt",
        //          "ticker" => array(
        //              "high":40200.88,
        //              "vol":7508.3096,
        //              "low":38239.38,
        //              "change":0.75,
        //              "turnover":292962771.34,
        //              "latest":39577.95
        //               ),
        //           "timestamp":1647005189792
        //      }
        //
        $marketId = $this->safe_string($ticker, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market);
        $timestamp = $this->safe_integer($ticker, 'timestamp');
        $tickerData = $this->safe_value($ticker, 'ticker');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($tickerData, 'high'),
            'low' => $this->safe_string($tickerData, 'low'),
            'bid' => null,
            'bidVolume' => null,
            'ask' => null,
            'askVolume' => null,
            'vwap' => null,
            'open' => null,
            'close' => null,
            'last' => $this->safe_string($tickerData, 'latest'),
            'previousClose' => null,
            'change' => null,
            'percentage' => $this->safe_string($tickerData, 'change'),
            'average' => null,
            'baseVolume' => $this->safe_string($tickerData, 'vol'),
            'quoteVolume' => $this->safe_string($tickerData, 'turnover'),
            'info' => $ticker,
        ), $market);
    }

    public function fetch_ticker($symbol, $params = array ()) {
        /**
         * fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
         * @param {str} $symbol unified $symbol of the $market to fetch the ticker for
         * @param {dict} $params extra parameters specific to the lbank2 api endpoint
         * @return {dict} a {@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structure}
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        // preferred ticker/24h endpoint is down
        $response = $this->publicGetTicker (array_merge($request, $params));
        //
        //      {
        //          "result":"true",
        //          "data" => array(
        //              {
        //                  "symbol":"btc_usdt",
        //                  "ticker":array(
        //                          "high":40200.88,
        //                          "vol":7508.3096,
        //                          "low":38239.38,
        //                          "change":0.75,
        //                          "turnover":292962771.34,
        //                          "latest":39577.95
        //                      ),
        //                  "timestamp":1647005189792
        //               }
        //                   ),
        //          "error_code":0,"ts":1647005190755
        //      }
        //
        $data = $this->safe_value($response, 'data', array());
        $first = $this->safe_value($data, 0, array());
        return $this->parse_ticker($first, $market);
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        /**
         * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
         * @param {str} $symbol unified $symbol of the $market to fetch the order book for
         * @param {int|null} $limit the maximum amount of order book entries to return
         * @param {dict} $params extra parameters specific to the lbank2 api endpoint
         * @return {dict} A dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure order book structures} indexed by $market symbols
         */
        $this->load_markets();
        $market = $this->market($symbol);
        if ($limit === null) {
            $limit = 60;
        }
        $request = array(
            'symbol' => $market['id'],
            'size' => $limit,
        );
        $response = $this->publicGetDepth (array_merge($request, $params));
        $orderbook = $response['data'];
        $timestamp = $this->milliseconds();
        return $this->parse_order_book($orderbook, $symbol, $timestamp);
    }

    public function parse_trade($trade, $market = null) {
        //
        // fetchTrades (old) publicGetTrades
        //
        //      {
        //          "date_ms":1647021989789,
        //          "amount":0.0028,
        //          "price":38804.2,
        //          "type":"buy",
        //          "tid":"52d5616ee35c43019edddebe59b3e094"
        //      }
        //
        //
        // fetchTrades (new) publicGetTradesSupplement
        //
        //      {
        //          "quoteQty":1675.048485,
        //          "price":0.127545,
        //          "qty":13133,
        //          "id":"3589541dc22e4357b227283650f714e2",
        //          "time":1648058297110,
        //          "isBuyerMaker":false
        //      }
        //
        // fetchMyTrades (private)
        //
        //      {
        //          "orderUuid":"38b4e7a4-14f6-45fd-aba1-1a37024124a0",
        //          "tradeFeeRate":0.0010000000,
        //          "dealTime":1648500944496,
        //          "dealQuantity":30.00000000000000000000,
        //          "tradeFee":0.00453300000000000000,
        //          "txUuid":"11f3850cc6214ea3b495adad3a032794",
        //          "dealPrice":0.15111300000000000000,
        //          "dealVolumePrice":4.53339000000000000000,
        //          "tradeType":"sell_market"
        //      }
        //
        $timestamp = $this->safe_integer_2($trade, 'date_ms', 'time');
        if ($timestamp === null) {
            $timestamp = $this->safe_integer($trade, 'dealTime');
        }
        $amountString = $this->safe_string_2($trade, 'amount', 'qty');
        if ($amountString === null) {
            $amountString = $this->safe_string($trade, 'dealQuantity');
        }
        $priceString = $this->safe_string($trade, 'price');
        if ($priceString === null) {
            $priceString = $this->safe_string($trade, 'dealPrice');
        }
        $costString = $this->safe_string($trade, 'quoteQty');
        if ($costString === null) {
            $costString = $this->safe_string($trade, 'dealVolumePrice');
        }
        $side = $this->safe_string_2($trade, 'tradeType', 'type');
        $type = null;
        $takerOrMaker = null;
        if ($side !== null) {
            $parts = explode('_', $side);
            $side = $this->safe_string($parts, 0);
            $typePart = $this->safe_string($parts, 1);
            $type = 'limit';
            $takerOrMaker = 'taker';
            if ($typePart !== null) {
                if ($typePart === 'market') {
                    $type = 'market';
                } elseif ($typePart === 'maker') {
                    $takerOrMaker = 'maker';
                }
            }
        }
        $id = $this->safe_string_2($trade, 'tid', 'id');
        if ($id === null) {
            $id = $this->safe_string($trade, 'txUuid');
        }
        $order = $this->safe_string($trade, 'orderUuid');
        $symbol = $this->safe_symbol(null, $market);
        $fee = null;
        $feeCost = $this->safe_string($trade, 'tradeFee');
        if ($feeCost !== null) {
            $fee = array(
                'cost' => $feeCost,
                'currency' => null,
                'rate' => $this->safe_string($trade, 'tradeFeeRate'),
            );
        }
        return $this->safe_trade(array(
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'id' => $id,
            'order' => $order,
            'type' => $type,
            'takerOrMaker' => $takerOrMaker,
            'side' => $side,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => $costString,
            'fee' => $fee,
            'info' => $trade,
        ), $market);
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        /**
         * get the list of most recent $trades for a particular $symbol
         * @param {str} $symbol unified $symbol of the $market to fetch $trades for
         * @param {int|null} $since timestamp in ms of the earliest trade to fetch
         * @param {int|null} $limit the maximum amount of $trades to fetch
         * @param {dict} $params extra parameters specific to the lbank2 api endpoint
         * @return {[dict]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades trade structures~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($since !== null) {
            $request['time'] = $since;
        }
        if ($limit !== null) {
            $request['size'] = $limit;
        } else {
            $request['size'] = 600; // max
        }
        $method = $this->safe_string($params, 'method');
        $params = $this->omit($params, 'method');
        if ($method === null) {
            $options = $this->safe_value($this->options, 'fetchTrades', array());
            $method = $this->safe_string($options, 'method', 'publicGetTrades');
        }
        $response = $this->$method (array_merge($request, $params));
        //
        //      {
        //          "result":"true",
        //          "data" => array(
        //              {
        //                  "date_ms":1647021989789,
        //                  "amount":0.0028,
        //                  "price":38804.2,
        //                  "type":"buy",
        //                  "tid":"52d5616ee35c43019edddebe59b3e094"
        //               }
        //           ),
        //           "error_code":0,
        //           "ts":1647021999308
        //      }
        $trades = $this->safe_value($response, 'data', array());
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        //
        //   array(
        //     1482311500, // timestamp
        //     5423.23,    // open
        //     5472.80,    // high
        //     5516.09,    // low
        //     5462,       // close
        //     234.3250    // volume
        //   ),
        //
        return array(
            $this->safe_timestamp($ohlcv, 0), // timestamp
            $this->safe_number($ohlcv, 1), // open
            $this->safe_number($ohlcv, 2), // high
            $this->safe_number($ohlcv, 3), // low
            $this->safe_number($ohlcv, 4), // close
            $this->safe_number($ohlcv, 5), // volume
        );
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        /**
         * fetches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
         * @param {str} $symbol unified $symbol of the $market to fetch OHLCV data for
         * @param {str} $timeframe the length of time each candle represents
         * @param {int|null} $since timestamp in ms of the earliest candle to fetch
         * @param {int|null} $limit the maximum amount of candles to fetch
         * @param {dict} $params extra parameters specific to the lbank2 api endpoint
         * @return {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
         */
        // endpoint doesnt work
        $this->load_markets();
        $market = $this->market($symbol);
        if ($since === null) {
            throw new ArgumentsRequired($this->id . ' fetchOHLCV () requires a $since argument');
        }
        if ($limit === null) {
            $limit = 100;
        }
        $request = array(
            'symbol' => $market['id'],
            'type' => $this->timeframes[$timeframe],
            'time' => intval($since / 1000),
            'size' => $limit, // max 2000
        );
        $response = $this->publicGetKline (array_merge($request, $params));
        $ohlcvs = $this->safe_value($response, 'data', array());
        //
        //
        // array(
        //   array(
        //     1482311500,
        //     5423.23,
        //     5472.80,
        //     5516.09,
        //     5462,
        //     234.3250
        //   ),
        //   array(
        //     1482311400,
        //     5432.52,
        //     5459.87,
        //     5414.30,
        //     5428.23,
        //     213.7329
        //   )
        // )
        //
        return $this->parse_ohlcvs($ohlcvs, $market, $timeframe, $since, $limit);
    }

    public function parse_balance($response) {
        //
        // privatePostUserInfo
        //
        //      {
        //          "toBtc" => array(
        //              "egc:" => "0",
        //              "iog" => "0",
        //              "ksm" => "0",
        //              ),
        //          "freeze" => array(
        //              "egc" => "0",
        //              "iog" => "0",
        //              "ksm" => "0" ,
        //              ),
        //          "asset" => array(
        //              "egc" => "0",
        //              "iog" => "0",
        //              "ksm" => "0",
        //              ),
        //          "free" => {
        //              "egc" => "0",
        //              "iog" => "0",
        //              "ksm" => "0",
        //              }
        //      }
        //
        // privatePostSupplementUserInfoAccount
        //
        //      {
        //          "balances":array(
        //              array(
        //                  "asset":"lbk",
        //                  "free":"0",
        //                  "locked":"0"
        //              ), ...
        //          )
        //      }
        //
        // privatePostSupplementUserInfo
        //
        //      array(
        //          {
        //              "usableAmt":"31.45130723",
        //              "assetAmt":"31.45130723",
        //              "networkList":array(
        //                  array(
        //                      "isDefault":true,
        //                      "withdrawFeeRate":"",
        //                      "name":"bep20(bsc)",
        //                      "withdrawMin":30,
        //                      "minLimit":0.0001,
        //                      "minDeposit":0.0001,
        //                      "feeAssetCode":"doge",
        //                      "withdrawFee":"30",
        //                      "type":1,
        //                      "coin":"doge",
        //                      "network":"bsc"
        //                  ),
        //                  array(
        //                      "isDefault":false,
        //                      "withdrawFeeRate":"",
        //                      "name":"dogecoin",
        //                      "withdrawMin":10,
        //                      "minLimit":0.0001,
        //                      "minDeposit":10,
        //                      "feeAssetCode":"doge",
        //                      "withdrawFee":"10",
        //                      "type":1,
        //                      "coin":"doge",
        //                      "network":"dogecoin"
        //                  }
        //              ),
        //              "freezeAmt":"0",
        //              "coin":"doge"
        //          ), ...
        //      )
        //
        $timestamp = $this->safe_integer($response, 'ts');
        $result = array(
            'info' => $response,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
        );
        $data = $this->safe_value($response, 'data');
        // from privatePostUserInfo
        $toBtc = $this->safe_value($data, 'toBtc');
        if ($toBtc !== null) {
            $used = $this->safe_value($data, 'freeze', array());
            $free = $this->safe_value($data, 'free', array());
            $currencies = is_array($free) ? array_keys($free) : array();
            for ($i = 0; $i < count($currencies); $i++) {
                $currencyId = $currencies[$i];
                $code = $this->safe_currency_code($currencyId);
                $account = $this->account();
                $account['used'] = $this->safe_string($used, $currencyId);
                $account['free'] = $this->safe_string($free, $currencyId);
                $result[$code] = $account;
            }
            return $this->safe_balance($result);
        }
        // from privatePostSupplementUserInfoAccount
        $balances = $this->safe_value($data, 'balances');
        if ($balances !== null) {
            for ($i = 0; $i < count($balances); $i++) {
                $item = $balances[$i];
                $currencyId = $this->safe_string($item, 'asset');
                $code = $this->safe_currency_code($currencyId);
                $account = $this->account();
                $account['free'] = $this->safe_string($item, 'free');
                $account['used'] = $this->safe_string($item, 'locked');
                $result[$code] = $account;
            }
            return $this->safe_balance($result);
        }
        // from privatePostSupplementUserInfo
        $isArray = gettype($data) === 'array' && count(array_filter(array_keys($data), 'is_string')) == 0;
        if ($isArray === true) {
            for ($i = 0; $i < count($data); $i++) {
                $item = $data[$i];
                $currencyId = $this->safe_string($item, 'coin');
                $code = $this->safe_currency_code($currencyId);
                $account = $this->account();
                $account['free'] = $this->safe_string($item, 'usableAmt');
                $account['used'] = $this->safe_string($item, 'freezeAmt');
                $result[$code] = $account;
            }
            return $this->safe_balance($result);
        }
    }

    public function fetch_balance($params = array ()) {
        /**
         * query for balance and get the amount of funds available for trading or funds locked in orders
         * @param {dict} $params extra parameters specific to the lbank2 api endpoint
         * @return {dict} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
         */
        $this->load_markets();
        $method = $this->safe_string($params, 'method');
        if ($method === null) {
            $options = $this->safe_value($this->options, 'fetchBalance', array());
            $method = $this->safe_string($options, 'method', 'privatePostSupplementUserInfo');
        }
        $response = $this->$method ();
        return $this->parse_balance($response);
    }

    public function parse_trading_fee($fee, $market = null) {
        //
        //      {
        //          "symbol":"skt_usdt",
        //          "makerCommission":"0.10",
        //          "takerCommission":"0.10"
        //      }
        //
        $marketId = $this->safe_string($fee, 'symbol');
        $symbol = $this->safe_symbol($marketId);
        return array(
            'info' => $fee,
            'symbol' => $symbol,
            'maker' => $this->safe_number($fee, 'makerCommission'),
            'taker' => $this->safe_number($fee, 'takerCommission'),
        );
    }

    public function fetch_trading_fee($symbol, $params = array ()) {
        $market = $this->market($symbol);
        $result = $this->fetch_trading_fees(array_merge($params, array( 'category' => $market['id'] )));
        return $result;
    }

    public function fetch_trading_fees($params = array ()) {
        $this->load_markets();
        $request = array();
        $response = $this->privatePostSupplementCustomerTradeFee (array_merge($request, $params));
        $fees = $this->safe_value($response, 'data', array());
        $result = array();
        for ($i = 0; $i < count($fees); $i++) {
            $fee = $this->parse_trading_fee($fees[$i]);
            $symbol = $fee['symbol'];
            $result[$symbol] = $fee;
        }
        return $result;
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $clientOrderId = $this->safe_string_2($params, 'custom_id', 'clientOrderId');
        $postOnly = $this->safe_value($params, 'postOnly', false);
        $timeInForce = $this->safe_string_upper($params, 'timeInForce');
        $params = $this->omit($params, array( 'custom_id', 'clientOrderId', 'timeInForce', 'postOnly' ));
        $request = array(
            'symbol' => $market['id'],
        );
        $ioc = ($timeInForce === 'IOC');
        $fok = ($timeInForce === 'FOK');
        $maker = ($postOnly || ($timeInForce === 'PO'));
        if (($type === 'market') && ($ioc || $fok || $maker)) {
            throw new InvalidOrder($this->id . ' createOrder () does not allow $market FOK, IOC, or $postOnly orders. Only limit IOC, FOK, and $postOnly orders are allowed');
        }
        if ($type === 'limit') {
            $request['type'] = $side;
            $request['price'] = $this->price_to_precision($symbol, $price);
            $request['amount'] = $this->amount_to_precision($symbol, $amount);
            if ($ioc) {
                $request['type'] = $side . '_' . 'ioc';
            } elseif ($fok) {
                $request['type'] = $side . '_' . 'fok';
            } elseif ($maker) {
                $request['type'] = $side . '_' . 'maker';
            }
        } elseif ($type === 'market') {
            if ($side === 'sell') {
                $request['type'] = $side . '_' . 'market';
                $request['amount'] = $this->amount_to_precision($symbol, $amount);
            } elseif ($side === 'buy') {
                $request['type'] = $side . '_' . 'market';
                if ($this->options['createMarketBuyOrderRequiresPrice']) {
                    if ($price === null) {
                        throw new InvalidOrder($this->id . " createOrder () requires the $price argument with $market buy orders to calculate total order $cost ($amount to spend), where $cost = $amount * $price-> Supply the $price argument to createOrder() call if you want the $cost to be calculated for you from $price and $amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the $cost in the $amount argument (the exchange-specific behaviour)");
                    } else {
                        $cost = floatval($amount) * floatval($price);
                        $request['price'] = $this->price_to_precision($symbol, $cost);
                    }
                } else {
                    $request['price'] = $amount;
                }
            }
        }
        if ($clientOrderId !== null) {
            $request['custom_id'] = $clientOrderId;
        }
        $method = null;
        $method = $this->safe_string($params, 'method');
        $params = $this->omit($params, 'method');
        if ($method === null) {
            $options = $this->safe_value($this->options, 'createOrder', array());
            $method = $this->safe_string($options, 'method', 'privatePostSupplementCreateOrder');
        }
        $response = $this->$method (array_merge($request, $params));
        //
        //      {
        //          "result":true,
        //          "data":array(
        //              "symbol":"doge_usdt",
        //              "order_id":"0cf8a3de-4597-4296-af45-be7abaa06b07"
        //              ),
        //          "error_code":0,
        //          "ts":1648162321043
        //      }
        //
        $result = $this->safe_value($response, 'data', array());
        return array(
            'id' => $this->safe_string($result, 'order_id'),
            'info' => $result,
        );
    }

    public function parse_order_status($status) {
        $statuses = array(
            '-1' => 'cancelled', // cancelled
            '0' => 'open', // not traded
            '1' => 'open', // partial deal
            '2' => 'closed', // complete deal
            '3' => 'closed', // filled partially and cancelled
            '4' => 'closed', // disposal processing
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order($order, $market = null) {
        //
        // fetchOrderSupplement (private)
        //
        //      {
        //          "cummulativeQuoteQty":0,
        //          "symbol":"doge_usdt",
        //          "executedQty":0,
        //          "orderId":"53d2d53e-70fb-4398-b722-f48571a5f61e",
        //          "origQty":1E+2,
        //          "price":0.05,
        //          "clientOrderId":null,
        //          "origQuoteOrderQty":5,
        //          "updateTime":1648163406000,
        //          "time":1648163139387,
        //          "type":"buy_maker",
        //          "status":-1
        //      }
        //
        //
        // fetchOrderDefault (private)
        //
        //      {
        //          "symbol":"shib_usdt",
        //          "amount":1,
        //          "create_time":1649367863356,
        //          "price":0.0000246103,
        //          "avg_price":0.00002466180000000104,
        //          "type":"buy_market",
        //          "order_id":"abe8b92d-86d9-4d6d-b71e-d14f5fb53ddf",
        //          "custom_id" => "007",                                 // field only present if user creates it at $order time
        //          "deal_amount":40548.54065802,
        //          "status":2
        //      }
        //
        // fetchOpenOrders (private)
        //
        //      {
        //          "cummulativeQuoteQty":0,
        //          "symbol":"doge_usdt",
        //          "executedQty":0,
        //          "orderId":"73878edf-008d-4e4c-8041-df1f1b2cd8bb",
        //          "origQty":100,
        //          "price":0.05,
        //          "origQuoteOrderQty":5,
        //          "updateTime":1648501762000,
        //          "time":1648501762353,
        //          "type":"buy",
        //          "status":0
        //      }
        //
        // fetchOrders (private)
        //
        //      {
        //          "cummulativeQuoteQty":0,
        //          "symbol":"doge_usdt",
        //          "executedQty":0,
        //          "orderId":"2cadc7cc-b5f6-486b-a5b4-d6ac49a9c186",
        //          "origQty":100,
        //          "price":0.05,
        //          "origQuoteOrderQty":5,
        //          "updateTime":1648501384000,
        //          "time":1648501363889,
        //          "type":"buy",
        //          "status":-1
        //      }
        //
        $id = $this->safe_string_2($order, 'orderId', 'order_id');
        $clientOrderId = $this->safe_string_2($order, 'clientOrderId', 'custom_id');
        $timestamp = $this->safe_string_2($order, 'time', 'create_time');
        $rawStatus = $this->safe_string($order, 'status');
        $marketId = $this->safe_string($order, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $timeInForce = null;
        $postOnly = false;
        $type = 'limit';
        $rawType = $this->safe_string($order, 'type'); // buy, sell, buy_market, sell_market, buy_maker,sell_maker,buy_ioc,sell_ioc, buy_fok, sell_fok
        $parts = explode('_', $rawType);
        $side = $this->safe_string($parts, 0);
        $typePart = $this->safe_string($parts, 1); // $market, maker, ioc, fok or null (limit)
        if ($typePart === 'market') {
            $type = 'market';
        }
        if ($typePart === 'maker') {
            $postOnly = true;
            $timeInForce = 'PO';
        }
        if ($typePart === 'ioc') {
            $timeInForce = 'IOC';
        }
        if ($typePart === 'fok') {
            $timeInForce = 'FOK';
        }
        $price = $this->safe_string($order, 'price');
        $costString = $this->safe_string($order, 'cummulativeQuoteQty');
        $amountString = null;
        if ($rawType !== 'buy_market') {
            $amountString = $this->safe_string_2($order, 'origQty', 'amount');
        }
        $filledString = $this->safe_string_2($order, 'executedQty', 'deal_amount');
        return $this->safe_order(array(
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'datetime' => $this->iso8601($timestamp),
            'timestamp' => $timestamp,
            'lastTradeTimestamp' => null,
            'status' => $this->parse_order_status($rawStatus),
            'symbol' => $market['symbol'],
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => $postOnly,
            'side' => $side,
            'price' => $price,
            'stopPrice' => null,
            'cost' => $costString,
            'amount' => $amountString,
            'filled' => $filledString,
            'remaining' => null,
            'trades' => null,
            'fee' => null,
            'info' => $order,
            'average' => null,
        ), $market);
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        $method = $this->safe_string($params, 'method');
        if ($method === null) {
            $options = $this->safe_value($this->options, 'fetchOrder', array());
            $method = $this->safe_string($options, 'method', 'fetchOrderSupplement');
        }
        $result = $this->$method ($id, $symbol, $params);
        return $result;
    }

    public function fetch_order_supplement($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrder () requires a $symbol argument');
        }
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'orderId' => $id,
        );
        $response = $this->privatePostSupplementOrdersInfo (array_merge($request, $params));
        //
        //      {
        //          "result":true,
        //          "data":array(
        //              "cummulativeQuoteQty":0,
        //              "symbol":"doge_usdt",
        //              "executedQty":0,
        //              "orderId":"53d2d53e-70fb-4398-b722-f48571a5f61e",
        //              "origQty":1E+2,
        //              "price":0.05,
        //              "clientOrderId":null,
        //              "origQuoteOrderQty":5,
        //              "updateTime":1648163406000,
        //              "time":1648163139387,
        //              "type":"buy_maker",
        //              "status":-1
        //              ),
        //          "error_code":0,
        //          "ts":1648164471827
        //      }
        //
        $result = $this->safe_value($response, 'data', array());
        return $this->parse_order($result);
    }

    public function fetch_order_default($id, $symbol = null, $params = array ()) {
        // Id can be a list of ids delimited by a comma
        $this->load_markets();
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrder () requires a $symbol argument');
        }
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'order_id' => $id,
        );
        $response = $this->privatePostOrdersInfo (array_merge($request, $params));
        //
        //      {
        //          "result":true,
        //          "data":array(
        //              {
        //                  "symbol":"doge_usdt",
        //                  "amount":18,
        //                  "create_time":1647455223186,
        //                  "price":0,
        //                  "avg_price":0.113344,
        //                  "type":"sell_market",
        //                  "order_id":"d4ca1ddd-40d9-42c1-9717-5de435865bec",
        //                  "deal_amount":18,
        //                  "status":2
        //                }
        //            ),
        //          "error_code":0,
        //          "ts":1647455270776
        //      }
        //
        $result = $this->safe_value($response, 'data', array());
        $numOrders = is_array($result) ? count($result) : 0;
        if ($numOrders === 1) {
            return $this->parse_order($result[0]);
        } else {
            $parsedOrders = array();
            for ($i = 0; $i < $numOrders; $i++) {
                $parsedOrder = $this->parse_order($result[$i]);
                $parsedOrders[] = $parsedOrder;
            }
            return $parsedOrders;
        }
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchMyTrades () requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $since = $this->safe_value($params, 'start_date', $since);
        $params = $this->omit($params, 'start_date');
        $request = array(
            'symbol' => $market['id'],
            // 'start_date' => String Start time yyyy-mm-dd, the maximum is today, the default is yesterday
            // 'end_date' => String Finish time yyyy-mm-dd, the maximum is today, the default is today
            // 'The start' => and end date of the query window is up to 2 days
            // 'from' => String Initial transaction number inquiring
            // 'direct' => String inquire direction,The default is the 'next' which is the positive sequence of dealing time，the 'prev' is inverted order of dealing time
            // 'size' => String Query the number of defaults to 100
        );
        if ($limit !== null) {
            $request['size'] = $limit;
        }
        if ($since !== null) {
            $request['start_date'] = $this->ymd($since, '-'); // max query 2 days ago
        }
        $response = $this->privatePostTransactionHistory (array_merge($request, $params));
        //
        //      {
        //          "result":true,
        //          "data":array(
        //              {
        //                  "orderUuid":"38b4e7a4-14f6-45fd-aba1-1a37024124a0",
        //                  "tradeFeeRate":0.0010000000,
        //                  "dealTime":1648500944496,
        //                  "dealQuantity":30.00000000000000000000,
        //                  "tradeFee":0.00453300000000000000,
        //                  "txUuid":"11f3850cc6214ea3b495adad3a032794",
        //                  "dealPrice":0.15111300000000000000,
        //                  "dealVolumePrice":4.53339000000000000000,
        //                  "tradeType":"sell_market"
        //              }
        //          ),
        //          "error_code":0,
        //          "ts":1648509742164
        //      }
        //
        $trades = $this->safe_value($response, 'data', array());
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        // default query is for cancelled and completely filled $orders
        // does not return open $orders unless specified explicitly
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrders() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        if ($limit === null) {
            $limit = 100;
        }
        $request = array(
            'symbol' => $market['id'],
            'current_page' => 1,
            'page_length' => $limit,
            // 'status'  -1 => Cancelled, 0 => Unfilled, 1 => Partially filled, 2 => Completely filled, 3 => Partially filled and cancelled, 4 => Cancellation is being processed
        );
        $response = $this->privatePostSupplementOrdersInfoHistory (array_merge($request, $params));
        //
        //      {
        //          "result":true,
        //          "data":array(
        //              "total":1,
        //              "page_length":100,
        //              "orders":array(
        //                  array(
        //                      "cummulativeQuoteQty":0,
        //                      "symbol":"doge_usdt",
        //                      "executedQty":0,
        //                      "orderId":"2cadc7cc-b5f6-486b-a5b4-d6ac49a9c186",
        //                      "origQty":100,
        //                      "price":0.05,
        //                      "origQuoteOrderQty":5,
        //                      "updateTime":1648501384000,
        //                      "time":1648501363889,
        //                      "type":"buy",
        //                      "status":-1
        //                  ), ...
        //              ),
        //              "current_page":1
        //          ),
        //          "error_code":0,
        //          "ts":1648505706348
        //      }
        //
        $result = $this->safe_value($response, 'data', array());
        $orders = $this->safe_value($result, 'orders', array());
        return $this->parse_orders($orders, $market, $since, $limit);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOpenOrders() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        if ($limit === null) {
            $limit = 100;
        }
        $request = array(
            'symbol' => $market['id'],
            'current_page' => 1,
            'page_length' => $limit,
        );
        $response = $this->privatePostSupplementOrdersInfoNoDeal (array_merge($request, $params));
        //
        //      {
        //          "result":true,
        //          "data":array(
        //              "total":1,
        //              "page_length":100,
        //              "orders":array(
        //                  array(
        //                      "cummulativeQuoteQty":0,
        //                      "symbol":"doge_usdt",
        //                      "executedQty":0,
        //                      "orderId":"73878edf-008d-4e4c-8041-df1f1b2cd8bb",
        //                      "origQty":100,
        //                      "price":0.05,
        //                      "origQuoteOrderQty":5,
        //                      "updateTime":1648501762000,
        //                      "time":1648501762353,
        //                      "type":"buy",
        //                      "status":0
        //                  ), ...
        //             ),
        //             "current_page":1
        //         ),
        //         "error_code":0,
        //         "ts":1648506110196
        //     }
        //
        $result = $this->safe_value($response, 'data', array());
        $orders = $this->safe_value($result, 'orders', array());
        return $this->parse_orders($orders, $market, $since, $limit);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument');
        }
        $this->load_markets();
        $clientOrderId = $this->safe_string_2($params, 'origClientOrderId', 'clientOrderId');
        $params = $this->omit($params, array( 'origClientOrderId', 'clientOrderId' ));
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($clientOrderId !== null) {
            $request['origClientOrderId'] = $clientOrderId;
        }
        $request['orderId'] = $id;
        $response = $this->privatePostSupplementCancelOrder (array_merge($request, $params));
        //
        //   {
        //      "result":true,
        //      "data":array(
        //          "executedQty":0.0,
        //          "price":0.05,
        //          "origQty":100.0,
        //          "tradeType":"buy",
        //          "status":0
        //          ),
        //      "error_code":0,
        //      "ts":1648501286196
        //  }
        $result = $this->safe_value($response, 'data', array());
        return $result;
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelAllOrders() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = $this->privatePostSupplementCancelOrderBySymbol (array_merge($request, $params));
        //
        //      {
        //          "result":"true",
        //          "data":array(
        //              array(
        //                  "executedQty":0.00000000000000000000,
        //                  "orderId":"293ef71b-3e67-4962-af93-aa06990a045f",
        //                  "price":0.05000000000000000000,
        //                  "origQty":100.00000000000000000000,
        //                  "tradeType":"buy",
        //                  "status":0
        //              ),
        //          ),
        //          "error_code":0,
        //          "ts":1648506641469
        //      }
        //
        $result = $this->safe_value($response, 'data', array());
        return $result;
    }

    public function fetch_deposit_address($code, $params = array ()) {
        $this->load_markets();
        $method = $this->safe_string($params, 'method');
        $params = $this->omit($params, 'method');
        if ($method === null) {
            $options = $this->safe_value($this->options, 'fetchDepositAddress', array());
            $method = $this->safe_string($options, 'method', 'fetchPrivateTradingFees');
        }
        return $this->$method ($code, $params);
    }

    public function fetch_deposit_address_default($code, $params = array ()) {
        $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'assetCode' => $currency['id'],
        );
        $networks = $this->safe_value($this->options, 'networks');
        $network = $this->safe_string_upper($params, 'network');
        $network = $this->safe_string($networks, $network, $network);
        if ($network !== null) {
            $request['netWork'] = $network; // ... yes, really lol
            $params = $this->omit($params, 'network');
        }
        $response = $this->privatePostGetDepositAddress (array_merge($request, $params));
        //
        //      {
        //          "result":true,
        //          "data":array(
        //              "assetCode":"usdt",
        //              "address":"0xc85689d37ca650bf2f2161364cdedee21eb6ca53",
        //              "memo":null,
        //              "netWork":"bep20(bsc)"
        //              ),
        //          "error_code":0,
        //          "ts":1648075865103
        //      }
        //
        $result = $this->safe_value($response, 'data');
        $address = $this->safe_string($result, 'address');
        $tag = $this->safe_string($result, 'memo');
        $networkId = $this->safe_string($result, 'netWork');
        $inverseNetworks = $this->safe_value($this->options, 'inverse-networks', array());
        $networkCode = $this->safe_string_upper($inverseNetworks, $networkId, $networkId);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => $tag,
            'network' => $networkCode,
            'info' => $response,
        );
    }

    public function fetch_deposit_address_supplement($code, $params = array ()) {
        // returns the $address for whatever the default $network is...
        $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'coin' => $currency['id'],
        );
        $networks = $this->safe_value($this->options, 'networks');
        $network = $this->safe_string_upper($params, 'network');
        $network = $this->safe_string($networks, $network, $network);
        if ($network !== null) {
            $request['networkName'] = $network;
            $params = $this->omit($params, 'network');
        }
        $response = $this->privatePostSupplementGetDepositAddress (array_merge($request, $params));
        //
        //      {
        //          "result":true,
        //          "data":array(
        //              "address":"TDxtabCC8iQwaxUUrPcE4WL2jArGAfvQ5A",
        //              "memo":null,
        //              "coin":"usdt"
        //              ),
        //          "error_code":0,
        //          "ts":1648073818880
        //     }
        //
        $result = $this->safe_value($response, 'data');
        $address = $this->safe_string($result, 'address');
        $tag = $this->safe_string($result, 'memo');
        $inverseNetworks = $this->safe_value($this->options, 'inverse-networks', array());
        $networkCode = $this->safe_string_upper($inverseNetworks, $network, $network);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => $tag,
            'network' => $networkCode, // will be null if not specified in $request
            'info' => $response,
        );
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
        $this->check_address($address);
        $this->load_markets();
        $fee = $this->safe_string($params, 'fee');
        $params = $this->omit($params, 'fee');
        if ($fee === null) {
            throw new ArgumentsRequired($this->id . ' withdraw () requires a $fee argument to be supplied in $params, the relevant coin $network $fee can be found by calling fetchTransactionFees (), note => if no $network param is supplied then the default $network will be used, this can also be found in fetchTransactionFees ()');
        }
        $currency = $this->currency($code);
        $request = array(
            'address' => $address,
            'coin' => $currency['id'],
            'amount' => $amount,
            'fee' => $fee, // the correct coin-$network $fee must be supplied, which can be found by calling fetchTransactionFees (private)
            // 'networkName' => defaults to the defaultNetwork of the coin which can be found in the /supplement/user_info endpoint
            // 'memo' => memo => memo word of bts and dct
            // 'mark' => Withdrawal Notes
            // 'name' => Remarks of the $address-> After filling in this parameter, it will be added to the withdrawal $address book of the $currency->
            // 'withdrawOrderId' => withdrawOrderId
            // 'type' => type=1 is for intra-site transfer
        );
        if ($tag !== null) {
            $request['memo'] = $tag;
        }
        $network = $this->safe_string_upper_2($params, 'network', 'networkName');
        $params = $this->omit($params, array( 'network', 'networkName' ));
        $networks = $this->safe_value($this->options, 'networks');
        $networkId = $this->safe_string($networks, $network, $network);
        if ($networkId !== null) {
            $request['networkName'] = $networkId;
        }
        $response = $this->privatePostSupplementWithdraw (array_merge($request, $params));
        //
        //      {
        //          "result":true,
        //          "data" => array(
        //              "fee":10.00000000000000000000,
        //              "withdrawId":1900376
        //              ),
        //          "error_code":0,
        //          "ts":1648992501414
        //      }
        //
        $result = $this->safe_value($response, 'data', array());
        return array(
            'info' => $result,
            'id' => $this->safe_string($result, 'withdrawId'),
        );
    }

    public function parse_deposit_status($status) {
        $statuses = array(
            '1' => 'pending',
            '2' => 'ok',
            '3' => 'failed',
            '4' => 'cancelled',
            '5' => 'transfer',   // Transfer
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_withdrawal_status($status) {
        $statuses = array(
            '1' => 'pending',
            '2' => 'cancelled',
            '3' => 'failed',
            '4' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // fetchDeposits (private)
        //
        //      {
        //          "insertTime":1649012310000,
        //          "amount":9.00000000000000000000,
        //          "address":"TYASr5UV6HEcXatwdFQfmLVUqQQQMUxHLS",
        //          "networkName":"trc20",
        //          "txId":"081e4e9351dd0274922168da5f2d14ea6c495b1c3b440244f4a6dd9fe196bf2b",
        //          "coin":"usdt",
        //          "status":"2"
        //      }
        //
        //
        // fetchWithdrawals (private)
        //
        //      {
        //          "amount":2.00000000000000000000,
        //          "address":"TBjrW5JHDyPZjFc5nrRMhRWUDaJmhGhmD6",
        //          "fee":1.00000000000000000000,
        //          "networkName":"trc20",
        //          "coid":"usdt",
        //          "transferType":"数字资产提现",
        //          "txId":"47eeee2763ad49b8817524dacfa7d092fb58f8b0ab7e5d25473314df1a793c3d",
        //          "id":1902194,
        //          "applyTime":1649014002000,
        //          "status":"4"
        //      }
        //
        $id = $this->safe_string($transaction, 'id');
        $type = null;
        if ($id === null) {
            $type = 'deposit';
        } else {
            $type = 'withdrawal';
        }
        $txid = $this->safe_string($transaction, 'txId');
        $timestamp = $this->safe_string_2($transaction, 'insertTime', 'applyTime');
        $networks = $this->safe_value($this->options, 'inverse-networks', array());
        $networkId = $this->safe_string($transaction, 'networkName');
        $network = $this->safe_string($networks, $networkId, $networkId);
        $address = $this->safe_string($transaction, 'address');
        $addressFrom = null;
        $addressTo = null;
        if ($type === 'deposit') {
            $addressFrom = $address;
        } else {
            $addressTo = $address;
        }
        $amount = $this->safe_number($transaction, 'amount');
        $currencyId = $this->safe_string_2($transaction, 'coin', 'coid');
        $code = $this->safe_currency_code($currencyId, $currency);
        $statusId = $this->safe_string($transaction, 'status');
        $status = null;
        if ($type === 'deposit') {
            $status = $this->parse_deposit_status($statusId);
        } else {
            $status = $this->parse_withdrawal_status($statusId);
        }
        $fee = null;
        $feeCost = $this->safe_number($transaction, 'fee');
        if ($feeCost !== null) {
            $fee = array(
                'cost' => $feeCost,
                'currency' => $code,
            );
        }
        return array(
            'info' => $transaction,
            'id' => $id,
            'txid' => $txid,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => $network,
            'address' => $address,
            'addressTo' => $addressTo,
            'addressFrom' => $addressFrom,
            'tag' => null,
            'tagTo' => null,
            'tagFrom' => null,
            'type' => $type,
            'amount' => $amount,
            'currency' => $code,
            'status' => $status,
            'updated' => null,
            'comment' => null,
            'internal' => ($status === 'transfer'),
            'fee' => $fee,
        );
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            // 'status' => Recharge status => ("1","Applying"),("2","Recharge successful"),("3","Recharge failed"),("4","Already Cancel"), ("5", "Transfer")
            // 'endTime' => end time, timestamp in milliseconds, default now
        );
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['coin'] = $currency['id'];
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        $response = $this->privatePostSupplementDepositHistory (array_merge($request, $params));
        //
        //      {
        //          "result":true,
        //          "data" => array(
        //              "total":1,
        //              "depositOrders" => array(
        //                  array(
        //                      "insertTime":1649012310000,
        //                      "amount":9.00000000000000000000,
        //                      "address":"TYASr5UV6HEcXatwdFQfmLVUqQQQMUxHLS",
        //                      "networkName":"trc20",
        //                      "txId":"081e4e9351dd0274922168da5f2d14ea6c495b1c3b440244f4a6dd9fe196bf2b",
        //                      "coin":"usdt",
        //                      "status":"2"
        //                  ),
        //              ),
        //              "page_length":20,
        //              "current_page":1
        //          ),
        //          "error_code":0,
        //          "ts":1649719721758
        //      }
        //
        $data = $this->safe_value($response, 'data', array());
        $deposits = $this->safe_value($data, 'depositOrders', array());
        return $this->parse_transactions($deposits, $code, $since, $limit);
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            // 'status' => Recharge status => ("1","Applying"),("2","Recharge successful"),("3","Recharge failed"),("4","Already Cancel"), ("5", "Transfer")
            // 'endTime' => end time, timestamp in milliseconds, default now
            // 'withdrawOrderId' => Custom withdrawal id
        );
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['coin'] = $currency['id'];
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        $response = $this->privatePostSupplementWithdraws (array_merge($request, $params));
        //
        //      {
        //          "result":true,
        //          "data" => array(
        //              "total":1,
        //              "withdraws" => array(
        //                  array(
        //                      "amount":2.00000000000000000000,
        //                      "address":"TBjrW5JHDyPZjFc5nrRMhRWUDaJmhGhmD6",
        //                      "fee":1.00000000000000000000,
        //                      "networkName":"trc20",
        //                      "coid":"usdt",
        //                      "transferType":"数字资产提现",
        //                      "txId":"47eeee2763ad49b8817524dacfa7d092fb58f8b0ab7e5d25473314df1a793c3d",
        //                      "id":1902194,
        //                      "applyTime":1649014002000,
        //                      "status":"4"
        //                  ),
        //              ),
        //              "page_length":20,
        //              "current_page":1
        //          ),
        //          "error_code":0,
        //          "ts":1649720362362
        //      }
        //
        $data = $this->safe_value($response, 'data', array());
        $withdraws = $this->safe_value($data, 'withdraws', array());
        return $this->parse_transactions($withdraws, $code, $since, $limit);
    }

    public function fetch_transaction_fees($codes = null, $params = array ()) {
        // private only returns information for currencies with non-zero balance
        $this->load_markets();
        $isAuthorized = $this->check_required_credentials(false);
        $result = null;
        if ($isAuthorized === true) {
            $method = $this->safe_string($params, 'method');
            $params = $this->omit($params, 'method');
            if ($method === null) {
                $options = $this->safe_value($this->options, 'fetchTransactionFees', array());
                $method = $this->safe_string($options, 'method', 'fetchPrivateFundingFees');
            }
            $result = $this->$method ($params);
        } else {
            $result = $this->fetch_public_funding_fees($params);
        }
        return $result;
    }

    public function fetch_private_funding_fees($params = array ()) {
        // complete $response
        // incl. for coins which null in public method
        $this->load_markets();
        $response = $this->privatePostSupplementUserInfo ();
        $result = $this->safe_value($response, 'data', array());
        $withdrawFees = array();
        for ($i = 0; $i < count($result); $i++) {
            $entry = $result[$i];
            $currencyId = $this->safe_string($entry, 'coin');
            $code = $this->safe_currency_code($currencyId);
            $networkList = $this->safe_value($entry, 'networkList', array());
            $withdrawFees[$code] = array();
            for ($j = 0; $j < count($networkList); $j++) {
                $networkEntry = $networkList[$j];
                $networkId = $this->safe_string($networkEntry, 'name');
                $networkCode = $this->safe_string($this->options['inverse-networks'], $networkId, $networkId);
                $fee = $this->safe_number($networkEntry, 'withdrawFee');
                if ($fee !== null) {
                    $withdrawFees[$code][$networkCode] = $fee;
                }
            }
        }
        return array(
            'withdraw' => $withdrawFees,
            'deposit' => array(),
            'info' => $response,
        );
    }

    public function fetch_public_funding_fees($params = array ()) {
        // extremely incomplete $response
        // vast majority fees null
        $this->load_markets();
        $code = $this->safe_string_2($params, 'coin', 'assetCode');
        $params = $this->omit($params, array( 'coin', 'assetCode' ));
        $request = array();
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['assetCode'] = $currency['id'];
        }
        $response = $this->publicGetWithdrawConfigs (array_merge($request, $params));
        $result = $this->safe_value($response, 'data', array());
        $withdrawFees = array();
        for ($i = 0; $i < count($result); $i++) {
            $item = $result[$i];
            $canWithdraw = $this->safe_string($item, 'canWithDraw');
            if ($canWithdraw === 'true') {
                $currencyId = $this->safe_string($item, 'assetCode');
                $code = $this->safe_currency_code($currencyId);
                $chain = $this->safe_string($item, 'chain');
                $network = $this->safe_string($this->options['inverse-networks'], $chain, $chain);
                if ($network === null) {
                    $network = $code;
                }
                $fee = $this->safe_string($item, 'fee');
                if ($withdrawFees[$code] === null) {
                    $withdrawFees[$code] = array();
                }
                $withdrawFees[$code][$network] = $fee;
            }
        }
        return array(
            'withdraw' => $withdrawFees,
            'deposit' => array(),
            'info' => $response,
        );
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $query = $this->omit($params, $this->extract_params($path));
        $url = $this->urls['api'] . '/' . $this->version . '/' . $this->implode_params($path, $params);
        // Every endpoint ends with ".do"
        $url .= '.do';
        if ($api === 'public') {
            if ($query) {
                $url .= '?' . $this->urlencode($this->keysort($query));
            }
        } else {
            $this->check_required_credentials();
            $timestamp = (string) $this->milliseconds();
            $echostr = $this->uuid22() . $this->uuid16();
            $query = array_merge(array(
                'api_key' => $this->apiKey,
            ), $query);
            $signatureMethod = null;
            if (strlen($this->secret) > 32) {
                $signatureMethod = 'RSA';
            } else {
                $signatureMethod = 'HmacSHA256';
            }
            $auth = $this->rawencode($this->keysort(array_merge(array(
                'echostr' => $echostr,
                'signature_method' => $signatureMethod,
                'timestamp' => $timestamp,
            ), $query)));
            $encoded = $this->encode($auth);
            $hash = $this->hash($encoded);
            $uppercaseHash = strtoupper($hash);
            $sign = null;
            if ($signatureMethod === 'RSA') {
                $cacheSecretAsPem = $this->safe_value($this->options, 'cacheSecretAsPem', true);
                $pem = null;
                if ($cacheSecretAsPem) {
                    $pem = $this->safe_value($this->options, 'pem');
                    if ($pem === null) {
                        $pem = $this->convert_secret_to_pem($this->encode($this->secret));
                        $this->options['pem'] = $pem;
                    }
                } else {
                    $pem = $this->convert_secret_to_pem($this->encode($this->secret));
                }
                $sign = $this->binary_to_base64($this->rsa($this->encode($uppercaseHash), $this->encode($pem), 'RS256'));
            } elseif ($signatureMethod === 'HmacSHA256') {
                $sign = $this->hmac($this->encode($uppercaseHash), $this->encode($this->secret));
            }
            $query['sign'] = $sign;
            $body = $this->urlencode($this->keysort($query));
            $headers = array(
                'Content-Type' => 'application/x-www-form-urlencoded',
                'timestamp' => $timestamp,
                'signature_method' => $signatureMethod,
                'echostr' => $echostr,
            );
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function convert_secret_to_pem($secret) {
        $lineLength = 64;
        $secretLength = strlen($secret) - 0;
        $numLines = intval($secretLength / $lineLength);
        $numLines = $this->sum($numLines, 1);
        $pem = "-----BEGIN PRIVATE KEY-----\n"; // eslint-disable-line
        for ($i = 0; $i < $numLines; $i++) {
            $start = $i * $lineLength;
            $end = $this->sum($start, $lineLength);
            $pem .= mb_substr($this->secret, $start, $end - $start) . "\n"; // eslint-disable-line
        }
        return $pem . '-----END PRIVATE KEY-----';
    }

    public function handle_errors($httpCode, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return;
        }
        $success = $this->safe_string($response, 'result');
        if ($success === 'false') {
            $errorCode = $this->safe_string($response, 'error_code');
            $message = $this->safe_string(array(
                '10000' => 'Internal error',
                '10001' => 'The required parameters can not be empty',
                '10002' => 'Validation failed',
                '10003' => 'Invalid parameter',
                '10004' => 'Request too frequent',
                '10005' => 'Secret key does not exist',
                '10006' => 'User does not exist',
                '10007' => 'Invalid signature',
                '10008' => 'Invalid Trading Pair',
                '10009' => 'Price and/or Amount are required for limit order',
                '10010' => 'Price and/or Amount must be less than minimum requirement',
                // '10011' => 'Market orders can not be missing the amount of the order',
                // '10012' => 'market sell orders can not be missing orders',
                '10013' => 'The amount is too small',
                '10014' => 'Insufficient amount of money in the account',
                '10015' => 'Invalid order type',
                '10016' => 'Insufficient account balance',
                '10017' => 'Server Error',
                '10018' => 'Page size should be between 1 and 50',
                '10019' => 'Cancel NO more than 3 orders in one request',
                '10020' => 'Volume < 0.001',
                '10021' => 'Price < 0.01',
                '10022' => 'Invalid authorization',
                '10023' => 'Market Order is not supported yet',
                '10024' => 'User cannot trade on this pair',
                '10025' => 'Order has been filled',
                '10026' => 'Order has been cancelld',
                '10027' => 'Order is cancelling',
                '10028' => 'Wrong query time',
                '10029' => 'from is not in the query time',
                '10030' => 'from do not match the transaction type of inqury',
                '10031' => 'echostr length must be valid and length must be from 30 to 40',
                '10033' => 'Failed to create order',
                '10036' => 'customID duplicated',
                '10100' => 'Has no privilege to withdraw',
                '10101' => 'Invalid fee rate to withdraw',
                '10102' => 'Too little to withdraw',
                '10103' => 'Exceed daily limitation of withdraw',
                '10104' => 'Cancel was rejected',
                '10105' => 'Request has been cancelled',
                '10106' => 'None trade time',
                '10107' => 'Start price exception',
                '10108' => 'can not create order',
                '10109' => 'wallet address is not mapping',
                '10110' => 'transfer fee is not mapping',
                '10111' => 'mount > 0',
                '10112' => 'fee is too lower',
                '10113' => 'transfer fee is 0',
                '10600' => 'intercepted by replay attacks filter, check timestamp',
                '10601' => 'Interface closed unavailable',
                '10701' => 'invalid asset code',
                '10702' => 'not allowed deposit',
            ), $errorCode, $this->json($response));
            $ErrorClass = $this->safe_value(array(
                '10001' => '\\ccxt\\BadRequest',
                '10002' => '\\ccxt\\AuthenticationError',
                '10003' => '\\ccxt\\BadRequest',
                '10004' => '\\ccxt\\RateLimitExceeded',
                '10005' => '\\ccxt\\AuthenticationError',
                '10006' => '\\ccxt\\AuthenticationError',
                '10007' => '\\ccxt\\AuthenticationError',
                '10008' => '\\ccxt\\BadSymbol',
                '10009' => '\\ccxt\\InvalidOrder',
                '10010' => '\\ccxt\\InvalidOrder',
                '10013' => '\\ccxt\\InvalidOrder',
                '10014' => '\\ccxt\\InsufficientFunds',
                '10015' => '\\ccxt\\InvalidOrder',
                '10016' => '\\ccxt\\InsufficientFunds',
                '10017' => '\\ccxt\\ExchangeError',
                '10018' => '\\ccxt\\BadRequest',
                '10019' => '\\ccxt\\BadRequest',
                '10020' => '\\ccxt\\BadRequest',
                '10021' => '\\ccxt\\InvalidOrder',
                '10022' => '\\ccxt\\PermissionDenied', // 'Invalid authorization',
                '10023' => '\\ccxt\\InvalidOrder', // 'Market Order is not supported yet',
                '10024' => '\\ccxt\\PermissionDenied', // 'User cannot trade on this pair',
                '10025' => '\\ccxt\\InvalidOrder', // 'Order has been filled',
                '10026' => '\\ccxt\\InvalidOrder', // 'Order has been cancelled',
                '10027' => '\\ccxt\\InvalidOrder', // 'Order is cancelling',
                '10028' => '\\ccxt\\BadRequest', // 'Wrong query time',
                '10029' => '\\ccxt\\BadRequest', // 'from is not in the query time',
                '10030' => '\\ccxt\\BadRequest', // 'from do not match the transaction type of inqury',
                '10031' => '\\ccxt\\InvalidNonce', // 'echostr length must be valid and length must be from 30 to 40',
                '10033' => '\\ccxt\\ExchangeError', // 'Failed to create order',
                '10036' => '\\ccxt\\DuplicateOrderId', // 'customID duplicated',
                '10100' => '\\ccxt\\PermissionDenied', // 'Has no privilege to withdraw',
                '10101' => '\\ccxt\\BadRequest', // 'Invalid fee rate to withdraw',
                '10102' => '\\ccxt\\InsufficientFunds', // 'Too little to withdraw',
                '10103' => '\\ccxt\\ExchangeError', // 'Exceed daily limitation of withdraw',
                '10104' => '\\ccxt\\ExchangeError', // 'Cancel was rejected',
                '10105' => '\\ccxt\\ExchangeError', // 'Request has been cancelled',
                '10106' => '\\ccxt\\BadRequest', // 'None trade time',
                '10107' => '\\ccxt\\BadRequest', // 'Start price exception',
                '10108' => '\\ccxt\\ExchangeError', // 'can not create order',
                '10109' => '\\ccxt\\InvalidAddress', // 'wallet address is not mapping',
                '10110' => '\\ccxt\\ExchangeError', // 'transfer fee is not mapping',
                '10111' => '\\ccxt\\BadRequest', // 'mount > 0',
                '10112' => '\\ccxt\\BadRequest', // 'fee is too lower',
                '10113' => '\\ccxt\\BadRequest', // 'transfer fee is 0',
                '10600' => '\\ccxt\\BadRequest', // 'intercepted by replay attacks filter, check timestamp',
                '10601' => '\\ccxt\\ExchangeError', // 'Interface closed unavailable',
                '10701' => '\\ccxt\\BadSymbol', // 'invalid asset code',
                '10702' => '\\ccxt\\PermissionDenied', // 'not allowed deposit',
            ), $errorCode, '\\ccxt\\ExchangeError');
            throw new $ErrorClass($message);
        }
    }
}
