<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\ArgumentsRequired;
use \ccxt\InvalidOrder;
use \ccxt\DDoSProtection;

class whitebit extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'whitebit',
            'name' => 'WhiteBit',
            'version' => 'v2',
            'countries' => array( 'EE' ),
            'rateLimit' => 500,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => null, // has but unimplemented
                'swap' => false,
                'future' => false,
                'option' => false,
                'cancelOrder' => true,
                'createDepositAddress' => null,
                'createLimitOrder' => null,
                'createMarketOrder' => null,
                'createOrder' => true,
                'createStopLimitOrder' => true,
                'createStopMarketOrder' => true,
                'createStopOrder' => true,
                'editOrder' => null,
                'fetchBalance' => true,
                'fetchBidsAsks' => null,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => true,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchOHLCV' => true,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrders' => true,
                'fetchOrderBook' => true,
                'fetchOrderTrades' => true,
                'fetchPremiumIndexOHLCV' => false,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => true,
                'fetchTransactionFees' => true,
                'transfer' => true,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '3m' => '3m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '2h' => '2h',
                '4h' => '4h',
                '6h' => '6h',
                '8h' => '8h',
                '12h' => '12h',
                '1d' => '1d',
                '3d' => '3d',
                '1w' => '1w',
                '1M' => '1M',
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/66732963-8eb7dd00-ee66-11e9-849b-10d9282bb9e0.jpg',
                'api' => array(
                    'v1' => array(
                        'public' => 'https://whitebit.com/api/v1/public',
                        'private' => 'https://whitebit.com/api/v1',
                    ),
                    'v2' => array(
                        'public' => 'https://whitebit.com/api/v2/public',
                    ),
                    'v4' => array(
                        'public' => 'https://whitebit.com/api/v4/public',
                        'private' => 'https://whitebit.com/api/v4',
                    ),
                ),
                'www' => 'https://www.whitebit.com',
                'doc' => 'https://github.com/whitebit-exchange/api-docs',
                'fees' => 'https://whitebit.com/fee-schedule',
                'referral' => 'https://whitebit.com/referral/d9bdf40e-28f2-4b52-b2f9-cd1415d82963',
            ),
            'api' => array(
                'web' => array(
                    'get' => array(
                        'v1/healthcheck',
                    ),
                ),
                'v1' => array(
                    'public' => array(
                        'get' => array(
                            'markets',
                            'tickers',
                            'ticker',
                            'symbols',
                            'depth/result',
                            'history',
                            'kline',
                        ),
                    ),
                    'private' => array(
                        'post' => array(
                            'account/balance',
                            'order/new',
                            'order/cancel',
                            'orders',
                            'account/order_history',
                            'account/executed_history',
                            'account/executed_history/all',
                            'account/order',
                        ),
                    ),
                ),
                'v2' => array(
                    'public' => array(
                        'get' => array(
                            'markets',
                            'ticker',
                            'assets',
                            'fee',
                            'depth/{market}',
                            'trades/{market}',
                        ),
                    ),
                ),
                'v4' => array(
                    'public' => array(
                        'get' => array(
                            'assets',
                            'fee',
                            'orderbook/{market}',
                            'ticker',
                            'trades/{market}',
                            'time',
                            'ping',
                        ),
                    ),
                    'private' => array(
                        'post' => array(
                            'main-account/address',
                            'main-account/balance',
                            'main-account/create-new-address',
                            'main-account/codes',
                            'main-account/codes/apply',
                            'main-account/codes/my',
                            'main-account/codes/history',
                            'main-account/fiat-deposit-url',
                            'main-account/history',
                            'main-account/withdraw',
                            'main-account/withdraw-pay',
                            'main-account/transfer',
                            'trade-account/balance',
                            'trade-account/executed-history',
                            'trade-account/order',
                            'trade-account/order/history',
                            'order/new',
                            'order/market',
                            'order/stock_market',
                            'order/stop_limit',
                            'order/stop_market',
                            'order/cancel',
                            'orders',
                        ),
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => false,
                    'percentage' => true,
                    'taker' => $this->parse_number('0.001'),
                    'maker' => $this->parse_number('0.001'),
                ),
            ),
            'options' => array(
                'createMarketBuyOrderRequiresPrice' => true,
                'fiatCurrencies' => array( 'EUR', 'USD', 'RUB', 'UAH' ),
                'accountsByType' => array(
                    'main' => 'main',
                    'spot' => 'trade',
                    'margin' => 'margin', // api does not suppot transfers to margin
                ),
                'transfer' => array(
                    'fillTransferResponseFromRequest' => true,
                ),
            ),
            'exceptions' => array(
                'exact' => array(
                    'Unauthorized request.' => '\\ccxt\\AuthenticationError', // array("code":10,"message":"Unauthorized request.")
                    'The market format is invalid.' => '\\ccxt\\BadSymbol', // array("code":0,"message":"Validation failed","errors":array("market":["The market format is invalid."]))
                    'Market is not available' => '\\ccxt\\BadSymbol', // array("success":false,"message":array("market":["Market is not available"]),"result":array())
                    'Invalid payload.' => '\\ccxt\\BadRequest', // array("code":9,"message":"Invalid payload.")
                    'Amount must be greater than 0' => '\\ccxt\\InvalidOrder', // array("code":0,"message":"Validation failed","errors":array("amount":["Amount must be greater than 0"]))
                    'The order id field is required.' => '\\ccxt\\InvalidOrder', // array("code":0,"message":"Validation failed","errors":array("orderId":["The order id field is required."]))
                    'Not enough balance' => '\\ccxt\\InsufficientFunds', // array("code":0,"message":"Validation failed","errors":array("amount":["Not enough balance"]))
                    'This action is unauthorized.' => '\\ccxt\\PermissionDenied', // array("code":0,"message":"This action is unauthorized.")
                    'This API Key is not authorized to perform this action.' => '\\ccxt\\PermissionDenied', // array("code":4,"message":"This API Key is not authorized to perform this action.")
                    'Unexecuted order was not found.' => '\\ccxt\\OrderNotFound', // array("code":2,"message":"Inner validation failed","errors":array("order_id":["Unexecuted order was not found."]))
                    '503' => '\\ccxt\\ExchangeNotAvailable', // array("response":null,"status":503,"errors":array("message":[""]),"notification":null,"warning":null,"_token":null),
                    '422' => '\\ccxt\\OrderNotFound', // array("response":null,"status":422,"errors":array("orderId":["Finished order id 1295772653 not found on your account"]),"notification":null,"warning":"Finished order id 1295772653 not found on your account","_token":null)
                ),
                'broad' => array(
                    'Given amount is less than min amount' => '\\ccxt\\InvalidOrder', // array("code":0,"message":"Validation failed","errors":array("amount":["Given amount is less than min amount 200000"],"total":["Total is less than 5.05"]))
                    'Total is less than' => '\\ccxt\\InvalidOrder', // array("code":0,"message":"Validation failed","errors":array("amount":["Given amount is less than min amount 200000"],"total":["Total is less than 5.05"]))
                    'fee must be no less than' => '\\ccxt\\InvalidOrder', // array("code":0,"message":"Validation failed","errors":array("amount":["Total amount . fee must be no less than 5.05505"]))
                    'Enable your key in API settings' => '\\ccxt\\PermissionDenied', // array("code":2,"message":"This action is unauthorized. Enable your key in API settings")
                ),
            ),
        ));
    }

    public function fetch_markets($params = array ()) {
        /**
         * retrieves data on all $markets for whitebit
         * @param {dict} $params extra parameters specific to the exchange api endpoint
         * @return {[dict]} an array of objects representing $market data
         */
        $response = $this->v2PublicGetMarkets ($params);
        //
        //    {
        //        "success" => true,
        //        "message" => "",
        //        "result" => array(
        //            array(
        //                "name":
        //                "C98_USDT",
        //                "stock":"C98",
        //                "money":"USDT",
        //                "stockPrec":"3",
        //                "moneyPrec":"5",
        //                "feePrec":"6",
        //                "makerFee":"0.001",
        //                "takerFee":"0.001",
        //                "minAmount":"2.5",
        //                "minTotal":"5.05",
        //                "tradesEnabled":true
        //            ),
        //            ...
        //        )
        //    }
        //
        $markets = $this->safe_value($response, 'result', array());
        $result = array();
        for ($i = 0; $i < count($markets); $i++) {
            $market = $markets[$i];
            $id = $this->safe_string($market, 'name');
            $baseId = $this->safe_string($market, 'stock');
            $quoteId = $this->safe_string($market, 'money');
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $symbol = $base . '/' . $quote;
            $active = $this->safe_value($market, 'tradesEnabled');
            $entry = array(
                'id' => $id,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'settle' => null,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'settleId' => null,
                'type' => 'spot',
                'spot' => true,
                'margin' => null,
                'swap' => false,
                'future' => false,
                'option' => false,
                'active' => $active,
                'contract' => false,
                'linear' => null,
                'inverse' => null,
                'taker' => $this->safe_number($market, 'makerFee'),
                'maker' => $this->safe_number($market, 'takerFee'),
                'contractSize' => null,
                'expiry' => null,
                'expiryDatetime' => null,
                'strike' => null,
                'optionType' => null,
                'precision' => array(
                    'amount' => $this->safe_integer($market, 'stockPrec'),
                    'price' => $this->safe_integer($market, 'moneyPrec'),
                ),
                'limits' => array(
                    'leverage' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'amount' => array(
                        'min' => $this->safe_number($market, 'minAmount'),
                        'max' => null,
                    ),
                    'price' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => $this->safe_number($market, 'minTotal'),
                        'max' => null,
                    ),
                ),
                'info' => $market,
            );
            $result[] = $entry;
        }
        return $result;
    }

    public function fetch_currencies($params = array ()) {
        /**
         * fetches all available currencies on an exchange
         * @param {dict} $params extra parameters specific to the whitebit api endpoint
         * @return {dict} an associative dictionary of currencies
         */
        $response = $this->v4PublicGetAssets ($params);
        //
        //      "BTC" => array(
        //          "name" => "Bitcoin",
        //          "unified_cryptoasset_id" => 1,
        //          "can_withdraw" => true,
        //          "can_deposit" => true,
        //          "min_withdraw" => "0.001",
        //          "max_withdraw" => "2",
        //          "maker_fee" => "0.1",
        //          "taker_fee" => "0.1",
        //          "min_deposit" => "0.0001",
        //           "max_deposit" => "0",
        //       ),
        //
        $ids = is_array($response) ? array_keys($response) : array();
        $result = array();
        for ($i = 0; $i < count($ids); $i++) {
            $id = $ids[$i];
            $currency = $response[$id];
            // breaks down in Python due to utf8 encoding issues on the exchange side
            // $name = $this->safe_string($currency, 'name');
            $canDeposit = $this->safe_value($currency, 'can_deposit', true);
            $canWithdraw = $this->safe_value($currency, 'can_withdraw', true);
            $active = $canDeposit && $canWithdraw;
            $code = $this->safe_currency_code($id);
            $result[$code] = array(
                'id' => $id,
                'code' => $code,
                'info' => $currency, // the original payload
                'name' => null, // see the comment above
                'active' => $active,
                'deposit' => $canDeposit,
                'withdraw' => $canWithdraw,
                'fee' => null,
                'precision' => null,
                'limits' => array(
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'withdraw' => array(
                        'min' => $this->safe_number($currency, 'min_withdraw'),
                        'max' => $this->safe_number($currency, 'max_withdraw'),
                    ),
                ),
            );
        }
        return $result;
    }

    public function fetch_transaction_fees($codes = null, $params = array ()) {
        $this->load_markets();
        $response = $this->v4PublicGetFee ($params);
        //
        //      {
        //          "1INCH":{
        //              "is_depositable":true,
        //              "is_withdrawal":true,
        //              "ticker":"1INCH",
        //              "name":"1inch",
        //              "providers":array(
        //              ),
        //              "withdraw":array(
        //                   "max_amount":"0",
        //                  "min_amount":"21.5",
        //                  "fixed":"17.5",
        //                  "flex":null
        //              ),
        //              "deposit":array(
        //                  "max_amount":"0",
        //                  "min_amount":"19.5",
        //                  "fixed":null,
        //                  "flex":null
        //               }
        //          ),
        //           array(...)
        //      }
        //
        $currenciesIds = is_array($response) ? array_keys($response) : array();
        $withdrawFees = array();
        $depositFees = array();
        for ($i = 0; $i < count($currenciesIds); $i++) {
            $currency = $currenciesIds[$i];
            $data = $response[$currency];
            $code = $this->safe_currency_code($currency);
            $withdraw = $this->safe_value($data, 'withdraw', array());
            $withdrawFees[$code] = $this->safe_string($withdraw, 'fixed');
            $deposit = $this->safe_value($data, 'deposit', array());
            $depositFees[$code] = $this->safe_string($deposit, 'fixed');
        }
        return array(
            'withdraw' => $withdrawFees,
            'deposit' => $depositFees,
            'info' => $response,
        );
    }

    public function fetch_trading_fees($params = array ()) {
        $response = $this->v4PublicGetAssets ($params);
        //
        //      {
        //          '1INCH' => array(
        //              name => '1inch',
        //              unified_cryptoasset_id => '8104',
        //              can_withdraw => true,
        //              can_deposit => true,
        //              min_withdraw => '33',
        //              max_withdraw => '0',
        //              maker_fee => '0.1',
        //              taker_fee => '0.1',
        //              min_deposit => '30',
        //              max_deposit => '0'
        //            ),
        //            ...
        //      }
        //
        $result = array();
        for ($i = 0; $i < count($this->symbols); $i++) {
            $symbol = $this->symbols[$i];
            $market = $this->market($symbol);
            $fee = $this->safe_value($response, $market['baseId'], array());
            $makerFee = $this->safe_string($fee, 'maker_fee');
            $takerFee = $this->safe_string($fee, 'taker_fee');
            $makerFee = Precise::string_div($makerFee, '100');
            $takerFee = Precise::string_div($takerFee, '100');
            $result[$symbol] = array(
                'info' => $fee,
                'symbol' => $market['symbol'],
                'percentage' => true,
                'tierBased' => false,
                'maker' => $this->parse_number($makerFee),
                'taker' => $this->parse_number($takerFee),
            );
        }
        return $result;
    }

    public function fetch_ticker($symbol, $params = array ()) {
        /**
         * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
         * @param {str} $symbol unified $symbol of the $market to fetch the $ticker for
         * @param {dict} $params extra parameters specific to the whitebit api endpoint
         * @return {dict} a {@link https://docs.ccxt.com/en/latest/manual.html#$ticker-structure $ticker structure}
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'market' => $market['id'],
        );
        $response = $this->v1PublicGetTicker (array_merge($request, $params));
        //
        //      {
        //         "success":true,
        //         "message":"",
        //         "result" => array(
        //             "bid":"0.021979",
        //             "ask":"0.021996",
        //             "open":"0.02182",
        //             "high":"0.022039",
        //             "low":"0.02161",
        //             "last":"0.021987",
        //             "volume":"2810.267",
        //             "deal":"61.383565474",
        //             "change":"0.76",
        //         ),
        //     }
        //
        $ticker = $this->safe_value($response, 'result', array());
        return $this->parse_ticker($ticker, $market);
    }

    public function parse_ticker($ticker, $market = null) {
        //
        //  FetchTicker (v1)
        //
        //    {
        //        "bid" => "0.021979",
        //        "ask" => "0.021996",
        //        "open" => "0.02182",
        //        "high" => "0.022039",
        //        "low" => "0.02161",
        //        "last" => "0.021987",
        //        "volume" => "2810.267",
        //        "deal" => "61.383565474",
        //        "change" => "0.76",
        //    }
        //
        // FetchTickers (v4)
        //
        //    "BCH_RUB" => {
        //        "base_id" => 1831,
        //        "quote_id" => 0,
        //        "last_price" => "32830.21",
        //        "quote_volume" => "1494659.8024096",
        //        "base_volume" => "46.1083",
        //        "isFrozen" => false,
        //        "change" => "2.12" // in percent
        //    }
        //
        $market = $this->safe_market(null, $market);
        $last = $this->safe_string($ticker, 'last_price');
        return $this->safe_ticker(array(
            'symbol' => $market['symbol'],
            'timestamp' => null,
            'datetime' => null,
            'high' => $this->safe_string($ticker, 'high'),
            'low' => $this->safe_string($ticker, 'low'),
            'bid' => $this->safe_string($ticker, 'bid'),
            'bidVolume' => null,
            'ask' => $this->safe_string($ticker, 'ask'),
            'askVolume' => null,
            'vwap' => null,
            'open' => $this->safe_string($ticker, 'open'),
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => $this->safe_string($ticker, 'change'),
            'average' => null,
            'baseVolume' => $this->safe_string_2($ticker, 'base_volume', 'volume'),
            'quoteVolume' => $this->safe_string_2($ticker, 'quote_volume', 'deal'),
            'info' => $ticker,
        ), $market);
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        /**
         * fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each $market
         * @param {[str]|null} $symbols unified $symbols of the markets to fetch the $ticker for, all $market tickers are returned if not assigned
         * @param {dict} $params extra parameters specific to the whitebit api endpoint
         * @return {dict} an array of {@link https://docs.ccxt.com/en/latest/manual.html#$ticker-structure $ticker structures}
         */
        $this->load_markets();
        $response = $this->v4PublicGetTicker ($params);
        //
        //      "BCH_RUB" => array(
        //          "base_id":1831,
        //          "quote_id":0,
        //          "last_price":"32830.21",
        //          "quote_volume":"1494659.8024096",
        //          "base_volume":"46.1083",
        //          "isFrozen":false,
        //          "change":"2.12"
        //      ),
        //
        $marketIds = is_array($response) ? array_keys($response) : array();
        $result = array();
        for ($i = 0; $i < count($marketIds); $i++) {
            $marketId = $marketIds[$i];
            $market = $this->safe_market($marketId);
            $ticker = $this->parse_ticker($response[$marketId], $market);
            $symbol = $ticker['symbol'];
            $result[$symbol] = $ticker;
        }
        return $this->filter_by_array($result, 'symbol', $symbols);
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        /**
         * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
         * @param {str} $symbol unified $symbol of the $market to fetch the order book for
         * @param {int|null} $limit the maximum amount of order book entries to return
         * @param {dict} $params extra parameters specific to the whitebit api endpoint
         * @return {dict} A dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure order book structures} indexed by $market symbols
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'market' => $market['id'],
        );
        if ($limit !== null) {
            $request['depth'] = $limit; // default = 50, maximum = 100
        }
        $response = $this->v4PublicGetOrderbookMarket (array_merge($request, $params));
        //
        //      {
        //          "timestamp" => 1594391413,
        //          "asks" => array(
        //              array(
        //                  "9184.41",
        //                  "0.773162"
        //              ),
        //              array( ... )
        //          ),
        //          "bids" => array(
        //              array(
        //                  "9181.19",
        //                  "0.010873"
        //              ),
        //              array( ... )
        //          )
        //      }
        //
        $timestamp = $this->safe_string($response, 'timestamp');
        return $this->parse_order_book($response, $symbol, $timestamp);
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        /**
         * get the list of most recent trades for a particular $symbol
         * @param {str} $symbol unified $symbol of the $market to fetch trades for
         * @param {int|null} $since timestamp in ms of the earliest trade to fetch
         * @param {int|null} $limit the maximum amount of trades to fetch
         * @param {dict} $params extra parameters specific to the whitebit api endpoint
         * @return {[dict]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-trades trade structures~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'market' => $market['id'],
        );
        $response = $this->v4PublicGetTradesMarket (array_merge($request, $params));
        //
        //      array(
        //          array(
        //              "tradeID" => 158056419,
        //              "price" => "9186.13",
        //              "quote_volume" => "0.0021",
        //              "base_volume" => "9186.13",
        //              "trade_timestamp" => 1594391747,
        //              "type" => "sell"
        //          ),
        //      ),
        //
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function parse_trade($trade, $market = null) {
        // fetchTradesV4
        //     array(
        //       "tradeID" => 158056419,
        //       "price" => "9186.13",
        //       "quote_volume" => "0.0021",
        //       "base_volume" => "9186.13",
        //       "trade_timestamp" => 1594391747,
        //       "type" => "sell"
        //     ),
        //
        // orderTrades (v4Private)
        //
        //     {
        //         "time" => 1593342324.613711,
        //         "fee" => "0.00000419198",
        //         "price" => "0.00000701",
        //         "amount" => "598",
        //         "id" => 149156519, // $trade $id
        //         "dealOrderId" => 3134995325, // $orderId
        //         "clientOrderId" => "customId11",
        //         "role" => 2, // 1 = maker, 2 = taker
        //         "deal" => "0.00419198" // $amount in money
        //     }
        //
        $timestamp = $this->safe_timestamp_2($trade, 'time', 'trade_timestamp');
        $orderId = $this->safe_string($trade, 'dealOrderId');
        $cost = $this->safe_string($trade, 'deal');
        $price = $this->safe_string($trade, 'price');
        $amount = $this->safe_string_2($trade, 'amount', 'base_volume');
        $id = $this->safe_string_2($trade, 'id', 'tradeID');
        $side = $this->safe_string($trade, 'type');
        $symbol = $this->safe_symbol(null, $market);
        $role = $this->safe_integer($trade, 'role');
        $takerOrMaker = null;
        if ($role !== null) {
            $takerOrMaker = ($role === 1) ? 'maker' : 'taker';
        }
        $fee = null;
        $feeCost = $this->safe_string($trade, 'fee');
        if ($feeCost !== null) {
            $safeMarket = $this->safe_market(null, $market);
            $quote = $safeMarket['quote'];
            $fee = array(
                'cost' => $feeCost,
                'currency' => $quote,
            );
        }
        return $this->safe_trade(array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'id' => $id,
            'order' => $orderId,
            'type' => null,
            'takerOrMaker' => $takerOrMaker,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => $fee,
        ), $market);
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        /**
         * fetches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
         * @param {str} $symbol unified $symbol of the $market to fetch OHLCV data for
         * @param {str} $timeframe the length of time each candle represents
         * @param {int|null} $since timestamp in ms of the earliest candle to fetch
         * @param {int|null} $limit the maximum amount of candles to fetch
         * @param {dict} $params extra parameters specific to the whitebit api endpoint
         * @return {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'market' => $market['id'],
            'interval' => $this->timeframes[$timeframe],
        );
        if ($since !== null) {
            $maxLimit = 1440;
            if ($limit === null) {
                $limit = $maxLimit;
            }
            $limit = min ($limit, $maxLimit);
            $start = intval($since / 1000);
            $duration = $this->parse_timeframe($timeframe);
            $end = $this->sum($start, $duration * $limit);
            $request['start'] = $start;
            $request['end'] = $end;
        }
        if ($limit !== null) {
            $request['limit'] = $limit; // max 1440
        }
        $response = $this->v1PublicGetKline (array_merge($request, $params));
        //
        //     {
        //         "success":true,
        //         "message":"",
        //         "result":[
        //             [1591488000,"0.025025","0.025025","0.025029","0.025023","6.181","0.154686629"],
        //             [1591488060,"0.025028","0.025033","0.025035","0.025026","8.067","0.201921167"],
        //             [1591488120,"0.025034","0.02505","0.02505","0.025034","20.089","0.503114696"],
        //         ]
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        return $this->parse_ohlcvs($result, $market, $timeframe, $since, $limit);
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        //
        //     array(
        //         1591488000,
        //         "0.025025",
        //         "0.025025",
        //         "0.025029",
        //         "0.025023",
        //         "6.181",
        //         "0.154686629"
        //     )
        //
        return array(
            $this->safe_timestamp($ohlcv, 0), // timestamp
            $this->safe_number($ohlcv, 1), // open
            $this->safe_number($ohlcv, 3), // high
            $this->safe_number($ohlcv, 4), // low
            $this->safe_number($ohlcv, 2), // close
            $this->safe_number($ohlcv, 5), // volume
        );
    }

    public function fetch_status($params = array ()) {
        /**
         * the latest known information on the availability of the exchange API
         * @param {dict} $params extra parameters specific to the whitebit api endpoint
         * @return {dict} a {@link https://docs.ccxt.com/en/latest/manual.html#exchange-$status-structure $status structure}
         */
        $response = $this->v4PublicGetPing ($params);
        //
        //      array(
        //          "pong"
        //      )
        //
        $status = $this->safe_string($response, 0);
        return array(
            'status' => ($status === 'pong') ? 'ok' : $status,
            'updated' => null,
            'eta' => null,
            'url' => null,
            'info' => $response,
        );
    }

    public function fetch_time($params = array ()) {
        /**
         * fetches the current integer timestamp in milliseconds from the exchange server
         * @param {dict} $params extra parameters specific to the whitebit api endpoint
         * @return {int} the current integer timestamp in milliseconds from the exchange server
         */
        $response = $this->v4PublicGetTime ($params);
        //
        //     {
        //         "time":1635467280514
        //     }
        //
        return $this->safe_integer($response, 'time');
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $method = null;
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'market' => $market['id'],
            'side' => $side,
            'amount' => $this->amount_to_precision($symbol, $amount),
        );
        $stopPrice = $this->safe_number_2($params, 'stopPrice', 'activationPrice');
        if ($stopPrice !== null) {
            // it's a stop order
            $request['activation_price'] = $this->price_to_precision($symbol, $stopPrice);
            if ($type === 'limit' || $type === 'stopLimit') {
                // it's a stop-limit-order
                $method = 'v4PrivateOPostOrderStopLimit';
            } elseif ($type === 'market' || $type === 'stopMarket') {
                // it's a stop-$market-order
                $method = 'v4PrivatePostOrderStopMarket';
            }
        } else {
            if ($type === 'market') {
                // it's a regular $market order
                $method = 'v4PrivatePostOrderMarket';
            }
            if ($type === 'limit') {
                // it's a regular limit order
                $method = 'v4PrivatePostOrderNew';
            }
        }
        // aggregate common assignments regardless stop or not
        if ($type === 'limit' || $type === 'stopLimit') {
            if ($price === null) {
                throw new ArgumentsRequired($this->id . ' createOrder() requires a $price argument for a stopLimit order');
            }
            $convertedPrice = $this->price_to_precision($symbol, $price);
            $request['price'] = $convertedPrice;
        }
        if ($type === 'market' || $type === 'stopMarket') {
            if ($side === 'buy') {
                $cost = $this->safe_number($params, 'cost');
                $createMarketBuyOrderRequiresPrice = $this->safe_value($this->options, 'createMarketBuyOrderRequiresPrice', true);
                if ($createMarketBuyOrderRequiresPrice) {
                    if ($price !== null) {
                        if ($cost === null) {
                            $cost = $amount * $price;
                        }
                    } elseif ($cost === null) {
                        throw new InvalidOrder($this->id . " createOrder() requires the $price argument for $market buy orders to calculate total order $cost ($amount to spend), where $cost = $amount * $price-> Supply a $price argument to createOrder() call if you want the $cost to be calculated for you from $price and $amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total $cost value in the 'amount' argument or in the 'cost' extra parameter (the exchange-specific behaviour)");
                    }
                } else {
                    $cost = ($cost === null) ? $amount : $cost;
                }
                $request['amount'] = $this->cost_to_precision($symbol, $cost);
            }
        }
        if ($method === null) {
            throw new ArgumentsRequired($this->id . ' createOrder() requires one of the following order types => $market, limit, stopLimit or stopMarket');
        }
        $response = $this->$method (array_merge($request, $params));
        return $this->parse_order($response);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'market' => $market['id'],
            'orderId' => intval($id),
        );
        return $this->v4PrivatePostOrderCancel (array_merge($request, $params));
    }

    public function parse_balance($response) {
        $balanceKeys = is_array($response) ? array_keys($response) : array();
        $result = array( );
        for ($i = 0; $i < count($balanceKeys); $i++) {
            $id = $balanceKeys[$i];
            $balance = $response[$id];
            $code = $this->safe_currency_code($id);
            $account = $this->account();
            $account['free'] = $this->safe_string($balance, 'available');
            $account['used'] = $this->safe_string($balance, 'freeze');
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function fetch_balance($params = array ()) {
        /**
         * query for balance and get the amount of funds available for trading or funds locked in orders
         * @param {dict} $params extra parameters specific to the whitebit api endpoint
         * @return {dict} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
         */
        $this->load_markets();
        $response = $this->v4PrivatePostTradeAccountBalance ($params);
        //
        //     {
        //         "BTC" => array( "available" => "0.123", "freeze" => "1" ),
        //         "XMR" => array( "available" => "3013", "freeze" => "100" ),
        //     }
        //
        return $this->parse_balance($response);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOpenOrders() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'market' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit; // default 50 max 100
        }
        $response = $this->v4PrivatePostOrders (array_merge($request, $params));
        //
        //     array(
        //         array(
        //             "orderId" => 3686033640,
        //             "clientOrderId" => "customId11",
        //             "market" => "BTC_USDT",
        //             "side" => "buy",
        //             "type" => "limit",
        //             "timestamp" => 1594605801.49815,    // current timestamp of unexecuted order
        //             "dealMoney" => "0",                 // executed amount in money
        //             "dealStock" => "0",                 // executed amount in stock
        //             "amount" => "2.241379",             // active order amount
        //             "takerFee" => "0.001",
        //             "makerFee" => "0.001",
        //             "left" => "2.241379",               // unexecuted amount in stock
        //             "dealFee" => "0",                   // executed fee by deal
        //             "price" => "40000"
        //         ),
        //     )
        //
        return $this->parse_orders($response, $market, $since, $limit, array( 'status' => 'open' ));
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $request['market'] = $market['id'];
        }
        if ($limit !== null) {
            $request['limit'] = $limit; // default 50 max 100
        }
        $response = $this->v4PrivatePostTradeAccountOrderHistory (array_merge($request, $params));
        //
        //     {
        //         "BTC_USDT" => array(
        //             array(
        //                 "id" => 160305483,
        //                 "clientOrderId" => "customId11",
        //                 "time" => 1594667731.724403,
        //                 "side" => "sell",
        //                 "role" => 2, // 1 = maker, 2 = taker
        //                 "amount" => "0.000076",
        //                 "price" => "9264.21",
        //                 "deal" => "0.70407996",
        //                 "fee" => "0.00070407996"
        //             ),
        //         ),
        //     }
        //
        $marketIds = is_array($response) ? array_keys($response) : array();
        $results = array();
        for ($i = 0; $i < count($marketIds); $i++) {
            $marketId = $marketIds[$i];
            $market = $this->safe_market($marketId, null, '_');
            $orders = $response[$marketId];
            for ($j = 0; $j < count($orders); $j++) {
                $order = $this->parse_order($orders[$j], $market);
                $results[] = array_merge($order, array( 'status' => 'filled' ));
            }
        }
        $results = $this->sort_by($results, 'timestamp');
        $results = $this->filter_by_symbol_since_limit($results, $symbol, $since, $limit, $since === null);
        return $results;
    }

    public function parse_order($order, $market = null) {
        //
        // createOrder, fetchOpenOrders
        //
        //     {
        //         "orderId" => 4180284841,
        //         "clientOrderId" => "order1987111",
        //         "market" => "BTC_USDT",
        //         "side" => "buy",
        //         "type" => "stop limit",
        //         "timestamp" => 1595792396.165973,
        //         "dealMoney" => "0",                  // if $order finished - $amount in money currency that finished
        //         "dealStock" => "0",                  // if $order finished - $amount in stock currency that finished
        //         "amount" => "0.001",
        //         "takerFee" => "0.001",
        //         "makerFee" => "0.001",
        //         "left" => "0.001",                   // $remaining $amount
        //         "dealFee" => "0",                    // $fee in money that you pay if $order is finished
        //         "price" => "40000",
        //         "activation_price" => "40000"        // activation $price -> only for stopLimit, stopMarket
        //     }
        //
        // fetchClosedOrders
        //
        //     {
        //         "market" => "BTC_USDT"
        //         "amount" => "0.0009",
        //         "price" => "40000",
        //         "type" => "limit",
        //         "id" => 4986126152,
        //         "clientOrderId" => "customId11",
        //         "side" => "sell",
        //         "ctime" => 1597486960.311311,       // $timestamp of $order creation
        //         "takerFee" => "0.001",
        //         "ftime" => 1597486960.311332,       // executed $order $timestamp
        //         "makerFee" => "0.001",
        //         "dealFee" => "0.041258268",         // paid $fee if $order is finished
        //         "dealStock" => "0.0009",            // $amount in stock currency that finished
        //         "dealMoney" => "41.258268"          // $amount in money currency that finished
        //     }
        //
        $marketId = $this->safe_string($order, 'market');
        $market = $this->safe_market($marketId, $market, '_');
        $symbol = $market['symbol'];
        $side = $this->safe_string($order, 'side');
        $filled = $this->safe_string($order, 'dealStock');
        $remaining = $this->safe_string($order, 'left');
        $clientOrderId = $this->safe_string($order, 'clientOrderId');
        $price = $this->safe_string($order, 'price');
        $stopPrice = $this->safe_string($order, 'activation_price');
        $orderId = $this->safe_string_2($order, 'orderId', 'id');
        $type = $this->safe_string($order, 'type');
        $amount = $this->safe_string($order, 'amount');
        $cost = null;
        if ($price === '0') {
            // api error to be solved
            $price = null;
        }
        if ($side === 'buy' && mb_strpos($type, 'market') !== false) {
            // in these cases the $amount is in the quote currency meaning it's the $cost
            $cost = $amount;
            $amount = null;
            if ($price !== null) {
                // if the $price is available we can do this conversion
                // from $amount in quote currency to base currency
                $amount = Precise::string_div($cost, $price);
            }
        }
        $dealFee = $this->safe_string($order, 'dealFee');
        $fee = null;
        if ($dealFee !== null) {
            $fee = array(
                'cost' => $this->parse_number($dealFee),
                'currency' => $market['quote'],
            );
        }
        $timestamp = $this->safe_timestamp_2($order, 'ctime', 'timestamp');
        $lastTradeTimestamp = $this->safe_timestamp($order, 'ftime');
        return $this->safe_order(array(
            'info' => $order,
            'id' => $orderId,
            'symbol' => $symbol,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $lastTradeTimestamp,
            'timeInForce' => null,
            'postOnly' => null,
            'status' => null,
            'side' => $side,
            'price' => $price,
            'type' => $type,
            'stopPrice' => $stopPrice,
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => $remaining,
            'average' => null,
            'cost' => $cost,
            'fee' => $fee,
            'trades' => null,
        ), $market);
    }

    public function fetch_order_trades($id, $symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            'orderId' => intval($id),
        );
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['market'] = $market['id'];
        }
        if ($limit !== null) {
            $request['limit'] = $limit; // default 50, max 100
        }
        $response = $this->v4PrivatePostTradeAccountOrder (array_merge($request, $params));
        //
        //     {
        //         "records" => array(
        //             {
        //                 "time" => 1593342324.613711,
        //                 "fee" => "0.00000419198",
        //                 "price" => "0.00000701",
        //                 "amount" => "598",
        //                 "id" => 149156519, // trade $id
        //                 "dealOrderId" => 3134995325, // orderId
        //                 "clientOrderId" => "customId11", // empty string if not specified
        //                 "role" => 2, // 1 = maker, 2 = taker
        //                 "deal" => "0.00419198"
        //             }
        //         ),
        //         "offset" => 0,
        //         "limit" => 100
        //     }
        //
        $data = $this->safe_value($response, 'records', array());
        return $this->parse_trades($data, $market);
    }

    public function fetch_deposit_address($code, $params = array ()) {
        $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'ticker' => $currency['id'],
        );
        $method = 'v4PrivatePostMainAccountAddress';
        if ($this->is_fiat($code)) {
            $method = 'v4PrivatePostMainAccountFiatDepositUrl';
            $provider = $this->safe_number($params, 'provider');
            if ($provider === null) {
                throw new ArgumentsRequired($this->id . ' fetchDepositAddress() requires a $provider when the ticker is fiat');
            }
            $request['provider'] = $provider;
            $amount = $this->safe_number($params, 'amount');
            if ($amount === null) {
                throw new ArgumentsRequired($this->id . ' fetchDepositAddress() requires an $amount when the ticker is fiat');
            }
            $request['amount'] = $amount;
            $uniqueId = $this->safe_value($params, 'uniqueId');
            if ($uniqueId === null) {
                throw new ArgumentsRequired($this->id . ' fetchDepositAddress() requires an $uniqueId when the ticker is fiat');
            }
        }
        $response = $this->$method (array_merge($request, $params));
        //
        // fiat
        //
        //     {
        //         "url" => "https://someaddress.com"
        //     }
        //
        // crypto
        //
        //     {
        //         "account" => array(
        //             "address" => "GDTSOI56XNVAKJNJBLJGRNZIVOCIZJRBIDKTWSCYEYNFAZEMBLN75RMN",
        //             "memo" => "48565488244493"
        //         ),
        //         "required" => {
        //             "fixedFee" => "0",
        //             "flexFee" => array(
        //                 "maxFee" => "0",
        //                 "minFee" => "0",
        //                 "percent" => "0"
        //             ),
        //             "maxAmount" => "0",
        //             "minAmount" => "1"
        //         }
        //     }
        //
        $url = $this->safe_string($response, 'url');
        $account = $this->safe_value($response, 'account', array());
        $address = $this->safe_string($account, 'address', $url);
        $tag = $this->safe_string($account, 'memo');
        $this->check_address($address);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => $tag,
            'network' => null,
            'info' => $response,
        );
    }

    public function transfer($code, $amount, $fromAccount, $toAccount, $params = array ()) {
        $this->load_markets();
        $currency = $this->currency($code);
        $accountsByType = $this->safe_value($this->options, 'accountsByType');
        $fromAccountId = $this->safe_string($accountsByType, $fromAccount, $fromAccount);
        $toAccountId = $this->safe_string($accountsByType, $toAccount, $toAccount);
        $type = null;
        if ($fromAccountId === 'main' && $toAccountId === 'trade') {
            $type = 'deposit';
        } elseif ($fromAccountId === 'trade' && $toAccountId === 'main') {
            $type = 'withdraw';
        }
        if ($type === null) {
            throw new ExchangeError($this->id . ' $transfer() only allows transfers between main account and spot account');
        }
        $request = array(
            'ticker' => $currency['id'],
            'method' => $type,
            'amount' => $this->currency_to_precision($code, $amount),
        );
        $response = $this->v4PrivatePostMainAccountTransfer (array_merge($request, $params));
        //
        //    array()
        //
        $transfer = $this->parse_transfer($response, $currency);
        $transferOptions = $this->safe_value($this->options, 'transfer', array());
        $fillTransferResponseFromRequest = $this->safe_value($transferOptions, 'fillTransferResponseFromRequest', true);
        if ($fillTransferResponseFromRequest) {
            $transfer['amount'] = $amount;
            $transfer['fromAccount'] = $fromAccount;
            $transfer['toAccount'] = $toAccount;
        }
        return $transfer;
    }

    public function parse_transfer($transfer, $currency) {
        //
        //    array()
        //
        return array(
            'info' => $transfer,
            'id' => null,
            'timestamp' => null,
            'datetime' => null,
            'currency' => $this->safe_currency_code(null, $currency),
            'amount' => null,
            'fromAccount' => null,
            'toAccount' => null,
            'status' => 'pending',
        );
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        $this->load_markets();
        $currency = $this->currency($code); // check if it has canDeposit
        $request = array(
            'ticker' => $currency['id'],
            'amount' => $this->currency_to_precision($code, $amount),
            'address' => $address,
        );
        $uniqueId = $this->safe_value($params, 'uniqueId');
        if ($uniqueId === null) {
            $uniqueId = $this->uuid22();
        }
        $request['uniqueId'] = $uniqueId;
        if ($tag !== null) {
            $request['memo'] = $tag;
        }
        if ($this->is_fiat($code)) {
            $provider = $this->safe_value($params, 'provider');
            if ($provider === null) {
                throw new ArgumentsRequired($this->id . ' withdraw() requires a $provider when the ticker is fiat');
            }
            $request['provider'] = $provider;
        }
        $response = $this->v4PrivatePostMainAccountWithdraw (array_merge($request, $params));
        //
        // empty array with a success status
        // go to deposit/withdraw history and check you $request status by $uniqueId
        //
        //     array()
        //
        return array_merge(array( 'id' => $uniqueId ), $this->parse_transaction($response, $currency));
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // withdraw
        //
        //     array()
        //
        $currency = $this->safe_currency(null, $currency);
        return array(
            'id' => null,
            'txid' => null,
            'timestamp' => null,
            'datetime' => null,
            'network' => null,
            'addressFrom' => null,
            'address' => null,
            'addressTo' => null,
            'amount' => null,
            'type' => null,
            'currency' => $currency['code'],
            'status' => null,
            'updated' => null,
            'tagFrom' => null,
            'tag' => null,
            'tagTo' => null,
            'comment' => null,
            'fee' => null,
            'info' => $transaction,
        );
    }

    public function is_fiat($currency) {
        $fiatCurrencies = $this->safe_value($this->options, 'fiatCurrencies', array());
        return $this->in_array($currency, $fiatCurrencies);
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $query = $this->omit($params, $this->extract_params($path));
        $version = $this->safe_value($api, 0);
        $accessibility = $this->safe_value($api, 1);
        $pathWithParams = '/' . $this->implode_params($path, $params);
        $url = $this->urls['api'][$version][$accessibility] . $pathWithParams;
        if ($accessibility === 'public') {
            if ($query) {
                $url .= '?' . $this->urlencode($query);
            }
        }
        if ($accessibility === 'private') {
            $this->check_required_credentials();
            $nonce = (string) $this->nonce();
            $secret = $this->encode($this->secret);
            $request = '/' . 'api' . '/' . $version . $pathWithParams;
            $body = $this->json(array_merge(array( 'request' => $request, 'nonce' => $nonce ), $params));
            $payload = base64_encode($body);
            $signature = $this->hmac($payload, $secret, 'sha512');
            $headers = array(
                'Content-Type' => 'application/json',
                'X-TXC-APIKEY' => $this->apiKey,
                'X-TXC-PAYLOAD' => $payload,
                'X-TXC-SIGNATURE' => $signature,
            );
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if (($code === 418) || ($code === 429)) {
            throw new DDoSProtection($this->id . ' ' . (string) $code . ' ' . $reason . ' ' . $body);
        }
        if ($code === 404) {
            throw new ExchangeError($this->id . ' ' . (string) $code . ' endpoint not found');
        }
        if ($response !== null) {
            // For cases where we have a meaningful $status
            // array("response":null,"status":422,"errors":array("orderId":["Finished order id 435453454535 not found on your account"]),"notification":null,"warning":"Finished order id 435453454535 not found on your account","_token":null)
            $status = $this->safe_integer($response, 'status');
            // array("code":10,"message":"Unauthorized request.")
            $message = $this->safe_string($response, 'message');
            // For these cases where we have a generic $code variable error key
            // array("code":0,"message":"Validation failed","errors":array("amount":["Amount must be greater than 0"]))
            $code = $this->safe_integer($response, 'code');
            $hasErrorStatus = $status !== null && $status !== '200';
            if ($hasErrorStatus || $code !== null) {
                $feedback = $this->id . ' ' . $body;
                $errorInfo = $message;
                if ($hasErrorStatus) {
                    $errorInfo = $status;
                } else {
                    $errorObject = $this->safe_value($response, 'errors');
                    if ($errorObject !== null) {
                        $errorKey = is_array($errorObject) ? array_keys($errorObject) : array()[0];
                        $errorMessageArray = $this->safe_value($errorObject, $errorKey, array());
                        $errorMessageLength = is_array($errorMessageArray) ? count($errorMessageArray) : 0;
                        $errorInfo = ($errorMessageLength > 0) ? $errorMessageArray[0] : $body;
                    }
                }
                $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorInfo, $feedback);
                $this->throw_broadly_matched_exception($this->exceptions['broad'], $body, $feedback);
                throw new ExchangeError($feedback);
            }
        }
    }
}
