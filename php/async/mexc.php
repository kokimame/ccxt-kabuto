<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\ArgumentsRequired;
use \ccxt\InvalidAddress;
use \ccxt\InvalidOrder;
use \ccxt\OrderNotFound;
use \ccxt\NotSupported;
use \ccxt\Precise;

class mexc extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'mexc',
            'name' => 'MEXC Global',
            'countries' => array( 'SC' ), // Seychelles
            'rateLimit' => 50, // default rate limit is 20 times per second
            'version' => 'v2',
            'certified' => true,
            'pro' => true,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => null, // has but unimplemented
                'swap' => true,
                'future' => false,
                'option' => false,
                'addMargin' => true,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'createMarketOrder' => false,
                'createOrder' => true,
                'createReduceOnlyOrder' => false,
                'createStopLimitOrder' => true,
                'createStopMarketOrder' => false,
                'createStopOrder' => true,
                'fetchBalance' => true,
                'fetchCanceledOrders' => true,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => true,
                'fetchDepositAddressesByNetwork' => true,
                'fetchDeposits' => true,
                'fetchFundingHistory' => true,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => true,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => true,
                'fetchLeverage' => null,
                'fetchLeverageTiers' => true,
                'fetchMarketLeverageTiers' => 'emulated',
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrderTrades' => true,
                'fetchPosition' => true,
                'fetchPositions' => true,
                'fetchPositionsRisk' => false,
                'fetchPremiumIndexOHLCV' => true,
                'fetchStatus' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => true,
                'fetchTransfer' => true,
                'fetchTransfers' => true,
                'fetchWithdrawals' => true,
                'reduceMargin' => true,
                'setLeverage' => true,
                'setMarginMode' => false,
                'transfer' => true,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '1d' => '1d',
                '1w' => '1w',
                '1M' => '1M',
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/137283979-8b2a818d-8633-461b-bfca-de89e8c446b2.jpg',
                'api' => array(
                    'spot' => array(
                        'public' => 'https://www.mexc.com/open/api/v2',
                        'private' => 'https://www.mexc.com/open/api/v2',
                    ),
                    'contract' => array(
                        'public' => 'https://contract.mexc.com/api/v1/contract',
                        'private' => 'https://contract.mexc.com/api/v1/private',
                    ),
                ),
                'www' => 'https://www.mexc.com/',
                'doc' => array(
                    'https://mxcdevelop.github.io/APIDoc/',
                ),
                'fees' => array(
                    'https://www.mexc.com/fee',
                ),
                'referral' => 'https://m.mexc.com/auth/signup?inviteCode=1FQ1G',
            ),
            'api' => array(
                'contract' => array(
                    'public' => array(
                        'get' => array(
                            'ping' => 2,
                            'detail' => 2,
                            'support_currencies' => 2,
                            'depth/{symbol}' => 2,
                            'depth_commits/{symbol}/{limit}' => 2,
                            'index_price/{symbol}' => 2,
                            'fair_price/{symbol}' => 2,
                            'funding_rate/{symbol}' => 2,
                            'kline/{symbol}' => 2,
                            'kline/index_price/{symbol}' => 2,
                            'kline/fair_price/{symbol}' => 2,
                            'deals/{symbol}' => 2,
                            'ticker' => 2,
                            'risk_reverse' => 2,
                            'risk_reverse/history' => 2,
                            'funding_rate/history' => 2,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            'account/assets' => 2,
                            'account/asset/{currency}' => 2,
                            'account/transfer_record' => 2,
                            'position/list/history_positions' => 2,
                            'position/open_positions' => 2,
                            'position/funding_records' => 2,
                            'position/position_mode' => 2,
                            'order/list/open_orders/{symbol}' => 2,
                            'order/list/history_orders' => 2,
                            'order/external/{symbol}/{external_oid}' => 2,
                            'order/get/{order_id}' => 2,
                            'order/batch_query' => 8,
                            'order/deal_details/{order_id}' => 2,
                            'order/list/order_deals' => 2,
                            'planorder/list/orders' => 2,
                            'stoporder/list/orders' => 2,
                            'stoporder/order_details/{stop_order_id}' => 2,
                            'account/risk_limit' => 2,
                            'account/tiered_fee_rate' => 2,
                        ),
                        'post' => array(
                            'position/change_margin' => 2,
                            'position/change_leverage' => 2,
                            'position/change_position_mode' => 2,
                            'order/submit' => 2,
                            'order/submit_batch' => 40,
                            'order/cancel' => 2,
                            'order/cancel_with_external' => 2,
                            'order/cancel_all' => 2,
                            'account/change_risk_level' => 2,
                            'planorder/place' => 2,
                            'planorder/cancel' => 2,
                            'planorder/cancel_all' => 2,
                            'stoporder/cancel' => 2,
                            'stoporder/cancel_all' => 2,
                            'stoporder/change_price' => 2,
                            'stoporder/change_plan_price' => 2,
                        ),
                    ),
                ),
                'spot' => array(
                    'public' => array(
                        'get' => array(
                            'market/symbols' => 1,
                            'market/coin/list' => 2,
                            'common/timestamp' => 1,
                            'common/ping' => 1,
                            'market/ticker' => 1,
                            'market/depth' => 1,
                            'market/deals' => 1,
                            'market/kline' => 1,
                            'market/api_default_symbols' => 2,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            'account/info' => 1,
                            'order/open_orders' => 1,
                            'order/list' => 1,
                            'order/query' => 1,
                            'order/deals' => 1,
                            'order/deal_detail' => 1,
                            'asset/deposit/address/list' => 2,
                            'asset/deposit/list' => 2,
                            'asset/address/list' => 2,
                            'asset/withdraw/list' => 2,
                            'asset/internal/transfer/record' => 10,
                            'account/balance' => 10,
                            'asset/internal/transfer/info' => 10,
                            'market/api_symbols' => 2,
                        ),
                        'post' => array(
                            'order/place' => 1,
                            'order/place_batch' => 1,
                            'asset/withdraw' => 2,
                            'asset/internal/transfer' => 10,
                        ),
                        'delete' => array(
                            'order/cancel' => 1,
                            'order/cancel_by_symbol' => 1,
                            'asset/withdraw' => 2,
                        ),
                    ),
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'fees' => array(
                'trading' => array(
                    'tierBased' => false,
                    'percentage' => true,
                    'maker' => 0.2 / 100, // maker / taker
                    'taker' => 0.2 / 100,
                ),
            ),
            'options' => array(
                'timeframes' => array(
                    'spot' => array(
                        '1m' => '1m',
                        '5m' => '5m',
                        '15m' => '15m',
                        '30m' => '30m',
                        '1h' => '1h',
                        '1d' => '1d',
                        '1M' => '1M',
                    ),
                    'contract' => array(
                        '1m' => 'Min1',
                        '5m' => 'Min5',
                        '15m' => 'Min15',
                        '30m' => 'Min30',
                        '1h' => 'Min60',
                        '4h' => 'Hour4',
                        '8h' => 'Hour8',
                        '1d' => 'Day1',
                        '1w' => 'Week1',
                        '1M' => 'Month1',
                    ),
                ),
                'defaultType' => 'spot', // spot, swap
                'networks' => array(
                    'TRX' => 'TRC-20',
                    'TRC20' => 'TRC-20',
                    'ETH' => 'ERC-20',
                    'ERC20' => 'ERC-20',
                    'BEP20' => 'BEP20(BSC)',
                ),
                'accountsByType' => array(
                    'spot' => 'MAIN',
                    'swap' => 'CONTRACT',
                ),
                'transfer' => array(
                    'accountsById' => array(
                        'MAIN' => 'spot',
                        'CONTRACT' => 'swap',
                    ),
                    'status' => array(
                        'SUCCESS' => 'ok',
                        'FAILED' => 'failed',
                        'WAIT' => 'pending',
                    ),
                ),
                'fetchOrdersByState' => array(
                    'method' => 'spotPrivateGetOrderList', // contractPrivateGetPlanorderListOrders
                ),
                'cancelOrder' => array(
                    'method' => 'spotPrivateDeleteOrderCancel', // contractPrivatePostOrderCancel contractPrivatePostPlanorderCancel
                ),
            ),
            'commonCurrencies' => array(
                'BEYONDPROTOCOL' => 'BEYOND',
                'BIFI' => 'BIFIF',
                'BYN' => 'BeyondFi',
                'COFI' => 'COFIX', // conflict with CoinFi
                'DFI' => 'DfiStarter',
                'DFT' => 'dFuture',
                'DRK' => 'DRK',
                'EGC' => 'Egoras Credit',
                'FLUX1' => 'FLUX', // switched places
                'FLUX' => 'FLUX1', // switched places
                'FREE' => 'FreeRossDAO', // conflict with FREE Coin
                'GMT' => 'GMT Token',
                'HERO' => 'Step Hero', // conflict with Metahero
                'MIMO' => 'Mimosa',
                'PROS' => 'Pros.Finance', // conflict with Prosper
                'SIN' => 'Sin City Token',
                'STEPN' => 'GMT',
            ),
            'exceptions' => array(
                'exact' => array(
                    '400' => '\\ccxt\\BadRequest', // Invalid parameter
                    '401' => '\\ccxt\\AuthenticationError', // Invalid signature, fail to pass the validation
                    '402' => '\\ccxt\\AuthenticationError', // array("success":false,"code":402,"message":"API key expired!")
                    '403' => '\\ccxt\\PermissionDenied', // array("msg":"no permission to access the endpoint","code":403)
                    '429' => '\\ccxt\\RateLimitExceeded', // too many requests, rate limit rule is violated
                    '703' => '\\ccxt\\PermissionDenied', // Require trade read permission!
                    '1000' => '\\ccxt\\AccountNotEnabled', // array("success":false,"code":1000,"message":"Please open contract account first!")
                    '1002' => '\\ccxt\\InvalidOrder', // array("success":false,"code":1002,"message":"Contract not allow place order!")
                    '10072' => '\\ccxt\\AuthenticationError', // Invalid access key
                    '10073' => '\\ccxt\\AuthenticationError', // Invalid request time
                    '10075' => '\\ccxt\\PermissionDenied', // array("msg":"IP [xxx.xxx.xxx.xxx] not in the ip white list","code":10075)
                    '10101' => '\\ccxt\\InsufficientFunds', // array("code":10101,"msg":"Insufficient balance")
                    '10216' => '\\ccxt\\InvalidAddress', // array("code":10216,"msg":"No available deposit address")
                    '10232' => '\\ccxt\\BadSymbol', // array("code":10232,"msg":"The currency not exist")
                    '30000' => '\\ccxt\\BadSymbol', // Trading is suspended for the requested symbol
                    '30001' => '\\ccxt\\InvalidOrder', // Current trading type (bid or ask) is not allowed
                    '30002' => '\\ccxt\\InvalidOrder', // Invalid trading amount, smaller than the symbol minimum trading amount
                    '30003' => '\\ccxt\\InvalidOrder', // Invalid trading amount, greater than the symbol maximum trading amount
                    '30004' => '\\ccxt\\InsufficientFunds', // Insufficient balance
                    '30005' => '\\ccxt\\InvalidOrder', // Oversell error
                    '30010' => '\\ccxt\\InvalidOrder', // Price out of allowed range
                    '30016' => '\\ccxt\\BadSymbol', // Market is closed
                    '30019' => '\\ccxt\\InvalidOrder', // Orders count over limit for batch processing
                    '30020' => '\\ccxt\\BadSymbol', // Restricted symbol, API access is not allowed for the time being
                    '30021' => '\\ccxt\\BadSymbol', // Invalid symbol
                    '33333' => '\\ccxt\\BadSymbol', // array("code":33333,"msg":"currency can not be null")
                ),
                'broad' => array(
                    'price and quantity must be positive' => '\\ccxt\\InvalidOrder', // array("msg":"price and quantity must be positive","code":400)
                ),
            ),
        ));
    }

    public function fetch_time($params = array ()) {
        /**
         * fetches the current integer timestamp in milliseconds from the exchange server
         * @param {dict} $params extra parameters specific to the mexc api endpoint
         * @return {int} the current integer timestamp in milliseconds from the exchange server
         */
        list($marketType, $query) = $this->handle_market_type_and_params('fetchTime', null, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'spotPublicGetCommonTimestamp',
            'swap' => 'contractPublicGetPing',
        ));
        $response = yield $this->$method (array_merge($query));
        //
        // spot
        //
        //     {
        //         "code":200,
        //         "data":1633375641837
        //     }
        //
        // contract
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":1634095541710
        //     }
        //
        return $this->safe_integer($response, 'data');
    }

    public function fetch_status($params = array ()) {
        /**
         * the latest known information on the availability of the exchange API
         * @param {dict} $params extra parameters specific to the mexc api endpoint
         * @return {dict} a {@link https://docs.ccxt.com/en/latest/manual.html#exchange-$status-structure $status structure}
         */
        $response = yield $this->spotPublicGetCommonPing ($params);
        //
        //     array( "code":200 )
        //
        $code = $this->safe_integer($response, 'code');
        $status = ($code === 200) ? 'ok' : 'maintenance';
        return array(
            'status' => $status,
            'updated' => null,
            'eta' => null,
            'url' => null,
            'info' => $response,
        );
    }

    public function fetch_currencies($params = array ()) {
        /**
         * fetches all available currencies on an exchange
         * @param {dict} $params extra parameters specific to the mexc api endpoint
         * @return {dict} an associative dictionary of currencies
         */
        $response = yield $this->spotPublicGetMarketCoinList ($params);
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             {
        //                 "currency":"AGLD",
        //                 "coins":array(
        //                     array(
        //                         "chain":"ERC20",
        //                         "precision":18,
        //                         "fee":8.09,
        //                         "is_withdraw_enabled":true,
        //                         "is_deposit_enabled":true,
        //                         "deposit_min_confirm":16,
        //                         "withdraw_limit_max":500000.0,
        //                         "withdraw_limit_min":14.0
        //                     }
        //                 ),
        //                 "full_name":"Adventure Gold"
        //             ),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $currency = $data[$i];
            $id = $this->safe_string($currency, 'currency');
            $code = $this->safe_currency_code($id);
            $name = $this->safe_string($currency, 'full_name');
            $currencyActive = false;
            $currencyPrecision = null;
            $currencyFee = null;
            $currencyWithdrawMin = null;
            $currencyWithdrawMax = null;
            $networks = array();
            $chains = $this->safe_value($currency, 'coins', array());
            $depositEnabled = false;
            $withdrawEnabled = false;
            for ($j = 0; $j < count($chains); $j++) {
                $chain = $chains[$j];
                $networkId = $this->safe_string($chain, 'chain');
                $network = $this->safe_network($networkId);
                $isDepositEnabled = $this->safe_value($chain, 'is_deposit_enabled', false);
                $isWithdrawEnabled = $this->safe_value($chain, 'is_withdraw_enabled', false);
                $active = ($isDepositEnabled && $isWithdrawEnabled);
                $currencyActive = $active || $currencyActive;
                $precisionDigits = $this->safe_integer($chain, 'precision');
                $precision = 1 / pow(10, $precisionDigits);
                $withdrawMin = $this->safe_string($chain, 'withdraw_limit_min');
                $withdrawMax = $this->safe_string($chain, 'withdraw_limit_max');
                $currencyWithdrawMin = ($currencyWithdrawMin === null) ? $withdrawMin : $currencyWithdrawMin;
                $currencyWithdrawMax = ($currencyWithdrawMax === null) ? $withdrawMax : $currencyWithdrawMax;
                if (Precise::string_gt($currencyWithdrawMin, $withdrawMin)) {
                    $currencyWithdrawMin = $withdrawMin;
                }
                if (Precise::string_lt($currencyWithdrawMax, $withdrawMax)) {
                    $currencyWithdrawMax = $withdrawMax;
                }
                if ($isDepositEnabled) {
                    $depositEnabled = true;
                }
                if ($isWithdrawEnabled) {
                    $withdrawEnabled = true;
                }
                $networks[$network] = array(
                    'info' => $chain,
                    'id' => $networkId,
                    'network' => $network,
                    'active' => $active,
                    'deposit' => $isDepositEnabled,
                    'withdraw' => $isWithdrawEnabled,
                    'fee' => $this->safe_number($chain, 'fee'),
                    'precision' => $precision,
                    'limits' => array(
                        'withdraw' => array(
                            'min' => $withdrawMin,
                            'max' => $withdrawMax,
                        ),
                    ),
                );
            }
            $networkKeys = is_array($networks) ? array_keys($networks) : array();
            $networkKeysLength = is_array($networkKeys) ? count($networkKeys) : 0;
            if (($networkKeysLength === 1) || (is_array($networks) && array_key_exists('NONE', $networks))) {
                $defaultNetwork = $this->safe_value_2($networks, 'NONE', $networkKeysLength - 1);
                if ($defaultNetwork !== null) {
                    $currencyFee = $defaultNetwork['fee'];
                    $currencyPrecision = $defaultNetwork['precision'];
                }
            }
            $result[$code] = array(
                'id' => $id,
                'code' => $code,
                'info' => $currency,
                'name' => $name,
                'active' => $currencyActive,
                'deposit' => $depositEnabled,
                'withdraw' => $withdrawEnabled,
                'fee' => $currencyFee,
                'precision' => $currencyPrecision,
                'limits' => array(
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'withdraw' => array(
                        'min' => $currencyWithdrawMin,
                        'max' => $currencyWithdrawMax,
                    ),
                ),
                'networks' => $networks,
            );
        }
        return $result;
    }

    public function fetch_markets($params = array ()) {
        /**
         * retrieves data on all markets for mexc
         * @param {dict} $params extra parameters specific to the exchange api endpoint
         * @return {[dict]} an array of objects representing market data
         */
        $defaultType = $this->safe_string_2($this->options, 'fetchMarkets', 'defaultType', 'spot');
        $type = $this->safe_string($params, 'type', $defaultType);
        $query = $this->omit($params, 'type');
        $spot = ($type === 'spot');
        $swap = ($type === 'swap');
        if (!$spot && !$swap) {
            throw new ExchangeError($this->id . " does not support '" . $type . "' $type, set exchange.options['defaultType'] to 'spot' or 'swap''"); // eslint-disable-line quotes
        }
        if ($spot) {
            return yield $this->fetch_spot_markets($query);
        } elseif ($swap) {
            return yield $this->fetch_contract_markets($query);
        }
    }

    public function fetch_contract_markets($params = array ()) {
        $response = yield $this->contractPublicGetDetail ($params);
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":[
        //             array(
        //                 "symbol":"BTC_USDT",
        //                 "displayName":"BTC_USDT永续",
        //                 "displayNameEn":"BTC_USDT SWAP",
        //                 "positionOpenType":3,
        //                 "baseCoin":"BTC",
        //                 "quoteCoin":"USDT",
        //                 "settleCoin":"USDT",
        //                 "contractSize":0.0001,
        //                 "minLeverage":1,
        //                 "maxLeverage":125,
        //                 "priceScale":2,
        //                 "volScale":0,
        //                 "amountScale":4,
        //                 "priceUnit":0.5,
        //                 "volUnit":1,
        //                 "minVol":1,
        //                 "maxVol":1000000,
        //                 "bidLimitPriceRate":0.1,
        //                 "askLimitPriceRate":0.1,
        //                 "takerFeeRate":0.0006,
        //                 "makerFeeRate":0.0002,
        //                 "maintenanceMarginRate":0.004,
        //                 "initialMarginRate":0.008,
        //                 "riskBaseVol":10000,
        //                 "riskIncrVol":200000,
        //                 "riskIncrMmr":0.004,
        //                 "riskIncrImr":0.004,
        //                 "riskLevelLimit":5,
        //                 "priceCoefficientVariation":0.1,
        //                 "indexOrigin":["BINANCE","GATEIO","HUOBI","MXC"],
        //                 "state":0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
        //                 "isNew":false,
        //                 "isHot":true,
        //                 "isHidden":false
        //             ),
        //         ]
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $market = $data[$i];
            $id = $this->safe_string($market, 'symbol');
            $baseId = $this->safe_string($market, 'baseCoin');
            $quoteId = $this->safe_string($market, 'quoteCoin');
            $settleId = $this->safe_string($market, 'settleCoin');
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $settle = $this->safe_currency_code($settleId);
            $state = $this->safe_string($market, 'state');
            $result[] = array(
                'id' => $id,
                'symbol' => $base . '/' . $quote . ':' . $settle,
                'base' => $base,
                'quote' => $quote,
                'settle' => $settle,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'settleId' => $settleId,
                'type' => 'swap',
                'spot' => false,
                'margin' => false,
                'swap' => true,
                'future' => false,
                'option' => false,
                'active' => ($state === '0'),
                'contract' => true,
                'linear' => true,
                'inverse' => false,
                'taker' => $this->safe_number($market, 'takerFeeRate'),
                'maker' => $this->safe_number($market, 'makerFeeRate'),
                'contractSize' => $this->safe_number($market, 'contractSize'),
                'expiry' => null,
                'expiryDatetime' => null,
                'strike' => null,
                'optionType' => null,
                'precision' => array(
                    'amount' => $this->safe_number($market, 'volUnit'),
                    'price' => $this->safe_number($market, 'priceUnit'),
                ),
                'limits' => array(
                    'leverage' => array(
                        'min' => $this->safe_number($market, 'minLeverage'),
                        'max' => $this->safe_number($market, 'maxLeverage'),
                    ),
                    'amount' => array(
                        'min' => $this->safe_number($market, 'minVol'),
                        'max' => $this->safe_number($market, 'maxVol'),
                    ),
                    'price' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
                'info' => $market,
            );
        }
        return $result;
    }

    public function fetch_spot_markets($params = array ()) {
        $response = yield $this->spotPublicGetMarketSymbols ($params);
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             array(
        //                 "symbol":"DFD_USDT",
        //                 "state":"ENABLED",
        //                 "countDownMark":1,
        //                 "vcoinName":"DFD",
        //                 "vcoinStatus":1,
        //                 "price_scale":4,
        //                 "quantity_scale":2,
        //                 "min_amount":"5", // not an amount = cost
        //                 "max_amount":"5000000",
        //                 "maker_fee_rate":"0.002",
        //                 "taker_fee_rate":"0.002",
        //                 "limited":true,
        //                 "etf_mark":0,
        //                 "symbol_partition":"ASSESS"
        //             ),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $response2 = yield $this->spotPublicGetMarketApiDefaultSymbols ($params);
        //
        //     {
        //         "code":200,
        //         "data":{
        //             "symbol":array(
        //                 "ALEPH_USDT","OGN_USDT","HC_USDT",
        //              )
        //         }
        //     }
        //
        $data2 = $this->safe_value($response2, 'data', array());
        $symbols = $this->safe_value($data2, 'symbol', array());
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $market = $data[$i];
            $id = $this->safe_string($market, 'symbol');
            list($baseId, $quoteId) = explode('_', $id);
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $priceScale = $this->safe_string($market, 'price_scale');
            $quantityScale = $this->safe_string($market, 'quantity_scale');
            $state = $this->safe_string($market, 'state');
            $active = false;
            for ($j = 0; $j < count($symbols); $j++) {
                if ($symbols[$j] === $id) {
                    if ($state === 'ENABLED') {
                        $active = true;
                    }
                    break;
                }
            }
            $result[] = array(
                'id' => $id,
                'symbol' => $base . '/' . $quote,
                'base' => $base,
                'quote' => $quote,
                'settle' => null,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'settleId' => null,
                'type' => 'spot',
                'spot' => true,
                'margin' => false,
                'swap' => false,
                'future' => false,
                'option' => false,
                'active' => $active,
                'contract' => false,
                'linear' => null,
                'inverse' => null,
                'taker' => $this->safe_number($market, 'taker_fee_rate'),
                'maker' => $this->safe_number($market, 'maker_fee_rate'),
                'contractSize' => null,
                'expiry' => null,
                'expiryDatetime' => null,
                'strike' => null,
                'optionType' => null,
                'precision' => array(
                    'amount' => $this->parse_number($this->parse_precision($quantityScale)),
                    'price' => $this->parse_number($this->parse_precision($priceScale)),
                ),
                'limits' => array(
                    'leverage' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'price' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => $this->safe_number($market, 'min_amount'),
                        'max' => $this->safe_number($market, 'max_amount'),
                    ),
                ),
                'info' => $market,
            );
        }
        return $result;
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        /**
         * fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
         * @param {[str]|null} $symbols unified $symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
         * @param {dict} $params extra parameters specific to the mexc api endpoint
         * @return {dict} an array of {@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structures}
         */
        yield $this->load_markets();
        list($marketType, $query) = $this->handle_market_type_and_params('fetchTickers', null, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'spotPublicGetMarketTicker',
            'swap' => 'contractPublicGetTicker',
        ));
        $response = yield $this->$method (array_merge($query));
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":array(
        //             array(
        //                 "symbol":"NKN_USDT",
        //                 "lastPrice":0.36199,
        //                 "bid1":0.35908,
        //                 "ask1":0.36277,
        //                 "volume24":657754,
        //                 "amount24":239024.53998,
        //                 "holdVol":149969,
        //                 "lower24Price":0.34957,
        //                 "high24Price":0.37689,
        //                 "riseFallRate":0.0117,
        //                 "riseFallValue":0.00419,
        //                 "indexPrice":0.36043,
        //                 "fairPrice":0.36108,
        //                 "fundingRate":0.000535,
        //                 "maxBidPrice":0.43251,
        //                 "minAskPrice":0.28834,
        //                 "timestamp":1634163352075
        //             ),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_tickers($data, $symbols);
    }

    public function fetch_ticker($symbol, $params = array ()) {
        /**
         * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
         * @param {str} $symbol unified $symbol of the $market to fetch the $ticker for
         * @param {dict} $params extra parameters specific to the mexc api endpoint
         * @return {dict} a {@link https://docs.ccxt.com/en/latest/manual.html#$ticker-structure $ticker structure}
         */
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $method = null;
        if ($market['spot']) {
            $method = 'spotPublicGetMarketTicker';
        } elseif ($market['swap']) {
            $method = 'contractPublicGetTicker';
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             {
        //                 "symbol":"BTC_USDT",
        //                 "volume":"880.821523",
        //                 "high":"49496.95", // highest price over the past 24 hours
        //                 "low":"46918.4", // lowest
        //                 "bid":"49297.64", // current buying price == the best price you can sell for
        //                 "ask":"49297.75", // current selling price == the best price you can buy for
        //                 "open":"48764.9", // open price 24h ago
        //                 "last":"49297.73", // last = close
        //                 "time":1633378200000, // timestamp
        //                 "change_rate":"0.0109265" // (last / open) - 1
        //             }
        //         )
        //     }
        //
        // swap / contract
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":{
        //             "symbol":"ETH_USDT",
        //             "lastPrice":3581.3,
        //             "bid1":3581.25,
        //             "ask1":3581.5,
        //             "volume24":4045530,
        //             "amount24":141331823.5755,
        //             "holdVol":5832946,
        //             "lower24Price":3413.4,
        //             "high24Price":3588.7,
        //             "riseFallRate":0.0275,
        //             "riseFallValue":95.95,
        //             "indexPrice":3580.7852,
        //             "fairPrice":3581.08,
        //             "fundingRate":0.000063,
        //             "maxBidPrice":3938.85,
        //             "minAskPrice":3222.7,
        //             "timestamp":1634162885016
        //         }
        //     }
        //
        if ($market['spot']) {
            $data = $this->safe_value($response, 'data', array());
            $ticker = $this->safe_value($data, 0);
            return $this->parse_ticker($ticker, $market);
        } elseif ($market['swap']) {
            $data = $this->safe_value($response, 'data', array());
            return $this->parse_ticker($data, $market);
        }
    }

    public function parse_ticker($ticker, $market = null) {
        //
        // spot
        //
        //     {
        //         "symbol":"BTC_USDT",
        //         "volume":"880.821523",
        //         "high":"49496.95",
        //         "low":"46918.4",
        //         "bid":"49297.64",
        //         "ask":"49297.75",
        //         "open":"48764.9",
        //         "last":"49297.73",
        //         "time":1633378200000,
        //         "change_rate":"0.0109265"
        //     }
        //
        // contract
        //
        //     {
        //         "symbol":"ETH_USDT",
        //         "lastPrice":3581.3,
        //         "bid1":3581.25,
        //         "ask1":3581.5,
        //         "volume24":4045530,
        //         "amount24":141331823.5755,
        //         "holdVol":5832946,
        //         "lower24Price":3413.4,
        //         "high24Price":3588.7,
        //         "riseFallRate":0.0275,
        //         "riseFallValue":95.95,
        //         "indexPrice":3580.7852,
        //         "fairPrice":3581.08,
        //         "fundingRate":0.000063,
        //         "maxBidPrice":3938.85,
        //         "minAskPrice":3222.7,
        //         "timestamp":1634162885016
        //     }
        //
        $timestamp = $this->safe_integer_2($ticker, 'time', 'timestamp');
        $marketId = $this->safe_string($ticker, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market, '_');
        $baseVolume = $this->safe_string_2($ticker, 'volume', 'volume24');
        $quoteVolume = $this->safe_string($ticker, 'amount24');
        $open = $this->safe_string($ticker, 'open');
        $last = $this->safe_string_2($ticker, 'last', 'lastPrice');
        $change = $this->safe_string($ticker, 'riseFallValue');
        $riseFallRate = $this->safe_string($ticker, 'riseFallRate');
        $percentage = Precise::string_add($riseFallRate, '1');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string_2($ticker, 'high', 'high24Price'),
            'low' => $this->safe_string_2($ticker, 'low', 'lower24Price'),
            'bid' => $this->safe_string_2($ticker, 'bid', 'bid1'),
            'bidVolume' => null,
            'ask' => $this->safe_string_2($ticker, 'ask', 'ask1'),
            'askVolume' => null,
            'vwap' => null,
            'open' => $open,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => $change,
            'percentage' => $percentage,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        /**
         * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other $data
         * @param {str} $symbol unified $symbol of the $market to fetch the order book for
         * @param {int|null} $limit the maximum amount of order book entries to return
         * @param {dict} $params extra parameters specific to the mexc api endpoint
         * @return {dict} A dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure order book structures} indexed by $market symbols
         */
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $method = null;
        if ($market['spot']) {
            $method = 'spotPublicGetMarketDepth';
            if ($limit === null) {
                $limit = 100; // the spot api requires a $limit
            }
            $request['depth'] = $limit;
        } elseif ($market['swap']) {
            $method = 'contractPublicGetDepthSymbol';
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot
        //
        //     {
        //         "code":200,
        //         "data":{
        //             "asks":array(
        //                 array("price":"49060.56","quantity":"0.099842"),
        //                 array("price":"49060.58","quantity":"0.016003"),
        //                 array("price":"49060.6","quantity":"0.023677")
        //             ),
        //             "bids":array(
        //                 array("price":"49060.45","quantity":"1.693009"),
        //                 array("price":"49060.44","quantity":"0.000843"),
        //                 array("price":"49059.98","quantity":"0.735"),
        //             ),
        //             "version":"202454074",
        //         }
        //     }
        //
        // swap / contract
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":{
        //             "asks":[
        //                 [3445.7,48379,1],
        //                 [3445.75,34994,1],
        //                 [3445.8,68634,2],
        //             ],
        //             "bids":[
        //                 [3445.55,44081,1],
        //                 [3445.5,24857,1],
        //                 [3445.45,50272,1],
        //             ],
        //             "version":2827730444,
        //             "timestamp":1634117846232
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $priceKey = $market['spot'] ? 'price' : 0;
        $amountKey = $market['spot'] ? 'quantity' : 1;
        $timestamp = $this->safe_integer($data, 'timestamp');
        $orderbook = $this->parse_order_book($data, $symbol, $timestamp, 'bids', 'asks', $priceKey, $amountKey);
        $orderbook['nonce'] = $this->safe_integer($data, 'version');
        return $orderbook;
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        /**
         * get the list of most recent trades for a particular $symbol
         * @param {str} $symbol unified $symbol of the $market to fetch trades for
         * @param {int|null} $since timestamp in ms of the earliest trade to fetch
         * @param {int|null} $limit the maximum amount of trades to fetch
         * @param {dict} $params extra parameters specific to the mexc api endpoint
         * @return {[dict]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-trades trade structures~
         */
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit; // default 100, max 100
        }
        $method = null;
        if ($market['spot']) {
            $method = 'spotPublicGetMarketDeals';
        } elseif ($market['swap']) {
            $method = 'contractPublicGetDealsSymbol';
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             array("trade_time":1633381766725,"trade_price":"0.068981","trade_quantity":"0.005","trade_type":"BID"),
        //             array("trade_time":1633381732705,"trade_price":"0.068979","trade_quantity":"0.006","trade_type":"BID"),
        //             array("trade_time":1633381694604,"trade_price":"0.068975","trade_quantity":"0.011","trade_type":"ASK"),
        //         )
        //     }
        //
        // swap / contract
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":array(
        //             array("p":3598.85,"v":52,"T":1,"O":2,"M":2,"t":1634169038038),
        //             array("p":3599.2,"v":15,"T":2,"O":3,"M":1,"t":1634169035603),
        //             array("p":3600.15,"v":229,"T":2,"O":1,"M":2,"t":1634169026354),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_trades($data, $market, $since, $limit);
    }

    public function parse_trade($trade, $market = null) {
        //
        // public fetchTrades
        //
        //     spot
        //
        //     {
        //         "trade_time":1633381766725,
        //         "trade_price":"0.068981",
        //         "trade_quantity":"0.005",
        //         "trade_type":"BID"
        //     }
        //
        //     swap / contract
        //
        //     {
        //         "p":3598.85,
        //         "v":52,
        //         "T":1, // 1 buy, 2 sell
        //         "O":2, // 1 opens a position, 2 does not open a position
        //         "M":2, // self-trading, 1 yes, 2 no
        //         "t":1634169038038
        //     }
        //
        // private fetchMyTrades, fetchOrderTrades
        //
        //     {
        //         "id":"b160b8f072d9403e96289139d5544809",
        //         "symbol":"USDC_USDT",
        //         "quantity":"150",
        //         "price":"0.9997",
        //         "amount":"149.955",
        //         "fee":"0.29991",
        //         "trade_type":"ASK",
        //         "order_id":"d798765285374222990bbd14decb86cd",
        //         "is_taker":true,
        //         "fee_currency":"USDT",
        //         "create_time":1633984904000
        //     }
        //
        $timestamp = $this->safe_integer_2($trade, 'create_time', 'trade_time');
        $timestamp = $this->safe_integer($trade, 't', $timestamp);
        $marketId = $this->safe_string($trade, 'symbol');
        $market = $this->safe_market($marketId, $market, '_');
        $symbol = $market['symbol'];
        $priceString = $this->safe_string_2($trade, 'price', 'trade_price');
        $priceString = $this->safe_string($trade, 'p', $priceString);
        $amountString = $this->safe_string_2($trade, 'quantity', 'trade_quantity');
        $amountString = $this->safe_string($trade, 'v', $amountString);
        $costString = $this->safe_string($trade, 'amount');
        $side = $this->safe_string_2($trade, 'trade_type', 'T');
        if (($side === 'BID') || ($side === '1')) {
            $side = 'buy';
        } elseif (($side === 'ASK') || ($side === '2')) {
            $side = 'sell';
        }
        $id = $this->safe_string_2($trade, 'id', 'trade_time');
        if ($id === null) {
            $id = $this->safe_string($trade, 't', $id);
            if ($id !== null) {
                $id .= '-' . $market['id'] . '-' . $amountString;
            }
        }
        $feeCostString = $this->safe_string($trade, 'fee');
        $fee = null;
        if ($feeCostString !== null) {
            $feeCurrencyId = $this->safe_string($trade, 'fee_currency');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCostString,
                'currency' => $feeCurrencyCode,
            );
        }
        $orderId = $this->safe_string($trade, 'order_id');
        $isTaker = $this->safe_value($trade, 'is_taker', true);
        $takerOrMaker = $isTaker ? 'taker' : 'maker';
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $id,
            'order' => $orderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => $costString,
            'fee' => $fee,
        ), $market);
    }

    public function fetch_trading_fees($params = array ()) {
        yield $this->load_markets();
        $response = yield $this->spotPublicGetMarketSymbols ($params);
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             array(
        //                 "symbol":"DFD_USDT",
        //                 "state":"ENABLED",
        //                 "countDownMark":1,
        //                 "vcoinName":"DFD",
        //                 "vcoinStatus":1,
        //                 "price_scale":4,
        //                 "quantity_scale":2,
        //                 "min_amount":"5", // not an amount = cost
        //                 "max_amount":"5000000",
        //                 "maker_fee_rate":"0.002",
        //                 "taker_fee_rate":"0.002",
        //                 "limited":true,
        //                 "etf_mark":0,
        //                 "symbol_partition":"ASSESS"
        //             ),
        //             ...
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $fee = $data[$i];
            $marketId = $this->safe_string($fee, 'symbol');
            $market = $this->safe_market($marketId, null, '_');
            $symbol = $market['symbol'];
            $result[$symbol] = array(
                'info' => $fee,
                'symbol' => $symbol,
                'maker' => $this->safe_number($fee, 'maker_fee_rate'),
                'taker' => $this->safe_number($fee, 'taker_fee_rate'),
                'percentage' => true,
                'tierBased' => false,
            );
        }
        return $result;
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        /**
         * fetches historical candlestick $data containing the open, high, low, and close price, and the volume of a $market
         * @param {str} $symbol unified $symbol of the $market to fetch OHLCV $data for
         * @param {str} $timeframe the length of time each candle represents
         * @param {int|null} $since timestamp in ms of the earliest candle to fetch
         * @param {int|null} $limit the maximum amount of candles to fetch
         * @param {dict} $params extra parameters specific to the mexc api endpoint
         * @return {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
         */
        yield $this->load_markets();
        $market = $this->market($symbol);
        $options = $this->safe_value($this->options, 'timeframes', array());
        $timeframes = $this->safe_value($options, $market['type'], array());
        $timeframeValue = $this->safe_string($timeframes, $timeframe);
        if ($timeframeValue === null) {
            throw new NotSupported($this->id . ' fetchOHLCV() does not support ' . $timeframe . ' $timeframe for ' . $market['type'] . ' markets');
        }
        $request = array(
            'symbol' => $market['id'],
            'interval' => $timeframeValue,
        );
        $method = null;
        if ($market['spot']) {
            $method = 'spotPublicGetMarketKline';
            if ($since !== null) {
                $request['start_time'] = intval($since / 1000);
            }
            if ($limit !== null) {
                $request['limit'] = $limit; // default 100
            }
        } elseif ($market['swap']) {
            $method = 'contractPublicGetKlineSymbol';
            if ($since !== null) {
                $request['start'] = intval($since / 1000);
            }
            // $request['end'] = $this->seconds();
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot
        //
        //     {
        //         "code":200,
        //         "data":[
        //             [1633377000,"49227.47","49186.21","49227.47","49169.48","0.5984809999999999","29434.259665989997"],
        //             [1633377060,"49186.21","49187.03","49206.64","49169.18","0.3658478","17990.651234393"],
        //             [1633377120,"49187.03","49227.2","49227.2","49174.4","0.0687651","3382.353190352"],
        //         ],
        //     }
        //
        // swap / contract
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":{
        //             "time":[1634052300,1634052360,1634052420],
        //             "open":[3492.2,3491.3,3495.65],
        //             "close":[3491.3,3495.65,3495.2],
        //             "high":[3495.85,3496.55,3499.4],
        //             "low":[3491.15,3490.9,3494.2],
        //             "vol":[1740.0,351.0,314.0],
        //             "amount":[60793.623,12260.4885,10983.1375],
        //         }
        //     }
        //
        if ($market['spot']) {
            $data = $this->safe_value($response, 'data', array());
            return $this->parse_ohlcvs($data, $market, $timeframe, $since, $limit);
        } elseif ($market['swap']) {
            $data = $this->safe_value($response, 'data', array());
            $result = $this->convert_trading_view_to_ohlcv($data, 'time', 'open', 'high', 'low', 'close', 'vol');
            return $this->parse_ohlcvs($result, $market, $timeframe, $since, $limit);
        }
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        //
        // the ordering in spot candles is OCHLV
        //
        //     array(
        //         1633377000, // 0 timestamp (unix seconds)
        //         "49227.47", // 1 open price
        //         "49186.21", // 2 closing price
        //         "49227.47", // 3 high
        //         "49169.48", // 4 low
        //         "0.5984809999999999", // 5 base volume
        //         "29434.259665989997", // 6 quote volume
        //     )
        //
        // the ordering in swap / contract candles is OHLCV
        //
        return [
            $this->safe_timestamp($ohlcv, 0),
            $this->safe_number($ohlcv, 1),
            $this->safe_number($ohlcv, $market['spot'] ? 3 : 2),
            $this->safe_number($ohlcv, $market['spot'] ? 4 : 3),
            $this->safe_number($ohlcv, $market['spot'] ? 2 : 4),
            $this->safe_number($ohlcv, 5),
        ];
    }

    public function fetch_balance($params = array ()) {
        /**
         * $query for $balance and get the amount of funds available for trading or funds locked in orders
         * @param {dict} $params extra parameters specific to the mexc api endpoint
         * @return {dict} a ~@link https://docs.ccxt.com/en/latest/manual.html?#$balance-structure $balance structure~
         */
        yield $this->load_markets();
        list($marketType, $query) = $this->handle_market_type_and_params('fetchBalance', null, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'spotPrivateGetAccountInfo',
            'margin' => 'spotPrivateGetAccountInfo',
            'swap' => 'contractPrivateGetAccountAssets',
        ));
        $spot = ($marketType === 'spot');
        $response = yield $this->$method ($query);
        //
        // $spot
        //
        //     {
        //         $code => "200",
        //         $data => {
        //             USDC => array( frozen => "0", available => "150" )
        //         }
        //     }
        //
        // swap / contract
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":array(
        //             array("currency":"BSV","positionMargin":0,"availableBalance":0,"cashBalance":0,"frozenBalance":0,"equity":0,"unrealized":0,"bonus":0),
        //             array("currency":"BCH","positionMargin":0,"availableBalance":0,"cashBalance":0,"frozenBalance":0,"equity":0,"unrealized":0,"bonus":0),
        //             array("currency":"CRV","positionMargin":0,"availableBalance":0,"cashBalance":0,"frozenBalance":0,"equity":0,"unrealized":0,"bonus":0),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $currentTime = $this->milliseconds();
        $result = array(
            'info' => $response,
            'timestamp' => $currentTime,
            'datetime' => $this->iso8601($currentTime),
        );
        if ($spot) {
            $currencyIds = is_array($data) ? array_keys($data) : array();
            for ($i = 0; $i < count($currencyIds); $i++) {
                $currencyId = $currencyIds[$i];
                $code = $this->safe_currency_code($currencyId);
                $balance = $this->safe_value($data, $currencyId, array());
                $account = $this->account();
                $account['free'] = $this->safe_string($balance, 'available');
                $account['used'] = $this->safe_string($balance, 'frozen');
                $result[$code] = $account;
            }
        } else {
            for ($i = 0; $i < count($data); $i++) {
                $balance = $data[$i];
                $currencyId = $this->safe_string($balance, 'currency');
                $code = $this->safe_currency_code($currencyId);
                $account = $this->account();
                $account['free'] = $this->safe_string($balance, 'availableBalance');
                $account['used'] = $this->safe_string($balance, 'frozenBalance');
                $result[$code] = $account;
            }
        }
        return $this->safe_balance($result);
    }

    public function safe_network($networkId) {
        if (mb_strpos($networkId, 'BSC') !== false) {
            return 'BEP20';
        }
        $parts = explode(' ', $networkId);
        $networkId = implode('', $parts);
        $networkId = str_replace('-20', '20', $networkId);
        $networksById = array(
            'ETH' => 'ETH',
            'ERC20' => 'ERC20',
            'BEP20(BSC)' => 'BEP20',
            'TRX' => 'TRC20',
        );
        return $this->safe_string($networksById, $networkId, $networkId);
    }

    public function parse_deposit_address($depositAddress, $currency = null) {
        //
        //     array("chain":"ERC-20","address":"0x55cbd73db24eafcca97369e3f2db74b2490586e6"),
        //     array("chain":"MATIC","address":"0x05aa3236f1970eae0f8feb17ec19435b39574d74"),
        //     array("chain":"TRC20","address":"TGaPfhW41EXD3sAfs1grLF6DKfugfqANNw"),
        //     array("chain":"SOL","address":"5FSpUKuh2gjw4mF89T2e7sEjzUA1SkRKjBChFqP43KhV"),
        //     array("chain":"ALGO","address":"B3XTZND2JJTSYR7R2TQVCUDT4QSSYVAIZYDPWVBX34DGAYATBU3AUV43VU")
        //
        //
        $address = $this->safe_string($depositAddress, 'address');
        $code = $this->safe_currency_code(null, $currency);
        $networkId = $this->safe_string($depositAddress, 'chain');
        $network = $this->safe_network($networkId);
        $this->check_address($address);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => null,
            'network' => $network,
            'info' => $depositAddress,
        );
    }

    public function fetch_deposit_addresses_by_network($code, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'currency' => $currency['id'],
        );
        $response = yield $this->spotPrivateGetAssetDepositAddressList (array_merge($request, $params));
        //
        //     {
        //         "code":200,
        //         "data":{
        //             "currency":"USDC",
        //             "chains":array(
        //                 array("chain":"ERC-20","address":"0x55cbd73db24eafcca97369e3f2db74b2490586e6"),
        //                 array("chain":"MATIC","address":"0x05aa3236f1970eae0f8feb17ec19435b39574d74"),
        //                 array("chain":"TRC20","address":"TGaPfhW41EXD3sAfs1grLF6DKfugfqANNw"),
        //                 array("chain":"SOL","address":"5FSpUKuh2gjw4mF89T2e7sEjzUA1SkRKjBChFqP43KhV"),
        //                 array("chain":"ALGO","address":"B3XTZND2JJTSYR7R2TQVCUDT4QSSYVAIZYDPWVBX34DGAYATBU3AUV43VU")
        //             )
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $chains = $this->safe_value($data, 'chains', array());
        $depositAddresses = array();
        for ($i = 0; $i < count($chains); $i++) {
            $depositAddress = $this->parse_deposit_address($chains[$i], $currency);
            $depositAddresses[] = $depositAddress;
        }
        return $this->index_by($depositAddresses, 'network');
    }

    public function fetch_deposit_address($code, $params = array ()) {
        $rawNetwork = $this->safe_string_upper($params, 'network');
        $params = $this->omit($params, 'network');
        $response = yield $this->fetch_deposit_addresses_by_network($code, $params);
        $networks = $this->safe_value($this->options, 'networks', array());
        $network = $this->safe_string($networks, $rawNetwork, $rawNetwork);
        $result = null;
        if ($network === null) {
            $result = $this->safe_value($response, $code);
            if ($result === null) {
                $alias = $this->safe_string($networks, $code, $code);
                $result = $this->safe_value($response, $alias);
                if ($result === null) {
                    $defaultNetwork = $this->safe_string($this->options, 'defaultNetwork', 'ERC20');
                    $result = $this->safe_value($response, $defaultNetwork);
                    if ($result === null) {
                        $values = is_array($response) ? array_values($response) : array();
                        $result = $this->safe_value($values, 0);
                        if ($result === null) {
                            throw new InvalidAddress($this->id . ' fetchDepositAddress() cannot find deposit address for ' . $code);
                        }
                    }
                }
            }
            return $result;
        }
        // TODO => add support for all aliases here
        $result = $this->safe_value($response, $rawNetwork);
        if ($result === null) {
            throw new InvalidAddress($this->id . ' fetchDepositAddress() cannot find ' . $network . ' deposit address for ' . $code);
        }
        return $result;
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array(
            // 'currency' => $currency['id'],
            // 'state' => 'state',
            // 'start_time' => $since, // default 1 day
            // 'end_time' => $this->milliseconds(),
            // 'page_num' => 1,
            // 'page_size' => $limit, // default 20, maximum 50
        );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'];
        }
        if ($since !== null) {
            $request['start_time'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = yield $this->spotPrivateGetAssetDepositList (array_merge($request, $params));
        //
        //     {
        //         "code":200,
        //         "data":{
        //             "page_size":20,
        //             "total_page":1,
        //             "total_size":1,
        //             "page_num":1,
        //             "result_list":array(
        //                 {
        //                     "currency":"USDC",
        //                     "amount":150.0,
        //                     "fee":0.0,
        //                     "confirmations":19,
        //                     "address":"0x55cbd73db24eafcca97369e3f2db74b2490586e6",
        //                     "state":"SUCCESS",
        //                     "tx_id":"0xc65a9b09e1b71def81bf8bb3ec724c0c1b2b4c82200c8c142e4ea4c1469fd789:0",
        //                     "require_confirmations":12,
        //                     "create_time":"2021-10-11T18:58:25.000+00:00",
        //                     "update_time":"2021-10-11T19:01:06.000+00:00"
        //                 }
        //             )
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $resultList = $this->safe_value($data, 'result_list', array());
        return $this->parse_transactions($resultList, $code, $since, $limit);
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array(
            // 'withdrawal_id' => '4b450616042a48c99dd45cacb4b092a7', // string
            // 'currency' => $currency['id'],
            // 'state' => 'state',
            // 'start_time' => $since, // default 1 day
            // 'end_time' => $this->milliseconds(),
            // 'page_num' => 1,
            // 'page_size' => $limit, // default 20, maximum 50
        );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'];
        }
        if ($since !== null) {
            $request['start_time'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = yield $this->spotPrivateGetAssetWithdrawList (array_merge($request, $params));
        //
        //     {
        //         "code":200,
        //         "data":{
        //             "page_size":20,
        //             "total_page":1,
        //             "total_size":1,
        //             "page_num":1,
        //             "result_list":array(
        //                 {
        //                     "id":"4b450616042a48c99dd45cacb4b092a7",
        //                     "currency":"USDT-TRX",
        //                     "address":"TRHKnx74Gb8UVcpDCMwzZVe4NqXfkdtPak",
        //                     "amount":30.0,
        //                     "fee":1.0,
        //                     "remark":"this is my first withdrawal remark",
        //                     "state":"WAIT",
        //                     "create_time":"2021-10-11T20:45:08.000+00:00"
        //                 }
        //             )
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $resultList = $this->safe_value($data, 'result_list', array());
        return $this->parse_transactions($resultList, $code, $since, $limit);
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // fetchDeposits
        //
        //     {
        //         "currency":"USDC",
        //         "amount":150.0,
        //         "fee":0.0,
        //         "confirmations":19,
        //         "address":"0x55cbd73db24eafcca97369e3f2db74b2490586e6",
        //         "state":"SUCCESS",
        //         "tx_id":"0xc65a9b09e1b71def81bf8bb3ec724c0c1b2b4c82200c8c142e4ea4c1469fd789:0",
        //         "require_confirmations":12,
        //         "create_time":"2021-10-11T18:58:25.000+00:00",
        //         "update_time":"2021-10-11T19:01:06.000+00:00"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "id":"4b450616042a48c99dd45cacb4b092a7",
        //         "currency":"USDT-TRX",
        //         "address":"TRHKnx74Gb8UVcpDCMwzZVe4NqXfkdtPak",
        //         "amount":30.0,
        //         "fee":1.0,
        //         "remark":"this is my first withdrawal remark",
        //         "state":"WAIT",
        //         "create_time":"2021-10-11T20:45:08.000+00:00"
        //     }
        //
        $id = $this->safe_string($transaction, 'id');
        $type = ($id === null) ? 'deposit' : 'withdrawal';
        $timestamp = $this->parse8601($this->safe_string($transaction, 'create_time'));
        $updated = $this->parse8601($this->safe_string($transaction, 'update_time'));
        $currencyId = $this->safe_string($transaction, 'currency');
        $network = null;
        if (($currencyId !== null) && (mb_strpos($currencyId, '-') !== false)) {
            $parts = explode('-', $currencyId);
            $currencyId = $this->safe_string($parts, 0);
            $networkId = $this->safe_string($parts, 1);
            $network = $this->safe_network($networkId);
        }
        $code = $this->safe_currency_code($currencyId, $currency);
        $status = $this->parse_transaction_status($this->safe_string($transaction, 'state'));
        $amountString = $this->safe_string($transaction, 'amount');
        $address = $this->safe_string($transaction, 'address');
        $txid = $this->safe_string($transaction, 'tx_id');
        $fee = null;
        $feeCostString = $this->safe_string($transaction, 'fee');
        if ($feeCostString !== null) {
            $fee = array(
                'cost' => $this->parse_number($feeCostString),
                'currency' => $code,
            );
        }
        if ($type === 'withdrawal') {
            // mexc withdrawal amount includes the $fee
            $amountString = Precise::string_sub($amountString, $feeCostString);
        }
        return array(
            'info' => $transaction,
            'id' => $id,
            'txid' => $txid,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => $network,
            'address' => $address,
            'addressTo' => null,
            'addressFrom' => null,
            'tag' => null,
            'tagTo' => null,
            'tagFrom' => null,
            'type' => $type,
            'amount' => $this->parse_number($amountString),
            'currency' => $code,
            'status' => $status,
            'updated' => $updated,
            'fee' => $fee,
        );
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            'WAIT' => 'pending',
            'WAIT_PACKAGING' => 'pending',
            'SUCCESS' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function fetch_position($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = yield $this->fetch_positions(array_merge($request, $params));
        $firstPosition = $this->safe_value($response, 0);
        return $this->parse_position($firstPosition, $market);
    }

    public function fetch_positions($symbols = null, $params = array ()) {
        yield $this->load_markets();
        $response = yield $this->contractPrivateGetPositionOpenPositions ($params);
        //
        //     {
        //         "success" => true,
        //         "code" => 0,
        //         "data" => array(
        //             {
        //                 "positionId" => 1394650,
        //                 "symbol" => "ETH_USDT",
        //                 "positionType" => 1,
        //                 "openType" => 1,
        //                 "state" => 1,
        //                 "holdVol" => 1,
        //                 "frozenVol" => 0,
        //                 "closeVol" => 0,
        //                 "holdAvgPrice" => 1217.3,
        //                 "openAvgPrice" => 1217.3,
        //                 "closeAvgPrice" => 0,
        //                 "liquidatePrice" => 1211.2,
        //                 "oim" => 0.1290338,
        //                 "im" => 0.1290338,
        //                 "holdFee" => 0,
        //                 "realised" => -0.0073,
        //                 "leverage" => 100,
        //                 "createTime" => 1609991676000,
        //                 "updateTime" => 1609991676000,
        //                 "autoAddIm" => false
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_positions($data, $symbols);
    }

    public function parse_position($position, $market = null) {
        //
        //     {
        //         "positionId" => 1394650,
        //         "symbol" => "ETH_USDT",
        //         "positionType" => 1,
        //         "openType" => 1,
        //         "state" => 1,
        //         "holdVol" => 1,
        //         "frozenVol" => 0,
        //         "closeVol" => 0,
        //         "holdAvgPrice" => 1217.3,
        //         "openAvgPrice" => 1217.3,
        //         "closeAvgPrice" => 0,
        //         "liquidatePrice" => 1211.2,
        //         "oim" => 0.1290338,
        //         "im" => 0.1290338,
        //         "holdFee" => 0,
        //         "realised" => -0.0073,
        //         "leverage" => 100,
        //         "createTime" => 1609991676000,
        //         "updateTime" => 1609991676000,
        //         "autoAddIm" => false
        //     }
        //
        $market = $this->safe_market($this->safe_string($position, 'symbol'), $market);
        $symbol = $market['symbol'];
        $contracts = $this->safe_string($position, 'holdVol');
        $entryPrice = $this->safe_number($position, 'openAvgPrice');
        $initialMargin = $this->safe_string($position, 'im');
        $rawSide = $this->safe_string($position, 'positionType');
        $side = ($rawSide === '1') ? 'long' : 'short';
        $openType = $this->safe_string($position, 'margin_mode');
        $marginMode = ($openType === '1') ? 'isolated' : 'cross';
        $leverage = $this->safe_string($position, 'leverage');
        $liquidationPrice = $this->safe_number($position, 'liquidatePrice');
        $timestamp = $this->safe_number($position, 'updateTime');
        return array(
            'info' => $position,
            'symbol' => $symbol,
            'contracts' => $this->parse_number($contracts),
            'contractSize' => null,
            'entryPrice' => $entryPrice,
            'collateral' => null,
            'side' => $side,
            'unrealizedProfit' => null,
            'leverage' => $this->parse_number($leverage),
            'percentage' => null,
            'marginMode' => $marginMode,
            'marginType' => $marginMode, // deprecated
            'notional' => null,
            'markPrice' => null,
            'liquidationPrice' => $liquidationPrice,
            'initialMargin' => $this->parse_number($initialMargin),
            'initialMarginPercentage' => null,
            'maintenanceMargin' => null,
            'maintenanceMarginPercentage' => null,
            'marginRatio' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
        );
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        list($marketType, $query) = $this->handle_market_type_and_params('createOrder', $market, $params);
        if ($marketType === 'spot') {
            return yield $this->create_spot_order($symbol, $type, $side, $amount, $price, $query);
        } elseif ($marketType === 'swap') {
            return yield $this->create_swap_order($symbol, $type, $side, $amount, $price, $query);
        }
    }

    public function create_spot_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $orderSide = null;
        if ($side === 'buy') {
            $orderSide = 'BID';
        } elseif ($side === 'sell') {
            $orderSide = 'ASK';
        }
        $orderType = strtoupper($type);
        $isMarketOrder = $orderType === 'MARKET';
        if ($isMarketOrder) {
            throw new InvalidOrder($this->id . ' createOrder () does not support $market orders, only limit orders are allowed');
        }
        if ($orderType === 'LIMIT') {
            $orderType = 'LIMIT_ORDER';
        }
        $postOnly = $this->is_post_only($isMarketOrder, $orderType === 'POST_ONLY', $params);
        $timeInForce = $this->safe_string_upper($params, 'timeInForce');
        $ioc = ($timeInForce === 'IOC');
        if ($postOnly) {
            $orderType = 'POST_ONLY';
        } elseif ($ioc) {
            $orderType = 'IMMEDIATE_OR_CANCEL';
        }
        if ($timeInForce === 'FOK') {
            throw new InvalidOrder($this->id . ' createOrder () does not support $timeInForce FOK, only IOC, PO, and GTC are allowed');
        }
        if ((($orderType !== 'POST_ONLY') && ($orderType !== 'IMMEDIATE_OR_CANCEL') && ($orderType !== 'LIMIT_ORDER'))) {
            throw new InvalidOrder($this->id . ' createOrder () does not support ' . $type . ' order $type, only LIMIT, LIMIT_ORDER, POST_ONLY or IMMEDIATE_OR_CANCEL are allowed');
        }
        $request = array(
            'symbol' => $market['id'],
            'price' => $this->price_to_precision($symbol, $price),
            'quantity' => $this->amount_to_precision($symbol, $amount),
            'trade_type' => $orderSide,
            'order_type' => $orderType, // LIMIT_ORDER，POST_ONLY，IMMEDIATE_OR_CANCEL
        );
        $clientOrderId = $this->safe_string_2($params, 'clientOrderId', 'client_order_id');
        if ($clientOrderId !== null) {
            $request['client_order_id'] = $clientOrderId;
        }
        $params = $this->omit($params, array( 'type', 'clientOrderId', 'client_order_id', 'postOnly', 'timeInForce' ));
        $response = yield $this->spotPrivatePostOrderPlace (array_merge($request, $params));
        //
        //     array("code":200,"data":"2ff3163e8617443cb9c6fc19d42b1ca4")
        //
        return $this->parse_order($response, $market);
    }

    public function create_swap_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $openType = $this->safe_integer($params, 'openType');
        if ($openType === null) {
            throw new ArgumentsRequired($this->id . ' createSwapOrder () requires an integer $openType parameter, 1 for isolated margin, 2 for cross margin');
        }
        if (($type !== 'limit') && ($type !== 'market') && ($type !== 1) && ($type !== 2) && ($type !== 3) && ($type !== 4) && ($type !== 5) && ($type !== 6)) {
            throw new InvalidOrder($this->id . ' createSwapOrder () order $type must either limit, $market, or 1 for limit orders, 2 for post-only orders, 3 for IOC orders, 4 for FOK orders, 5 for $market orders or 6 to convert $market $price to current price');
        }
        $isMarketOrder = ($type === 'market') || ($type === 5);
        $postOnly = $this->is_post_only($isMarketOrder, $type === 2, $params);
        if ($postOnly) {
            $type = 2;
        } elseif ($type === 'limit') {
            $type = 1;
        } elseif ($type === 'market') {
            $type = 5;
        }
        $timeInForce = $this->safe_string_upper($params, 'timeInForce');
        $ioc = ($timeInForce === 'IOC');
        $fok = ($timeInForce === 'FOK');
        if ($ioc) {
            $type = 3;
        } elseif ($fok) {
            $type = 4;
        }
        if (($side !== 1) && ($side !== 2) && ($side !== 3) && ($side !== 4)) {
            throw new InvalidOrder($this->id . ' createSwapOrder () order $side must be 1 open long, 2 close short, 3 open short or 4 close long');
        }
        $request = array(
            'symbol' => $market['id'],
            // 'price' => floatval($this->price_to_precision($symbol, $price)),
            'vol' => floatval($this->amount_to_precision($symbol, $amount)),
            // 'leverage' => int, // required for isolated margin
            'side' => $side, // 1 open long, 2 close short, 3 open short, 4 close long
            //
            // supported order types
            //
            //     1 limit
            //     2 post only maker (PO)
            //     3 transact or cancel instantly (IOC)
            //     4 transact completely or cancel completely (FOK)
            //     5 $market orders
            //     6 convert $market $price to current $price
            //
            'type' => $type,
            'openType' => $openType, // 1 isolated, 2 cross
            // 'positionId' => 1394650, // long, filling in this parameter when closing a position is recommended
            // 'externalOid' => $clientOrderId,
            // 'triggerPrice' => 10.0, // Required for trigger order
            // 'triggerType' => 1, // Required for trigger order 1 => more than or equal, 2 => less than or equal
            // 'executeCycle' => 1, // Required for trigger order 1 => 24 hours,2 => 7 days
            // 'trend' => 1, // Required for trigger order 1 => latest $price, 2 => fair $price, 3 => index $price
            // 'orderType' => 1, // Required for trigger order 1 => limit order,2:Post Only Maker,3 => close or cancel instantly ,4 => close or cancel completely,5 => Market order
        );
        $method = 'contractPrivatePostOrderSubmit';
        $stopPrice = $this->safe_number_2($params, 'triggerPrice', 'stopPrice');
        $params = $this->omit($params, array( 'stopPrice', 'triggerPrice', 'timeInForce', 'postOnly' ));
        if ($stopPrice !== null) {
            $method = 'contractPrivatePostPlanorderPlace';
            $request['triggerPrice'] = $this->price_to_precision($symbol, $stopPrice);
            $request['triggerType'] = $this->safe_integer($params, 'triggerType', 1);
            $request['executeCycle'] = $this->safe_integer($params, 'executeCycle', 1);
            $request['trend'] = $this->safe_integer($params, 'trend', 1);
            $request['orderType'] = $this->safe_integer($params, 'orderType', $type);
        }
        if (($type !== 5) && ($type !== 6) && ($type !== 'market')) {
            $request['price'] = floatval($this->price_to_precision($symbol, $price));
        }
        if ($openType === 1) {
            $leverage = $this->safe_integer($params, 'leverage');
            if ($leverage === null) {
                throw new ArgumentsRequired($this->id . ' createSwapOrder () requires a $leverage parameter for isolated margin orders');
            }
        }
        $clientOrderId = $this->safe_string_2($params, 'clientOrderId', 'externalOid');
        if ($clientOrderId !== null) {
            $request['externalOid'] = $clientOrderId;
        }
        $params = $this->omit($params, array( 'clientOrderId', 'externalOid' ));
        $response = yield $this->$method (array_merge($request, $params));
        //
        // Swap
        //     array("code":200,"data":"2ff3163e8617443cb9c6fc19d42b1ca4")
        //
        // Trigger
        //     array("success":true,"code":0,"data":259208506303929856)
        //
        return $this->parse_order($response, $market);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $options = $this->safe_value($this->options, 'cancelOrder', array());
        $defaultMethod = $this->safe_string($options, 'method', 'spotPrivateDeleteOrderCancel');
        $method = $this->safe_string($params, 'method', $defaultMethod);
        $stop = $this->safe_value($params, 'stop');
        $request = array();
        if ($market['type'] === 'spot') {
            $method = 'spotPrivateDeleteOrderCancel';
            $clientOrderId = $this->safe_string_2($params, 'clientOrderId', 'client_order_ids');
            if ($clientOrderId !== null) {
                $params = $this->omit($params, array( 'clientOrderId', 'client_order_ids' ));
                $request['client_order_ids'] = $clientOrderId;
            } else {
                $request['order_ids'] = $id;
            }
        } elseif ($stop) {
            $method = 'contractPrivatePostPlanorderCancel';
            $request = array();
            if (gettype($id) === 'array' && count(array_filter(array_keys($id), 'is_string')) == 0) {
                for ($i = 0; $i < count($id); $i++) {
                    $request[] = array(
                        'symbol' => $market['id'],
                        'orderId' => $id[$i],
                    );
                }
            } elseif (gettype($id) === 'string') {
                $request[] = array(
                    'symbol' => $market['id'],
                    'orderId' => $id,
                );
            }
        } elseif ($market['type'] === 'swap') {
            $method = 'contractPrivatePostOrderCancel';
            $request = array( $id );
        }
        $response = yield $this->$method ($request); // dont extend with $params, otherwise ARRAY will be turned into OBJECT
        //
        // Spot
        //
        //     array("code":200,"data":array("965245851c444078a11a7d771323613b":"success"))
        //
        // Swap
        //
        //     {
        //         "success" => true,
        //         "code" => 0,
        //         "data" => array(
        //             {
        //                 "orderId" => 268726891790294528,
        //                 "errorCode" => 0,
        //                 "errorMsg" => "success"
        //             }
        //         )
        //     }
        //
        // Trigger
        //
        //     {
        //         "success" => true,
        //         "code" => 0
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        if ($stop) {
            $data = $response;
        }
        return $this->parse_order($data, $market);
    }

    public function parse_order_status($status, $market = null) {
        $statuses = array();
        if ($market['type'] === 'spot') {
            $statuses = array(
                'NEW' => 'open',
                'FILLED' => 'closed',
                'PARTIALLY_FILLED' => 'open',
                'CANCELED' => 'canceled',
                'PARTIALLY_CANCELED' => 'canceled',
            );
        } elseif ($market['type'] === 'swap') {
            $statuses = array(
                '2' => 'open',
                '3' => 'closed',
                '4' => 'canceled',
            );
        } else {
            $statuses = array(
                '1' => 'open',
                '2' => 'canceled',
                '3' => 'closed',
            );
        }
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order($order, $market = null) {
        // TODO update parseOrder to reflect type, $timeInForce, and $postOnly from fetchOrder ()
        //
        // createOrder
        //
        // spot
        //
        //     array("code":200,"data":"2ff3163e8617443cb9c6fc19d42b1ca4")
        //
        // swap / contract
        //
        //     array( "success" => true, "code" => 0, "data" => 102057569836905984 )
        //
        // spot fetchOpenOrders
        //
        //     {
        //         "id":"965245851c444078a11a7d771323613b",
        //         "symbol":"ETH_USDT",
        //         "price":"3430",
        //         "quantity":"0.01",
        //         "state":"NEW",
        //         "type":"BID",
        //         "remain_quantity":"0.01",
        //         "remain_amount":"34.3",
        //         "create_time":1633989029039,
        //         "client_order_id":"",
        //         "order_type":"LIMIT_ORDER"
        //     }
        //
        // swap fetchOpenOrders, fetchClosedOrders, fetchCanceledOrders, fetchOrder
        //
        //     {
        //         "orderId" => "266578267438402048",
        //         "symbol" => "BTC_USDT",
        //         "positionId" => 0,
        //         "price" => 30000,
        //         "vol" => 11,
        //         "leverage" => 20,
        //         "side" => 1,
        //         "category" => 1,
        //         "orderType" => 1,
        //         "dealAvgPrice" => 0,
        //         "dealVol" => 0,
        //         "orderMargin" => 1.6896,
        //         "takerFee" => 0,
        //         "makerFee" => 0,
        //         "profit" => 0,
        //         "feeCurrency" => "USDT",
        //         "openType" => 1,
        //         "state" => 2,
        //         "externalOid" => "_m_8d673a31c47642d9a59993aca61ae394",
        //         "errorCode" => 0,
        //         "usedMargin" => 0,
        //         "createTime" => 1649227612000,
        //         "updateTime" => 1649227611000,
        //         "positionMode" => 1
        //     }
        //
        // spot fetchClosedOrders, fetchCanceledOrders, fetchOrder
        //
        //     {
        //         "id":"d798765285374222990bbd14decb86cd",
        //         "symbol":"USDC_USDT",
        //         "price":"0.9988",
        //         "quantity":"150",
        //         "state":"FILLED", // CANCELED
        //         "type":"ASK", // BID
        //         "deal_quantity":"150",
        //         "deal_amount":"149.955",
        //         "create_time":1633984904000,
        //         "order_type":"MARKET_ORDER" // LIMIT_ORDER
        //     }
        //
        // trigger fetchClosedOrders, fetchCanceledOrders, fetchOpenOrders
        //
        //     {
        //         "id" => "266583973507973632",
        //         "symbol" => "BTC_USDT",
        //         "leverage" => 20,
        //         "side" => 1,
        //         "triggerPrice" => 30000,
        //         "price" => 31000,
        //         "vol" => 11,
        //         "openType" => 1,
        //         "triggerType" => 2,
        //         "state" => 2,
        //         "executeCycle" => 87600,
        //         "trend" => 1,
        //         "orderType" => 1,
        //         "errorCode" => 0,
        //         "createTime" => 1649228972000,
        //         "updateTime" => 1649230287000
        //     }
        //
        // spot cancelOrder
        //
        //     array("965245851c444078a11a7d771323613b":"success")
        //
        // swap cancelOrder
        //
        //     {
        //         "orderId" => 268726891790294528,
        //         "errorCode" => 0,
        //         "errorMsg" => "success"
        //     }
        //
        // trigger cancelOrder
        //
        //     {
        //         "success" => true,
        //         "code" => 0
        //     }
        //
        $id = $this->safe_string_2($order, 'data', 'id');
        $status = null;
        if ($id === null) {
            $keys = is_array($order) ? array_keys($order) : array();
            $id = $this->safe_string($keys, 0);
            $state = $this->safe_string($order, $id);
            if ($state === 'success') {
                $status = 'canceled';
            }
        }
        $state = $this->safe_string($order, 'state');
        $timestamp = $this->safe_integer_2($order, 'create_time', 'createTime');
        $price = $this->safe_string($order, 'price');
        $amount = $this->safe_string_2($order, 'quantity', 'vol');
        $remaining = $this->safe_string($order, 'remain_quantity');
        $filled = $this->safe_string_2($order, 'deal_quantity', 'dealVol');
        $cost = $this->safe_string_2($order, 'deal_amount', 'dealAvgPrice');
        $marketId = $this->safe_string($order, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market, '_');
        $sideCheck = $this->safe_integer($order, 'side');
        $side = null;
        $bidOrAsk = $this->safe_string($order, 'type');
        if ($bidOrAsk === 'BID') {
            $side = 'buy';
        } elseif ($bidOrAsk === 'ASK') {
            $side = 'sell';
        }
        if ($sideCheck === 1) {
            $side = 'open long';
        } elseif ($side === 2) {
            $side = 'close short';
        } elseif ($side === 3) {
            $side = 'open short';
        } elseif ($side === 4) {
            $side = 'close long';
        }
        $status = $this->parse_order_status($state, $market);
        $clientOrderId = $this->safe_string_2($order, 'client_order_id', 'orderId');
        $rawOrderType = $this->safe_string_2($order, 'orderType', 'order_type');
        $orderType = null;
        // swap => 1:$price limited $order, 2:Post Only Maker, 3:transact or cancel instantly, 4:transact completely or cancel completely，5:$market orders, 6:convert $market $price to current $price
        // spot => LIMIT_ORDER, POST_ONLY, IMMEDIATE_OR_CANCEL
        $timeInForce = null;
        $postOnly = null;
        if ($rawOrderType !== null) {
            $postOnly = false;
            if ($rawOrderType === '1') {
                $orderType = 'limit';
                $timeInForce = 'GTC';
            } elseif ($rawOrderType === '2') {
                $orderType = 'limit';
                $timeInForce = 'PO';
                $postOnly = true;
            } elseif ($rawOrderType === '3') {
                $orderType = 'limit';
                $timeInForce = 'IOC';
            } elseif ($rawOrderType === '4') {
                $orderType = 'limit';
                $timeInForce = 'FOK';
            } elseif (($rawOrderType === '5') || ($rawOrderType === '6')) {
                $orderType = 'market';
                $timeInForce = 'GTC';
            } elseif ($rawOrderType === 'LIMIT_ORDER') {
                $orderType = 'limit';
                $timeInForce = 'GTC';
            } elseif ($rawOrderType === 'POST_ONLY') {
                $orderType = 'limit';
                $timeInForce = 'PO';
                $postOnly = true;
            } elseif ($rawOrderType === 'IMMEDIATE_OR_CANCEL') {
                $orderType = 'limit';
                $timeInForce = 'IOC';
            }
        }
        return $this->safe_order(array(
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $this->safe_integer($order, 'updateTime'),
            'status' => $status,
            'symbol' => $symbol,
            'type' => $orderType,
            'timeInForce' => $timeInForce,
            'postOnly' => $postOnly,
            'side' => $side,
            'price' => $price,
            'stopPrice' => $this->safe_string($order, 'triggerPrice'),
            'average' => null,
            'amount' => $amount,
            'cost' => $cost,
            'filled' => $filled,
            'remaining' => $remaining,
            'fee' => null,
            'trades' => null,
            'info' => $order,
        ), $market);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOpenOrders() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'], // spot, swap
            // 'start_time' => $since, // spot
            // 'limit' => $limit, // spot default 50, max 1000
            // 'trade_type' => 'BID', // spot BID / ASK
            // 'page_num' => 1, // swap required default 1
            // 'page_size' => $limit, // swap required default 20 max 100
            // 'end_time' => 1633988662382, // trigger order
        );
        list($marketType, $query) = $this->handle_market_type_and_params('fetchOpenOrders', $market, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'spotPrivateGetOrderOpenOrders',
            'swap' => 'contractPrivateGetOrderListOpenOrdersSymbol',
        ));
        $stop = $this->safe_value($params, 'stop');
        if ($stop) {
            return yield $this->fetch_orders_by_state('1', $symbol, $since, $limit, $params);
        }
        $response = yield $this->$method (array_merge($request, $query));
        //
        // Spot
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             array(
        //                 "id":"965245851c444078a11a7d771323613b",
        //                 "symbol":"ETH_USDT",
        //                 "price":"3430",
        //                 "quantity":"0.01",
        //                 "state":"NEW",
        //                 "type":"BID",
        //                 "remain_quantity":"0.01",
        //                 "remain_amount":"34.3",
        //                 "create_time":1633989029039,
        //                 "client_order_id":"",
        //                 "order_type":"LIMIT_ORDER"
        //             ),
        //         )
        //     }
        //
        // Swap
        //
        //     {
        //         "success" => true,
        //         "code" => 0,
        //         "data" => array(
        //             {
        //                 "orderId" => "266578267438402048",
        //                 "symbol" => "BTC_USDT",
        //                 "positionId" => 0,
        //                 "price" => 30000,
        //                 "vol" => 11,
        //                 "leverage" => 20,
        //                 "side" => 1,
        //                 "category" => 1,
        //                 "orderType" => 1,
        //                 "dealAvgPrice" => 0,
        //                 "dealVol" => 0,
        //                 "orderMargin" => 1.6896,
        //                 "takerFee" => 0,
        //                 "makerFee" => 0,
        //                 "profit" => 0,
        //                 "feeCurrency" => "USDT",
        //                 "openType" => 1,
        //                 "state" => 2,
        //                 "externalOid" => "_m_8d673a31c47642d9a59993aca61ae394",
        //                 "errorCode" => 0,
        //                 "usedMargin" => 0,
        //                 "createTime" => 1649227612000,
        //                 "updateTime" => 1649227611000,
        //                 "positionMode" => 1
        //             }
        //         )
        //     }
        //
        // Trigger
        //
        //     {
        //         "success" => true,
        //         "code" => 0,
        //         "data" => array(
        //             {
        //                 "id" => "267198217203040768",
        //                 "symbol" => "BTC_USDT",
        //                 "leverage" => 20,
        //                 "side" => 1,
        //                 "triggerPrice" => 31111,
        //                 "price" => 31115,
        //                 "vol" => 2,
        //                 "openType" => 1,
        //                 "triggerType" => 2,
        //                 "state" => 1,
        //                 "executeCycle" => 87600,
        //                 "trend" => 1,
        //                 "orderType" => 1,
        //                 "errorCode" => 0,
        //                 "createTime" => 1649375419000,
        //                 "updateTime" => 1649375419000
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_orders($data, $market, $since, $limit);
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrder() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        list($marketType, $query) = $this->handle_market_type_and_params('fetchOrder', $market, $params);
        $request = array(
            'order_ids' => $id,
        );
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'spotPrivateGetOrderQuery',
            'swap' => 'contractPrivateGetOrderBatchQuery',
        ));
        $response = yield $this->$method (array_merge($request, $query));
        //
        // Spot
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             {
        //                 "id":"2ff3163e8617443cb9c6fc19d42b1ca4",
        //                 "symbol":"ETH_USDT",
        //                 "price":"3420",
        //                 "quantity":"0.01",
        //                 "state":"CANCELED",
        //                 "type":"BID",
        //                 "deal_quantity":"0",
        //                 "deal_amount":"0",
        //                 "create_time":1633988662000,
        //                 "order_type":"LIMIT_ORDER"
        //             }
        //         )
        //     }
        //
        // Swap
        //
        //     {
        //         "success" => true,
        //         "code" => 0,
        //         "data" => array(
        //             {
        //                 "orderId" => "259208506647860224",
        //                 "symbol" => "BTC_USDT",
        //                 "positionId" => 0,
        //                 "price" => 30000,
        //                 "vol" => 10,
        //                 "leverage" => 20,
        //                 "side" => 1,
        //                 "category" => 1,
        //                 "orderType" => 1,
        //                 "dealAvgPrice" => 0,
        //                 "dealVol" => 0,
        //                 "orderMargin" => 1.536,
        //                 "takerFee" => 0,
        //                 "makerFee" => 0,
        //                 "profit" => 0,
        //                 "feeCurrency" => "USDT",
        //                 "openType" => 1,
        //                 "state" => 4,
        //                 "externalOid" => "planorder_279208506303929856_10",
        //                 "errorCode" => 0,
        //                 "usedMargin" => 0,
        //                 "createTime" => 1647470524000,
        //                 "updateTime" => 1647470540000,
        //                 "positionMode" => 1
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $firstOrder = $this->safe_value($data, 0);
        if ($firstOrder === null) {
            throw new OrderNotFound($this->id . ' fetchOrder() could not find the order $id ' . $id);
        }
        return $this->parse_order($firstOrder, $market);
    }

    public function fetch_orders_by_state($state, $symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrdersByState() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            // 'start_time' => $since, // default 7 days, max 30 days
            // 'limit' => $limit, // default 50, max 1000
            // 'trade_type' => 'BID', // BID / ASK
            'states' => $state, // NEW, FILLED, PARTIALLY_FILLED, CANCELED, PARTIALLY_CANCELED, trigger orders => 1 untriggered, 2 cancelled, 3 executed, 4 invalid, 5 execution failed
            // 'end_time' => 1633988662000, // trigger orders
            // 'page_num' => 1, // trigger orders default is 1
            // 'page_size' => $limit, // trigger orders default 20 max 100
        );
        $stop = $this->safe_value($params, 'stop');
        $limitRequest = $stop ? 'page_size' : 'limit';
        if ($limit !== null) {
            $request[$limitRequest] = $limit;
        }
        if ($since !== null) {
            $request['start_time'] = $since;
        }
        $options = $this->safe_value($this->options, 'fetchOrdersByState', array());
        $defaultMethod = $this->safe_string($options, 'method', 'spotPrivateGetOrderList');
        $method = $this->safe_string($params, 'method', $defaultMethod);
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'spotPrivateGetOrderList',
            'swap' => 'contractPrivateGetOrderListHistoryOrders',
        ));
        if ($stop) {
            $method = 'contractPrivateGetPlanorderListOrders';
        }
        $query = $this->omit($params, array( 'method', 'stop' ));
        $response = yield $this->$method (array_merge($request, $query));
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_orders($data, $market, $since, $limit);
    }

    public function fetch_canceled_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchCanceledOrders() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $stop = $this->safe_value($params, 'stop');
        $state = 'CANCELED';
        if ($market['type'] === 'swap') {
            $state = '4';
        } elseif ($stop) {
            $state = '2';
        }
        return yield $this->fetch_orders_by_state($state, $symbol, $since, $limit, $params);
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchClosedOrders() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $stop = $this->safe_value($params, 'stop');
        $state = 'FILLED';
        if ($stop || $market['type'] === 'swap') {
            $state = '3';
        }
        return yield $this->fetch_orders_by_state($state, $symbol, $since, $limit, $params);
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'spotPrivateDeleteOrderCancelBySymbol',
            'swap' => 'contractPrivatePostOrderCancelAll',
        ));
        $stop = $this->safe_value($params, 'stop');
        if ($stop) {
            $method = 'contractPrivatePostPlanorderCancelAll';
        }
        $query = $this->omit($params, array( 'method', 'stop' ));
        $response = yield $this->$method (array_merge($request, $query));
        //
        // Spot
        //
        //     {
        //         "code" => 200,
        //         "data" => array(
        //             array(
        //                 "msg" => "success",
        //                 "order_id" => "75ecf99feef04538b78e4622beaba6eb",
        //                 "client_order_id" => "a9329e86f2094b0d8b58e92c25029554"
        //             ),
        //             array(
        //                 "msg" => "success",
        //                 "order_id" => "139413c48f8b4c018f452ce796586bcf"
        //             ),
        //             {
        //                 "msg" => "success",
        //                 "order_id" => "b58ef34c570e4917981f276d44091484"
        //             }
        //         )
        //     }
        //
        // Swap and Trigger
        //
        //     {
        //         "success" => true,
        //         "code" => 0
        //     }
        //
        return $response;
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchMyTrades() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            // 'start_time' => $since, // default 7 days, max 30 days
            // 'limit' => $limit, // default 50, max 1000
        );
        if ($since !== null) {
            $request['start_time'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = yield $this->spotPrivateGetOrderDeals (array_merge($request, $params));
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             {
        //                 "id":"b160b8f072d9403e96289139d5544809",
        //                 "symbol":"USDC_USDT",
        //                 "quantity":"150",
        //                 "price":"0.9997",
        //                 "amount":"149.955",
        //                 "fee":"0.29991",
        //                 "trade_type":"ASK",
        //                 "order_id":"d798765285374222990bbd14decb86cd",
        //                 "is_taker":true,
        //                 "fee_currency":"USDT",
        //                 "create_time":1633984904000
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_trades($data, $market, $since, $limit);
    }

    public function fetch_order_trades($id, $symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
        }
        $request = array(
            'order_id' => $id,
        );
        $response = yield $this->spotPrivateGetOrderDealDetail (array_merge($request, $params));
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             {
        //                 "id":"b160b8f072d9403e96289139d5544809",
        //                 "symbol":"USDC_USDT",
        //                 "quantity":"150",
        //                 "price":"0.9997",
        //                 "amount":"149.955",
        //                 "fee":"0.29991",
        //                 "trade_type":"ASK",
        //                 "order_id":"d798765285374222990bbd14decb86cd",
        //                 "is_taker":true,
        //                 "fee_currency":"USDT",
        //                 "create_time":1633984904000
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_trades($data, $market, $since, $limit);
    }

    public function modify_margin_helper($symbol, $amount, $addOrReduce, $params = array ()) {
        $positionId = $this->safe_integer($params, 'positionId');
        if ($positionId === null) {
            throw new ArgumentsRequired($this->id . ' modifyMarginHelper() requires a $positionId parameter');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $amount = $this->amount_to_precision($symbol, $amount);
        $request = array(
            'positionId' => $positionId,
            'amount' => $amount,
            'type' => $addOrReduce,
        );
        $response = yield $this->contractPrivatePostPositionChangeMargin (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "code" => 0
        //     }
        //
        $type = ($addOrReduce === 'ADD') ? 'add' : 'reduce';
        return array_merge($this->parse_margin_modification($response, $market), array(
            'amount' => $this->safe_number($amount),
            'type' => $type,
        ));
    }

    public function parse_margin_modification($data, $market = null) {
        $statusRaw = $this->safe_string($data, 'success');
        $status = ($statusRaw === true) ? 'ok' : 'failed';
        return array(
            'info' => $data,
            'type' => null,
            'amount' => null,
            'code' => null,
            'symbol' => $this->safe_symbol(null, $market),
            'status' => $status,
        );
    }

    public function reduce_margin($symbol, $amount, $params = array ()) {
        return yield $this->modify_margin_helper($symbol, $amount, 'SUB', $params);
    }

    public function add_margin($symbol, $amount, $params = array ()) {
        return yield $this->modify_margin_helper($symbol, $amount, 'ADD', $params);
    }

    public function set_leverage($leverage, $symbol = null, $params = array ()) {
        yield $this->load_markets();
        $request = array(
            'leverage' => $leverage,
        );
        $positionId = $this->safe_integer($params, 'positionId');
        if ($positionId === null) {
            $openType = $this->safe_number($params, 'openType'); // 1 or 2
            $positionType = $this->safe_number($params, 'positionType'); // 1 or 2
            $market = ($symbol !== null) ? $this->market($symbol) : null;
            if (($openType === null) || ($positionType === null) || ($market === null)) {
                throw new ArgumentsRequired($this->id . ' setLeverage() requires a $positionId parameter or a $symbol argument with $openType and $positionType parameters, use $openType 1 or 2 for isolated or cross margin respectively, use $positionType 1 or 2 for long or short positions');
            } else {
                $request['openType'] = $openType;
                $request['symbol'] = $market['id'];
                $request['positionType'] = $positionType;
            }
        } else {
            $request['positionId'] = $positionId;
        }
        return yield $this->contractPrivatePostPositionChangeLeverage (array_merge($request, $params));
    }

    public function fetch_transfer($id, $code = null, $params = array ()) {
        $request = array(
            'transact_id' => $id,
        );
        $response = yield $this->spotPrivateGetAssetInternalTransferInfo (array_merge($request, $params));
        //
        //     {
        //         $code => '200',
        //         $data => {
        //             currency => 'USDT',
        //             amount => '1',
        //             transact_id => '954877a2ef54499db9b28a7cf9ebcf41',
        //             from => 'MAIN',
        //             to => 'CONTRACT',
        //             transact_state => 'SUCCESS'
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_transfer($data);
    }

    public function fetch_transfers($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array();
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'];
        }
        if ($since !== null) {
            $request['start_time'] = $since;
        }
        if ($limit !== null) {
            if ($limit > 50) {
                throw new ExchangeError('This exchange supports a maximum $limit of 50');
            }
            $request['page-size'] = $limit;
        }
        $response = yield $this->spotPrivateGetAssetInternalTransferRecord (array_merge($request, $params));
        //
        //     {
        //         $code => '200',
        //         $data => {
        //             total_page => '1',
        //             total_size => '5',
        //             result_list => [array(
        //                     $currency => 'USDT',
        //                     amount => '1',
        //                     transact_id => '954877a2ef54499db9b28a7cf9ebcf41',
        //                     from => 'MAIN',
        //                     to => 'CONTRACT',
        //                     transact_state => 'SUCCESS'
        //                 ),
        //                 ...
        //             ]
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $resultList = $this->safe_value($data, 'result_list', array());
        return $this->parse_transfers($resultList, $currency, $since, $limit);
    }

    public function transfer($code, $amount, $fromAccount, $toAccount, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $accountsByType = $this->safe_value($this->options, 'accountsByType', array());
        $fromId = $this->safe_string($accountsByType, $fromAccount, $fromAccount);
        $toId = $this->safe_string($accountsByType, $toAccount, $toAccount);
        $request = array(
            'currency' => $currency['id'],
            'amount' => $amount,
            'from' => $fromId,
            'to' => $toId,
        );
        $response = yield $this->spotPrivatePostAssetInternalTransfer (array_merge($request, $params));
        //
        //     {
        //         $code => '200',
        //         $data => {
        //             $currency => 'USDT',
        //             $amount => '1',
        //             transact_id => 'b60c1df8e7b24b268858003f374ecb75',
        //             from => 'MAIN',
        //             to => 'CONTRACT',
        //             transact_state => 'WAIT'
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_transfer($data, $currency);
    }

    public function parse_transfer($transfer, $currency = null) {
        //
        //     {
        //         $currency => 'USDT',
        //         amount => '1',
        //         transact_id => 'b60c1df8e7b24b268858003f374ecb75',
        //         from => 'MAIN',
        //         to => 'CONTRACT',
        //         transact_state => 'WAIT'
        //     }
        //
        $transferOptions = $this->safe_value($this->options, 'transfer', array());
        $transferStatusById = $this->safe_value($transferOptions, 'status', array());
        $currencyId = $this->safe_string($transfer, 'currency');
        $id = $this->safe_string($transfer, 'transact_id');
        $fromId = $this->safe_string($transfer, 'from');
        $toId = $this->safe_string($transfer, 'to');
        $accountsById = $this->safe_value($transferOptions, 'accountsById', array());
        $fromAccount = $this->safe_string($accountsById, $fromId);
        $toAccount = $this->safe_string($accountsById, $toId);
        $statusId = $this->safe_string($transfer, 'transact_state');
        return array(
            'info' => $transfer,
            'id' => $id,
            'timestamp' => null,
            'datetime' => null,
            'currency' => $this->safe_currency_code($currencyId, $currency),
            'amount' => $this->safe_number($transfer, 'amount'),
            'fromAccount' => $fromAccount,
            'toAccount' => $toAccount,
            'status' => $this->safe_string($transferStatusById, $statusId),
        );
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
        $networks = $this->safe_value($this->options, 'networks', array());
        $network = $this->safe_string_2($params, 'network', 'chain'); // this line allows the user to specify either ERC20 or ETH
        $network = $this->safe_string($networks, $network, $network); // handle ETH > ERC-20 alias
        $this->check_address($address);
        yield $this->load_markets();
        $currency = $this->currency($code);
        if ($tag !== null) {
            $address .= ':' . $tag;
        }
        $request = array(
            'currency' => $currency['id'],
            'address' => $address,
            'amount' => $amount,
        );
        if ($network !== null) {
            $request['chain'] = $network;
            $params = $this->omit($params, array( 'network', 'chain' ));
        }
        $response = yield $this->spotPrivatePostAssetWithdraw (array_merge($request, $params));
        //
        //     {
        //         "code":200,
        //         "data" => {
        //             "withdrawId":"25fb2831fb6d4fc7aa4094612a26c81d"
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return array(
            'info' => $data,
            'id' => $this->safe_string($data, 'withdrawId'),
        );
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        list($section, $access) = $api;
        $url = $this->urls['api'][$section][$access] . '/' . $this->implode_params($path, $params);
        $params = $this->omit($params, $this->extract_params($path));
        if ($access === 'public') {
            if ($params) {
                $url .= '?' . $this->urlencode($params);
            }
        } else {
            $this->check_required_credentials();
            $timestamp = (string) $this->milliseconds();
            $auth = '';
            $headers = array(
                'ApiKey' => $this->apiKey,
                'Request-Time' => $timestamp,
                'Content-Type' => 'application/json',
            );
            if ($method === 'POST') {
                $auth = $this->json($params);
                $body = $auth;
            } else {
                $params = $this->keysort($params);
                if ($params) {
                    $auth .= $this->urlencode($params);
                    $url .= '?' . $auth;
                }
            }
            $auth = $this->apiKey . $timestamp . $auth;
            $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256');
            $headers['Signature'] = $signature;
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return;
        }
        //     array("code":10232,"msg":"The currency not exist")
        //     array("code":10216,"msg":"No available deposit address")
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":1634095541710
        //     }
        //
        $success = $this->safe_value($response, 'success', false);
        if ($success === true) {
            return;
        }
        $responseCode = $this->safe_string($response, 'code');
        if (($responseCode !== '200') && ($responseCode !== '0')) {
            $feedback = $this->id . ' ' . $body;
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $body, $feedback);
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $responseCode, $feedback);
            throw new ExchangeError($feedback);
        }
    }

    public function fetch_funding_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = null;
        $request = array(
            // 'symbol' => $market['id'],
            // 'position_id' => positionId,
            // 'page_num' => 1,
            // 'page_size' => $limit, // default 20, max 100
        );
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($limit !== null) {
            $request['page_size'] = $limit;
        }
        $response = yield $this->contractPrivateGetPositionFundingRecords (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "code" => 0,
        //         "data" => {
        //             "pageSize" => 20,
        //             "totalCount" => 2,
        //             "totalPage" => 1,
        //             "currentPage" => 1,
        //             "resultList" => array(
        //                 array(
        //                     "id" => 7423910,
        //                     "symbol" => "BTC_USDT",
        //                     "positionType" => 1,
        //                     "positionValue" => 29.30024,
        //                     "funding" => 0.00076180624,
        //                     "rate" => -0.000026,
        //                     "settleTime" => 1643299200000
        //                 ),
        //                 {
        //                     "id" => 7416473,
        //                     "symbol" => "BTC_USDT",
        //                     "positionType" => 1,
        //                     "positionValue" => 28.9188,
        //                     "funding" => 0.0014748588,
        //                     "rate" => -0.000051,
        //                     "settleTime" => 1643270400000
        //                 }
        //             )
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $resultList = $this->safe_value($data, 'resultList', array());
        $result = array();
        for ($i = 0; $i < count($resultList); $i++) {
            $entry = $resultList[$i];
            $timestamp = $this->safe_string($entry, 'settleTime');
            $result[] = array(
                'info' => $entry,
                'symbol' => $symbol,
                'code' => null,
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
                'id' => $this->safe_number($entry, 'id'),
                'amount' => $this->safe_number($entry, 'funding'),
            );
        }
        return $result;
    }

    public function parse_funding_rate($fundingRate, $market = null) {
        //
        //     {
        //         "symbol" => "BTC_USDT",
        //         "fundingRate" => 0.000014,
        //         "maxFundingRate" => 0.003,
        //         "minFundingRate" => -0.003,
        //         "collectCycle" => 8,
        //         "nextSettleTime" => 1643241600000,
        //         "timestamp" => 1643240373359
        //     }
        //
        $nextFundingRate = $this->safe_number($fundingRate, 'fundingRate');
        $nextFundingTimestamp = $this->safe_integer($fundingRate, 'nextSettleTime');
        $marketId = $this->safe_string($fundingRate, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market);
        $timestamp = $this->safe_integer($fundingRate, 'timestamp');
        $datetime = $this->iso8601($timestamp);
        return array(
            'info' => $fundingRate,
            'symbol' => $symbol,
            'markPrice' => null,
            'indexPrice' => null,
            'interestRate' => null,
            'estimatedSettlePrice' => null,
            'timestamp' => $timestamp,
            'datetime' => $datetime,
            'fundingRate' => null,
            'fundingTimestamp' => null,
            'fundingDatetime' => null,
            'nextFundingRate' => $nextFundingRate,
            'nextFundingTimestamp' => $nextFundingTimestamp,
            'nextFundingDatetime' => $this->iso8601($nextFundingTimestamp),
            'previousFundingRate' => null,
            'previousFundingTimestamp' => null,
            'previousFundingDatetime' => null,
        );
    }

    public function fetch_funding_rate($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = yield $this->contractPublicGetFundingRateSymbol (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "code" => 0,
        //         "data" => {
        //             "symbol" => "BTC_USDT",
        //             "fundingRate" => 0.000014,
        //             "maxFundingRate" => 0.003,
        //             "minFundingRate" => -0.003,
        //             "collectCycle" => 8,
        //             "nextSettleTime" => 1643241600000,
        //             "timestamp" => 1643240373359
        //         }
        //     }
        //
        $result = $this->safe_value($response, 'data', array());
        return $this->parse_funding_rate($result, $market);
    }

    public function fetch_funding_rate_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        /**
         * fetches historical funding rate prices
         * @param {str|null} $symbol unified $symbol of the $market to fetch the funding rate history for
         * @param {int|null} $since not used by mexc, but filtered internally by ccxt
         * @param {int|null} $limit mexc $limit is page_size default 20, maximum is 100
         * @param {dict} $params extra parameters specific to the mexc api endpoint
         * @return {[dict]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure funding rate structures~
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchFundingRateHistory() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            // 'page_size' => $limit, // optional
            // 'page_num' => 1, // optional, current page number, default is 1
        );
        if ($limit !== null) {
            $request['page_size'] = $limit;
        }
        $response = yield $this->contractPublicGetFundingRateHistory (array_merge($request, $params));
        //
        //    {
        //        "success" => true,
        //        "code" => 0,
        //        "data" => {
        //            "pageSize" => 2,
        //            "totalCount" => 21,
        //            "totalPage" => 11,
        //            "currentPage" => 1,
        //            "resultList" => array(
        //                array(
        //                    "symbol" => "BTC_USDT",
        //                    "fundingRate" => 0.000266,
        //                    "settleTime" => 1609804800000
        //                ),
        //                {
        //                    "symbol" => "BTC_USDT",
        //                    "fundingRate" => 0.00029,
        //                    "settleTime" => 1609776000000
        //                }
        //            )
        //        }
        //    }
        //
        $data = $this->safe_value($response, 'data');
        $result = $this->safe_value($data, 'resultList', array());
        $rates = array();
        for ($i = 0; $i < count($result); $i++) {
            $entry = $result[$i];
            $marketId = $this->safe_string($entry, 'symbol');
            $symbol = $this->safe_symbol($marketId);
            $timestamp = $this->safe_string($entry, 'settleTime');
            $rates[] = array(
                'info' => $entry,
                'symbol' => $symbol,
                'fundingRate' => $this->safe_number($entry, 'fundingRate'),
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
            );
        }
        $sorted = $this->sort_by($rates, 'timestamp');
        return $this->filter_by_symbol_since_limit($sorted, $market['symbol'], $since, $limit);
    }

    public function fetch_leverage_tiers($symbols = null, $params = array ()) {
        yield $this->load_markets();
        $response = yield $this->contractPublicGetDetail ($params);
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":[
        //             array(
        //                 "symbol" => "BTC_USDT",
        //                 "displayName" => "BTC_USDT永续",
        //                 "displayNameEn" => "BTC_USDT SWAP",
        //                 "positionOpenType" => 3,
        //                 "baseCoin" => "BTC",
        //                 "quoteCoin" => "USDT",
        //                 "settleCoin" => "USDT",
        //                 "contractSize" => 0.0001,
        //                 "minLeverage" => 1,
        //                 "maxLeverage" => 125,
        //                 "priceScale" => 2,
        //                 "volScale" => 0,
        //                 "amountScale" => 4,
        //                 "priceUnit" => 0.5,
        //                 "volUnit" => 1,
        //                 "minVol" => 1,
        //                 "maxVol" => 1000000,
        //                 "bidLimitPriceRate" => 0.1,
        //                 "askLimitPriceRate" => 0.1,
        //                 "takerFeeRate" => 0.0006,
        //                 "makerFeeRate" => 0.0002,
        //                 "maintenanceMarginRate" => 0.004,
        //                 "initialMarginRate" => 0.008,
        //                 "riskBaseVol" => 10000,
        //                 "riskIncrVol" => 200000,
        //                 "riskIncrMmr" => 0.004,
        //                 "riskIncrImr" => 0.004,
        //                 "riskLevelLimit" => 5,
        //                 "priceCoefficientVariation" => 0.1,
        //                 "indexOrigin" => ["BINANCE","GATEIO","HUOBI","MXC"],
        //                 "state" => 0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
        //                 "isNew" => false,
        //                 "isHot" => true,
        //                 "isHidden" => false
        //             ),
        //             ...
        //         ]
        //     }
        //
        $data = $this->safe_value($response, 'data');
        return $this->parse_leverage_tiers($data, $symbols, 'symbol');
    }

    public function parse_market_leverage_tiers($info, $market) {
        /**
         * @ignore
         * @param {dict} $info Exchange response for 1 $market
         * @param {dict} $market CCXT $market
         */
        //
        //    {
        //        "symbol" => "BTC_USDT",
        //        "displayName" => "BTC_USDT永续",
        //        "displayNameEn" => "BTC_USDT SWAP",
        //        "positionOpenType" => 3,
        //        "baseCoin" => "BTC",
        //        "quoteCoin" => "USDT",
        //        "settleCoin" => "USDT",
        //        "contractSize" => 0.0001,
        //        "minLeverage" => 1,
        //        "maxLeverage" => 125,
        //        "priceScale" => 2,
        //        "volScale" => 0,
        //        "amountScale" => 4,
        //        "priceUnit" => 0.5,
        //        "volUnit" => 1,
        //        "minVol" => 1,
        //        "maxVol" => 1000000,
        //        "bidLimitPriceRate" => 0.1,
        //        "askLimitPriceRate" => 0.1,
        //        "takerFeeRate" => 0.0006,
        //        "makerFeeRate" => 0.0002,
        //        "maintenanceMarginRate" => 0.004,
        //        "initialMarginRate" => 0.008,
        //        "riskBaseVol" => 10000,
        //        "riskIncrVol" => 200000,
        //        "riskIncrMmr" => 0.004,
        //        "riskIncrImr" => 0.004,
        //        "riskLevelLimit" => 5,
        //        "priceCoefficientVariation" => 0.1,
        //        "indexOrigin" => ["BINANCE","GATEIO","HUOBI","MXC"],
        //        "state" => 0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
        //        "isNew" => false,
        //        "isHot" => true,
        //        "isHidden" => false
        //    }
        //
        $maintenanceMarginRate = $this->safe_string($info, 'maintenanceMarginRate');
        $initialMarginRate = $this->safe_string($info, 'initialMarginRate');
        $maxVol = $this->safe_string($info, 'maxVol');
        $riskIncrVol = $this->safe_string($info, 'riskIncrVol');
        $riskIncrMmr = $this->safe_string($info, 'riskIncrMmr');
        $riskIncrImr = $this->safe_string($info, 'riskIncrImr');
        $floor = '0';
        $tiers = array();
        $quoteId = $this->safe_string($info, 'quoteCoin');
        while (Precise::string_lt($floor, $maxVol)) {
            $cap = Precise::string_add($floor, $riskIncrVol);
            $tiers[] = array(
                'tier' => $this->parse_number(Precise::string_div($cap, $riskIncrVol)),
                'currency' => $this->safe_currency_code($quoteId),
                'minNotional' => $this->parse_number($floor),
                'maxNotional' => $this->parse_number($cap),
                'maintenanceMarginRate' => $this->parse_number($maintenanceMarginRate),
                'maxLeverage' => $this->parse_number(Precise::string_div('1', $initialMarginRate)),
                'info' => $info,
            );
            $initialMarginRate = Precise::string_add($initialMarginRate, $riskIncrImr);
            $maintenanceMarginRate = Precise::string_add($maintenanceMarginRate, $riskIncrMmr);
            $floor = $cap;
        }
        return $tiers;
    }
}
