<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ArgumentsRequired;
use \ccxt\InvalidOrder;
use \ccxt\Precise;

class woo extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'woo',
            'name' => 'WOO X',
            'countries' => array( 'KY' ), // Cayman Islands
            'rateLimit' => 100,
            'version' => 'v1',
            'certified' => false,
            'hostname' => 'woo.org',
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => true,
                'swap' => false,
                'future' => false,
                'option' => false,
                'addMargin' => false,
                'cancelAllOrders' => false,
                'cancelOrder' => true,
                'cancelOrders' => true,
                'cancelWithdraw' => false, // exchange have that endpoint disabled atm, but was once implemented in ccxt per old docs => https://kronosresearch.github.io/wootrade-documents/#cancel-withdraw-request
                'createDepositAddress' => false,
                'createMarketOrder' => false,
                'createOrder' => true,
                'createStopLimitOrder' => false,
                'createStopMarketOrder' => false,
                'createStopOrder' => false,
                'fetchAccounts' => true,
                'fetchBalance' => true,
                'fetchCanceledOrders' => false,
                'fetchClosedOrder' => false,
                'fetchClosedOrders' => false,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => false,
                'fetchDeposits' => true,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchLedger' => true,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrder' => false,
                'fetchOpenOrders' => false,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchOrderTrades' => true,
                'fetchPremiumIndexOHLCV' => false,
                'fetchStatus' => false,
                'fetchTicker' => false,
                'fetchTickers' => false,
                'fetchTime' => false,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => true,
                'fetchTransactions' => true,
                'fetchTransfers' => true,
                'fetchWithdrawals' => true,
                'reduceMargin' => false,
                'setMargin' => false,
                'transfer' => true,
                'withdraw' => false, // exchange have that endpoint disabled atm, but was once implemented in ccxt per old docs => https://kronosresearch.github.io/wootrade-documents/#token-withdraw
            ),
            'timeframes' => array(
                '1m' => '1m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '4h' => '4h',
                '12h' => '12h',
                '1d' => '1d',
                '1w' => '1w',
                '1M' => '1mon',
                '1y' => '1y',
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/150730761-1a00e5e0-d28c-480f-9e65-089ce3e6ef3b.jpg',
                'api' => array(
                    'public' => 'https://api.{hostname}',
                    'private' => 'https://api.{hostname}',
                ),
                // TEST (stating) api ( https://support.woo.org/hc/en-001/articles/4406352945305--Institutional-Account-Welcome-Packet-V-2) doesn't work at this moment, even thou
                // 'test' => array(
                //     'public' => 'http://api.staging.woo.org',
                //     'private' => 'http://api.staging.woo.org',
                // ),
                'www' => 'https://woo.org/',
                'doc' => array(
                    'https://docs.woo.org/',
                ),
                'fees' => array(
                    'https://support.woo.org/hc/en-001/articles/4404611795353--Trading-Fees',
                ),
                'referral' => 'https://referral.woo.org/BAJS6oNmZb3vi3RGA',
            ),
            'api' => array(
                'v1' => array(
                    'public' => array(
                        'get' => array(
                            'info' => 1,
                            'info/{symbol}' => 1,
                            'market_trades' => 1,
                            'token' => 1,
                            'token_network' => 1,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            'client/token' => 1,
                            'order/{oid}' => 1,
                            'client/order/{client_order_id}' => 1,
                            'orders' => 1,
                            'orderbook/{symbol}' => 1,
                            'kline' => 1,
                            'client/trade/{tid}' => 1,
                            'order/{oid}/trades' => 1,
                            'client/trades' => 1,
                            'client/info' => 60,
                            'asset/deposit' => 120,
                            'asset/history' => 60,
                            'sub_account/all' => 60,
                            'sub_account/assets' => 60,
                            'token_interest' => 60,
                            'token_interest/{token}' => 60,
                            'interest/history' => 60,
                            'interest/repay' => 60,
                        ),
                        'post' => array(
                            'order' => 5, // 2 requests per 1 second per symbol
                            'asset/main_sub_transfer' => 30, // 20 requests per 60 seconds
                            'asset/withdraw' => 120,  // implemented in ccxt, disabled on the exchange side https://kronosresearch.github.io/wootrade-documents/#token-withdraw
                        ),
                        'delete' => array(
                            'order' => 1,
                            'client/order' => 1,
                            'orders' => 1,
                            'asset/withdraw' => 120,  // implemented in ccxt, disabled on the exchange side https://kronosresearch.github.io/wootrade-documents/#cancel-withdraw-request
                        ),
                    ),
                ),
                'v2' => array(
                    'private' => array(
                        'get' => array(
                            'client/holding' => 1,
                        ),
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => true,
                    'percentage' => true,
                    'maker' => $this->parse_number('0.0002'),
                    'taker' => $this->parse_number('0.0005'),
                ),
            ),
            'options' => array(
                'createMarketBuyOrderRequiresPrice' => true,
                'network-aliases' => array(
                    'ALGO' => 'ALGO',
                    'ATOM' => 'ATOM',
                    'AVAXC' => 'AVAXC',
                    'BNB' => 'BEP2',
                    'BSC' => 'BEP20',
                    'BTC' => 'BTC',
                    'BCHSV' => 'BSV',
                    'EOS' => 'EOS',
                    'ETH' => 'ERC20',
                    'HECO' => 'HRC20',
                    'MATIC' => 'POLYGON',
                    'ONT' => 'ONT',
                    'SOL' => 'SPL',
                    'TERRA' => 'TERRA',
                    'TRON' => 'TRC20',
                ),
                // network-aliases for titles are removed (is_array(case, if needed => pastebin.com/raw/BvgKViPN ) && array_key_exists(just, case, if needed => pastebin.com/raw/BvgKViPN ))
                'network-aliases-for-protocol' => array(
                    'ALGO' => 'ALGO',
                    'ATOM' => 'ATOM',
                    'C Chain' => 'AVAXC',
                    'BEP2' => 'BEP2',
                    'BEP20' => 'BEP20',
                    'BTC' => 'BTC',
                    'BSV' => 'BSV',
                    'EOS' => 'EOS',
                    'ERC20' => 'ERC20',
                    'HECO' => 'HRC20',
                    'Polygon' => 'POLYGON',
                    'ONT' => 'ONT',
                    'SOL' => 'SPL',
                    'TERRA' => 'TERRA',
                    'TRON' => 'TRC20',
                ),
                // these network aliases require manual mapping here
                'network-aliases-for-tokens' => array(
                    'HT' => 'ERC20',
                    'OMG' => 'ERC20',
                    'UATOM' => 'ATOM',
                    'ZRX' => 'ZRX',
                ),
                'defaultNetworkCodePriorities' => array(
                    'TRC20',
                    'ERC20',
                    'BSC20',
                ),
                // override defaultNetworkCodePriorities for a specific currency
                'defaultNetworkCodeForCurrencies' => array(
                    // 'USDT' => 'TRC20',
                    // 'BTC' => 'BTC',
                ),
                'transfer' => array(
                    'fillResponseFromRequest' => true,
                ),
            ),
            'commonCurrencies' => array(),
            'exceptions' => array(
                'exact' => array(
                    '-1000' => '\\ccxt\\ExchangeError', // array( "code" => -1000,  "message" => "An unknown error occurred while processing the request" )
                    '-1001' => '\\ccxt\\AuthenticationError', // array( "code" => -1001,  "message" => "The api key or secret is in wrong format" )
                    '-1002' => '\\ccxt\\AuthenticationError', // array( "code" => -1002,  "message" => "API key or secret is invalid, it may because key have insufficient permission or the key is expired/revoked." )
                    '-1003' => '\\ccxt\\RateLimitExceeded', // array( "code" => -1003,  "message" => "Rate limit exceed." )
                    '-1004' => '\\ccxt\\BadRequest', // array( "code" => -1004,  "message" => "An unknown parameter was sent." )
                    '-1005' => '\\ccxt\\BadRequest', // array( "code" => -1005,  "message" => "Some parameters are in wrong format for api." )
                    '-1006' => '\\ccxt\\BadRequest', // array( "code" => -1006,  "message" => "The data is not found in server." )
                    '-1007' => '\\ccxt\\BadRequest', // array( "code" => -1007,  "message" => "The data is already exists or your request is duplicated." )
                    '-1008' => '\\ccxt\\InvalidOrder', // array( "code" => -1008,  "message" => "The quantity of settlement is too high than you can request." )
                    '-1009' => '\\ccxt\\BadRequest', // array( "code" => -1009,  "message" => "Can not request withdrawal settlement, you need to deposit other arrears first." )
                    '-1011' => '\\ccxt\\ExchangeError', // array( "code" => -1011,  "message" => "Can not place/cancel orders, it may because internal network error. Please try again in a few seconds." )
                    '-1012' => '\\ccxt\\BadRequest', // array( "code" => -1012,  "message" => "Amount is required for buy market orders when margin disabled.")  The place/cancel order request is rejected by internal module, it may because the account is in liquidation or other internal errors. Please try again in a few seconds." }
                    '-1101' => '\\ccxt\\InvalidOrder', // array( "code" => -1101,  "message" => "The risk exposure for client is too high, it may cause by sending too big order or the leverage is too low. please refer to client info to check the current exposure." )
                    '-1102' => '\\ccxt\\InvalidOrder', // array( "code" => -1102,  "message" => "The order value (price * size) is too small." )
                    '-1103' => '\\ccxt\\InvalidOrder', // array( "code" => -1103,  "message" => "The order price is not following the tick size rule for the symbol." )
                    '-1104' => '\\ccxt\\InvalidOrder', // array( "code" => -1104,  "message" => "The order quantity is not following the step size rule for the symbol." )
                    '-1105' => '\\ccxt\\InvalidOrder', // array( "code" => -1105,  "message" => "Price is X% too high or X% too low from the mid price." )
                ),
                'broad' => array(
                    'symbol must not be blank' => '\\ccxt\\BadRequest', // when sending 'cancelOrder' without symbol [-1005]
                    'The token is not supported' => '\\ccxt\\BadRequest', // when getting incorrect token's deposit address [-1005]
                    'Your order and symbol are not valid or already canceled' => '\\ccxt\\BadRequest', // actual response whensending 'cancelOrder' for already canceled id [-1006]
                    'Insufficient WOO. Please enable margin trading for leverage trading' => '\\ccxt\\BadRequest', // when selling insufficent token [-1012]
                ),
            ),
            'precisionMode' => TICK_SIZE,
        ));
    }

    public function fetch_markets($params = array ()) {
        /**
         * retrieves $data on all markets for woo
         * @param {dict} $params extra parameters specific to the exchange api endpoint
         * @return {[dict]} an array of objects representing $market $data
         */
        list($marketType, $query) = $this->handle_market_type_and_params('fetchMarkets', null, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'v1PublicGetInfo',
        ));
        $response = yield $this->$method ($query);
        //
        // {
        //     rows => [
        //         array(
        //             $symbol => "SPOT_AAVE_USDT",
        //             quote_min => 0,
        //             quote_max => 100000,
        //             quote_tick => 0.01,
        //             base_min => 0.01,
        //             base_max => 7284,
        //             base_tick => 0.0001,
        //             min_notional => 10,
        //             price_range => 0.1,
        //             created_time => "0",
        //             updated_time => "1639107647.988",
        //             is_stable => 0
        //         ),
        //         ...
        //     success => true
        // }
        //
        $data = $this->safe_value($response, 'rows', array());
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $market = $data[$i];
            $marketId = $this->safe_string($market, 'symbol');
            $parts = explode('_', $marketId);
            $marketTypeVal = $this->safe_string_lower($parts, 0);
            $isSpot = $marketTypeVal === 'spot';
            $isSwap = false;
            $isFuture = false;
            $isOption = false;
            $baseId = $this->safe_string($parts, 1);
            $quoteId = $this->safe_string($parts, 2);
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $symbol = $base . '/' . $quote;
            $minQuote = $this->safe_number($market, 'quote_min');
            $maxQuote = $this->safe_number($market, 'quote_max');
            $minBase = $this->safe_number($market, 'base_min');
            $maxBase = $this->safe_number($market, 'base_max');
            $priceScale = $this->safe_number($market, 'quote_tick');
            $quantityScale = $this->safe_number($market, 'base_tick');
            $minCost = $this->safe_number($market, 'min_notional');
            $result[] = array(
                'id' => $marketId,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'settle' => null,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'settleId' => null,
                'type' => $marketTypeVal,
                'spot' => $isSpot,
                'margin' => true,
                'swap' => false,
                'future' => false,
                'option' => false,
                'active' => null,
                'contract' => $isSwap || $isFuture || $isOption,
                'linear' => null,
                'inverse' => null,
                'contractSize' => null,
                'expiry' => null,
                'expiryDatetime' => null,
                'strike' => null,
                'optionType' => null,
                'precision' => array(
                    'amount' => $quantityScale,
                    'price' => $priceScale,
                ),
                'limits' => array(
                    'leverage' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'amount' => array(
                        'min' => $minBase,
                        'max' => $maxBase,
                    ),
                    'price' => array(
                        'min' => $minQuote,
                        'max' => $maxQuote,
                    ),
                    'cost' => array(
                        'min' => $minCost,
                        'max' => null,
                    ),
                ),
                'info' => $market,
            );
        }
        return $result;
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        /**
         * get the list of most recent trades for a particular $symbol
         * @param {str} $symbol unified $symbol of the $market to fetch trades for
         * @param {int|null} $since timestamp in ms of the earliest trade to fetch
         * @param {int|null} $limit the maximum amount of trades to fetch
         * @param {dict} $params extra parameters specific to the woo api endpoint
         * @return {[dict]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-trades trade structures~
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchTrades() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        list($marketType, $query) = $this->handle_market_type_and_params('fetchTrades', $market, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'v1PublicGetMarketTrades',
        ));
        $response = yield $this->$method (array_merge($request, $query));
        //
        // {
        //     success => true,
        //     rows => array(
        //         array(
        //             $symbol => "SPOT_BTC_USDT",
        //             side => "SELL",
        //             executed_price => 46222.35,
        //             executed_quantity => 0.0012,
        //             executed_timestamp => "1641241162.329"
        //         ),
        //         array(
        //             $symbol => "SPOT_BTC_USDT",
        //             side => "SELL",
        //             executed_price => 46222.35,
        //             executed_quantity => 0.0012,
        //             executed_timestamp => "1641241162.329"
        //         ),
        //         array(
        //             $symbol => "SPOT_BTC_USDT",
        //             side => "BUY",
        //             executed_price => 46224.32,
        //             executed_quantity => 0.00039,
        //             executed_timestamp => "1641241162.287"
        //         ),
        //         ...
        //      )
        // }
        //
        $resultResponse = $this->safe_value($response, 'rows', array());
        return $this->parse_trades($resultResponse, $market, $since, $limit);
    }

    public function parse_trade($trade, $market = null) {
        //
        // public/market_trades
        //
        //     {
        //         $symbol => "SPOT_BTC_USDT",
        //         $side => "SELL",
        //         executed_price => 46222.35,
        //         executed_quantity => 0.0012,
        //         executed_timestamp => "1641241162.329"
        //     }
        //
        // fetchOrderTrades, fetchOrder
        //
        //     {
        //         $id => '99119876',
        //         $symbol => 'SPOT_WOO_USDT',
        //         $fee => '0.0024',
        //         $side => 'BUY',
        //         executed_timestamp => '1641481113.084',
        //         $order_id => '87001234',
        //         order_tag => 'default', <-- this param only in "fetchOrderTrades"
        //         executed_price => '1',
        //         executed_quantity => '12',
        //         fee_asset => 'WOO',
        //         is_maker => '1'
        //     }
        //
        $isFromFetchOrder = (is_array($trade) && array_key_exists('id', $trade));
        $timestamp = $this->safe_timestamp($trade, 'executed_timestamp');
        $marketId = $this->safe_string($trade, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $price = $this->safe_string($trade, 'executed_price');
        $amount = $this->safe_string($trade, 'executed_quantity');
        $order_id = $this->safe_string($trade, 'order_id');
        $fee = $this->parse_token_and_fee_temp($trade, 'fee_asset', 'fee');
        $cost = Precise::string_mul($price, $amount);
        $side = $this->safe_string_lower($trade, 'side');
        $id = $this->safe_string($trade, 'id');
        if ($id === null) { // reconstruct artificially, if it doesn't exist
            if ($timestamp !== null) {
                $amountStr = ($amount === null) ? '' : $amount;
                $sideStr = ($side === null) ? '' : $side;
                $priceStr = ($price === null) ? '' : $price;
                $marketIdStr = $this->safe_string($market, 'id', '');
                $id = $this->number_to_string($timestamp) . '-' . $marketIdStr . '-' . $sideStr . '-' . $amountStr . '-' . $priceStr;
            }
        }
        $takerOrMaker = null;
        if ($isFromFetchOrder) {
            $isMaker = $this->safe_string($trade, 'is_maker') === '1';
            $takerOrMaker = $isMaker ? 'maker' : 'taker';
        }
        return $this->safe_trade(array(
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'order' => $order_id,
            'takerOrMaker' => $takerOrMaker,
            'type' => null,
            'fee' => $fee,
            'info' => $trade,
        ), $market);
    }

    public function parse_token_and_fee_temp($item, $feeTokenKey, $feeAmountKey) {
        $feeCost = $this->safe_string($item, $feeAmountKey);
        $fee = null;
        if ($feeCost !== null) {
            $feeCurrencyId = $this->safe_string($item, $feeTokenKey);
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrencyCode,
            );
        }
        return $fee;
    }

    public function fetch_trading_fees($params = array ()) {
        yield $this->load_markets();
        $response = yield $this->v1PrivateGetClientInfo ($params);
        //
        //     {
        //         "application":array(
        //             "id":45585,
        //             "leverage":3.00,
        //             "otpauth":false,
        //             "alias":"email@address.com",
        //             "application_id":"c2cc4d74-c8cb-4e10-84db-af2089b8c68a",
        //             "account":"email@address.com",
        //             "account_mode":"PURE_SPOT",
        //             "taker_fee_rate":5.00,
        //             "maker_fee_rate":2.00,
        //             "interest_rate":0.00,
        //             "futures_leverage":1.00,
        //             "futures_taker_fee_rate":5.00,
        //             "futures_maker_fee_rate":2.00
        //         ),
        //         "margin_rate":1000,
        //         "success":true
        //     }
        //
        $application = $this->safe_value($response, 'application', array());
        $maker = $this->safe_string($application, 'maker_fee_rate');
        $taker = $this->safe_string($application, 'taker_fee_rate');
        $result = array();
        for ($i = 0; $i < count($this->symbols); $i++) {
            $symbol = $this->symbols[$i];
            $result[$symbol] = array(
                'info' => $response,
                'symbol' => $symbol,
                'maker' => $this->parse_number(Precise::string_div($maker, '10000')),
                'taker' => $this->parse_number(Precise::string_div($taker, '10000')),
                'percentage' => true,
                'tierBased' => true,
            );
        }
        return $result;
    }

    public function fetch_currencies($params = array ()) {
        /**
         * fetches all available currencies on an exchange
         * @param {dict} $params extra parameters specific to the woo api endpoint
         * @return {dict} an associative dictionary of currencies
         */
        $method = null;
        $result = array();
        list($marketType, $query) = $this->handle_market_type_and_params('fetchCurrencies', null, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'v1PublicGetToken',
        ));
        $tokenResponse = yield $this->$method ($query);
        //
        // {
        //     rows => array(
        //         array(
        //             token => "ETH_USDT",
        //             fullname => "Tether",
        //             $decimals => 6,
        //             balance_token => "USDT",
        //             created_time => "0",
        //             updated_time => "0"
        //         ),
        //         array(
        //             token => "BSC_USDT",
        //             fullname => "Tether",
        //             $decimals => 18,
        //             balance_token => "USDT",
        //             created_time => "0",
        //             updated_time => "0"
        //         ),
        //         array(
        //             token => "ZEC",
        //             fullname => "ZCash",
        //             $decimals => 8,
        //             balance_token => "ZEC",
        //             created_time => "0",
        //             updated_time => "0"
        //         ),
        //         ...
        //     ),
        //     success => true
        // }
        //
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'v1PublicGetTokenNetwork',
        ));
        $tokenNetworkResponse = yield $this->$method ($query);
        //
        // {
        //     rows => array(
        //         array(
        //             protocol => "ERC20",
        //             token => "USDT",
        //             $name => "Ethereum",
        //             minimum_withdrawal => 30,
        //             withdrawal_fee => 25,
        //             allow_deposit => 1,
        //             allow_withdraw => 1
        //         ),
        //         array(
        //             protocol => "TRC20",
        //             token => "USDT",
        //             $name => "Tron",
        //             minimum_withdrawal => 30,
        //             withdrawal_fee => 1,
        //             allow_deposit => 1,
        //             allow_withdraw => 1
        //         ),
        //         ...
        //     ),
        //     success => true
        // }
        //
        $tokenRows = $this->safe_value($tokenResponse, 'rows', array());
        $tokenNetworkRows = $this->safe_value($tokenNetworkResponse, 'rows', array());
        $networksByCurrencyId = $this->group_by($tokenNetworkRows, 'token');
        for ($i = 0; $i < count($tokenRows); $i++) {
            $currency = $tokenRows[$i];
            $id = $this->safe_string($currency, 'balance_token');
            $code = $this->safe_currency_code($id);
            $name = $this->safe_string($currency, 'fullname');
            $decimals = $this->safe_integer($currency, 'decimals');
            $chainedTokenCode = $this->safe_string($currency, 'token');
            $parts = explode('_', $chainedTokenCode);
            $chainNameId = $this->safe_string($parts, 0, $chainedTokenCode);
            $chainCode = $this->safe_string($this->options['network-aliases'], $chainNameId, $chainNameId);
            if (!(is_array($result) && array_key_exists($code, $result))) {
                $networks = $this->safe_value($networksByCurrencyId, $id, array());
                $resultingNetworks = array();
                for ($j = 0; $j < count($networks); $j++) {
                    $networkEntry = $networks[$j];
                    $networkId = $this->safe_string($networkEntry, 'protocol');
                    $networkIdManualMatched = $this->safe_string($this->options['network-aliases-for-tokens'], $networkId, $networkId);
                    $networkCode = $this->safe_string_2($this->options['network-aliases-for-protocol'], $chainNameId, $chainNameId, $networkIdManualMatched);
                    $depositEnabled = $this->safe_integer($networkEntry, 'allow_deposit', 0);
                    $withdrawEnabled = $this->safe_integer($networkEntry, 'allow_withdraw', 0);
                    $resultingNetworks[$networkCode] = array(
                        'id' => $networkId,
                        'network' => $networkCode,
                        'limits' => array(
                            'withdraw' => array(
                                'min' => $this->safe_number($networkEntry, 'minimum_withdrawal'),
                                'max' => null,
                            ),
                            'deposit' => array(
                                'min' => null,
                                'max' => null,
                            ),
                        ),
                        'active' => null,
                        'deposit' => $depositEnabled,
                        'withdraw' => $withdrawEnabled,
                        'fee' => $this->safe_number($networkEntry, 'withdrawal_fee'),
                        'precision' => null, // will be filled down below
                        'info' => $networkEntry,
                    );
                }
                $networksKeys = is_array($resultingNetworks) ? array_keys($resultingNetworks) : array();
                $firstNetworkKey = $networksKeys[0];
                $networkLength = is_array($networksKeys) ? count($networksKeys) : 0;
                $result[$code] = array(
                    'id' => $id,
                    'name' => $name,
                    'code' => $code,
                    'precision' => ($networkLength === 1) ? $decimals : null, // will be filled down below
                    'active' => null,
                    'fee' => ($networkLength === 1) ? $resultingNetworks[$firstNetworkKey]['fee'] : null,
                    'networks' => $resultingNetworks,
                    'limits' => array(
                        'deposit' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'withdraw' => array(
                            'min' => ($networkLength === 1) ? $resultingNetworks[$firstNetworkKey]['limits']['withdraw']['min'] : null,
                            'max' => null,
                        ),
                    ),
                    'info' => array(), // will be filled down below
                );
            }
            $networkKeys = is_array($result[$code]['networks']) ? array_keys($result[$code]['networks']) : array();
            $firstNetworkKey = $this->safe_string($networkKeys, 0);
            // now add the precision info from token-object
            if (is_array($result[$code]['networks']) && array_key_exists($chainCode, $result[$code]['networks'])) {
                $result[$code]['networks'][$chainCode]['precision'] = $decimals;
            } else {
                // else $chainCode will be the only token slug, which has only 1 supported network
                $result[$code]['networks'][$firstNetworkKey]['precision'] = $decimals;
            }
            // now add the info object specifically for the item
            $result[$code]['info'][$chainedTokenCode] = $currency;
        }
        return $result;
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'order_type' => strtoupper($type),
            'side' => strtoupper($side),
        );
        if ($price !== null) {
            $request['order_price'] = $this->price_to_precision($symbol, $price);
        }
        if ($type === 'market') {
            // for $market buy it requires the $amount of quote currency to spend
            if ($side === 'buy') {
                $cost = $this->safe_number($params, 'cost');
                if ($this->safe_value($this->options, 'createMarketBuyOrderRequiresPrice', true)) {
                    if ($cost === null) {
                        if ($price === null) {
                            throw new InvalidOrder($this->id . " createOrder() requires the $price argument for $market buy orders to calculate total order $cost-> Supply a $price argument to createOrder() call if you want the $cost to be calculated for you from $price and $amount, or alternatively, supply the total $cost value in the 'order_amount' in  exchange-specific parameters");
                        } else {
                            $request['order_amount'] = $this->cost_to_precision($symbol, $amount * $price);
                        }
                    } else {
                        $request['order_amount'] = $this->cost_to_precision($symbol, $cost);
                    }
                }
            } else {
                $request['order_quantity'] = $this->amount_to_precision($symbol, $amount);
            }
        } else {
            $request['order_quantity'] = $this->amount_to_precision($symbol, $amount);
        }
        $clientOrderId = $this->safe_string_2($params, 'clOrdID', 'clientOrderId');
        if ($clientOrderId !== null) {
            $request['client_order_id'] = $clientOrderId;
        }
        $params = $this->omit($params, array( 'clOrdID', 'clientOrderId' ));
        list($marketType, $query) = $this->handle_market_type_and_params('createOrder', $market, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'v1PrivatePostOrder',
        ));
        $response = yield $this->$method (array_merge($request, $query));
        // {
        //     success => true,
        //     timestamp => '1641383206.489',
        //     order_id => '86980774',
        //     order_type => 'LIMIT',
        //     order_price => '1', // null for 'MARKET' order
        //     order_quantity => '12', // null for 'MARKET' order
        //     order_amount => null, // NOT-null for 'MARKET' order
        //     client_order_id => '0'
        // }
        return array_merge(
            $this->parse_order($response, $market),
            array( 'type' => $type )
        );
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument');
        }
        yield $this->load_markets();
        $request = null;
        $clientOrderIdUnified = $this->safe_string_2($params, 'clOrdID', 'clientOrderId');
        $clientOrderIdExchangeSpecific = $this->safe_string_2($params, 'client_order_id', $clientOrderIdUnified);
        $isByClientOrder = $clientOrderIdExchangeSpecific !== null;
        if ($isByClientOrder) {
            $request['client_order_id'] = $clientOrderIdExchangeSpecific;
            $params = $this->omit($params, array( 'clOrdID', 'clientOrderId', 'client_order_id' ));
        } else {
            $request['order_id'] = $id;
        }
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
        }
        $request['symbol'] = $market['id'];
        list($marketType, $query) = $this->handle_market_type_and_params('cancelOrder', $market, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'v1PrivateDeleteOrder',
        ));
        $response = yield $this->$method (array_merge($request, $query));
        //
        // array( success => true, status => 'CANCEL_SENT' )
        //
        $extendParams = array( 'symbol' => $symbol );
        if ($isByClientOrder) {
            $extendParams['client_order_id'] = $clientOrderIdExchangeSpecific;
        } else {
            $extendParams['id'] = $id;
        }
        return array_merge($this->parse_order($response), $extendParams);
    }

    public function cancel_orders($ids, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' canelOrders() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        list($marketType, $query) = $this->handle_market_type_and_params('cancelOrders', $market, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'v1PrivateDeleteOrders',
        ));
        $response = yield $this->$method (array_merge($request, $query));
        return $response;
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        yield $this->load_markets();
        $market = ($symbol !== null) ? $this->market($symbol) : null;
        $request = array();
        list($marketType, $query) = $this->handle_market_type_and_params('fetchOrder', $market, $params);
        $clientOrderId = $this->safe_string_2($params, 'clOrdID', 'clientOrderId');
        $chosenSpotMethod = null;
        if ($clientOrderId) {
            $chosenSpotMethod = 'v1PrivateGetClientOrderClientOrderId';
            $request['client_order_id'] = $clientOrderId;
        } else {
            $chosenSpotMethod = 'v1PrivateGetOrderOid';
            $request['oid'] = $id;
        }
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => $chosenSpotMethod,
        ));
        $response = yield $this->$method (array_merge($request, $query));
        //
        // {
        //     success => true,
        //     $symbol => 'SPOT_WOO_USDT',
        //     status => 'FILLED', // FILLED, NEW
        //     side => 'BUY',
        //     created_time => '1641480933.000',
        //     order_id => '87541111',
        //     order_tag => 'default',
        //     price => '1',
        //     type => 'LIMIT',
        //     quantity => '12',
        //     amount => null,
        //     visible => '12',
        //     executed => '12', // or any partial amount
        //     total_fee => '0.0024',
        //     fee_asset => 'WOO',
        //     client_order_id => null,
        //     average_executed_price => '1',
        //     Transactions => array(
        //       {
        //         $id => '99111647',
        //         $symbol => 'SPOT_WOO_USDT',
        //         fee => '0.0024',
        //         side => 'BUY',
        //         executed_timestamp => '1641482113.084',
        //         order_id => '87541111',
        //         executed_price => '1',
        //         executed_quantity => '12',
        //         fee_asset => 'WOO',
        //         is_maker => '1'
        //       }
        //     )
        // }
        //
        return $this->parse_order($response);
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            $request['start_t'] = $since;
        }
        list($marketType, $query) = $this->handle_market_type_and_params('fetchOrders', $market, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'v1PrivateGetOrders',
        ));
        $response = yield $this->$method (array_merge($request, $query));
        $data = $this->safe_value($response, 'rows');
        return $this->parse_orders($data, $market, $since, $limit, $params);
    }

    public function parse_order($order, $market = null) {
        //
        // Possible input functions:
        // * createOrder
        // * cancelOrder
        // * fetchOrder
        // * fetchOrders
        // $isFromFetchOrder = (is_array($order) && array_key_exists('order_tag', $order)); TO_DO
        $timestamp = $this->safe_timestamp_2($order, 'timestamp', 'created_time');
        $orderId = $this->safe_integer($order, 'order_id');
        $clientOrderId = $this->safe_timestamp($order, 'client_order_id'); // Somehow, this always returns 0 for limit $order
        $marketId = $this->safe_string($order, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $price = $this->safe_string_2($order, 'order_price', 'price');
        $amount = $this->safe_string_2($order, 'order_quantity', 'quantity'); // This is base $amount
        $cost = $this->safe_string_2($order, 'order_amount', 'amount'); // This is quote $amount
        $orderType = $this->safe_string_lower_2($order, 'order_type', 'type');
        $status = $this->safe_value($order, 'status');
        $side = $this->safe_string_lower($order, 'side');
        $filled = $this->safe_value($order, 'executed');
        $remaining = Precise::string_sub($cost, $filled);
        $fee = $this->safe_value($order, 'total_fee');
        $feeCurrency = $this->safe_string($order, 'fee_asset');
        $transactions = $this->safe_value($order, 'Transactions');
        return $this->safe_order(array(
            'id' => $orderId,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'status' => $this->parse_order_status($status),
            'symbol' => $symbol,
            'type' => $orderType,
            'timeInForce' => null,
            'postOnly' => null, // TO_DO
            'side' => $side,
            'price' => $price,
            'stopPrice' => null,
            'average' => null,
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => $remaining, // TO_DO
            'cost' => $cost,
            'trades' => $transactions,
            'fee' => array(
                'cost' => $fee,
                'currency' => $feeCurrency,
            ),
            'info' => $order,
        ), $market);
    }

    public function parse_order_status($status) {
        if ($status !== null) {
            $statuses = array(
                'NEW' => 'open',
                'FILLED' => 'closed',
                'CANCEL_SENT' => 'canceled',
                'CANCEL_ALL_SENT' => 'canceled',
            );
            return $this->safe_string($statuses, $status, $status);
        }
        return $status;
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        /**
         * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
         * @param {str} $symbol unified $symbol of the $market to fetch the order book for
         * @param {int|null} $limit the maximum amount of order book entries to return
         * @param {dict} $params extra parameters specific to the woo api endpoint
         * @return {dict} A dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure order book structures} indexed by $market symbols
         */
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $limit = min ($limit, 1000);
            $request['max_level'] = $limit;
        }
        list($marketType, $query) = $this->handle_market_type_and_params('fetchOrderBook', $market, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'v1PrivateGetOrderbookSymbol',
        ));
        $response = yield $this->$method (array_merge($request, $query));
        //
        // {
        //   success => true,
        //   $timestamp => '1641562961192',
        //   asks => array(
        //     array( price => '0.921', quantity => '76.01' ),
        //     array( price => '0.933', quantity => '477.10' ),
        //     ...
        //   ),
        //   bids => array(
        //     array( price => '0.940', quantity => '13502.47' ),
        //     array( price => '0.932', quantity => '43.91' ),
        //     ...
        //   )
        // }
        //
        $timestamp = $this->safe_integer($response, 'timestamp');
        return $this->parse_order_book($response, $symbol, $timestamp, 'bids', 'asks', 'price', 'quantity');
    }

    public function fetch_ohlcv($symbol, $timeframe = '1h', $since = null, $limit = null, $params = array ()) {
        /**
         * fetches historical candlestick $data containing the open, high, low, and close price, and the volume of a $market
         * @param {str} $symbol unified $symbol of the $market to fetch OHLCV $data for
         * @param {str} $timeframe the length of time each candle represents
         * @param {int|null} $since timestamp in ms of the earliest candle to fetch
         * @param {int|null} $limit the maximum amount of candles to fetch
         * @param {dict} $params extra parameters specific to the woo api endpoint
         * @return {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
         */
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'type' => $this->timeframes[$timeframe],
        );
        if ($limit !== null) {
            $request['limit'] = min ($limit, 1000);
        }
        list($marketType, $query) = $this->handle_market_type_and_params('fetchOHLCV', $market, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'v1PrivateGetKline',
        ));
        $response = yield $this->$method (array_merge($request, $query));
        // {
        //     success => true,
        //     rows => array(
        //       array(
        //         open => '0.94238',
        //         close => '0.94271',
        //         low => '0.94238',
        //         high => '0.94296',
        //         volume => '73.55',
        //         amount => '69.32040520',
        //         $symbol => 'SPOT_WOO_USDT',
        //         type => '1m',
        //         start_timestamp => '1641584700000',
        //         end_timestamp => '1641584760000'
        //       ),
        //       array(
        //         open => '0.94186',
        //         close => '0.94186',
        //         low => '0.94186',
        //         high => '0.94186',
        //         volume => '64.00',
        //         amount => '60.27904000',
        //         $symbol => 'SPOT_WOO_USDT',
        //         type => '1m',
        //         start_timestamp => '1641584640000',
        //         end_timestamp => '1641584700000'
        //       ),
        //       ...
        //     )
        // }
        $data = $this->safe_value($response, 'rows', array());
        return $this->parse_ohlcvs($data, $market, $timeframe, $since, $limit);
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        // example response in fetchOHLCV
        return array(
            $this->safe_integer($ohlcv, 'start_timestamp'),
            $this->safe_number($ohlcv, 'open'),
            $this->safe_number($ohlcv, 'high'),
            $this->safe_number($ohlcv, 'low'),
            $this->safe_number($ohlcv, 'close'),
            $this->safe_number($ohlcv, 'volume'),
        );
    }

    public function fetch_order_trades($id, $symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
        }
        $request = array(
            'oid' => $id,
        );
        list($marketType, $query) = $this->handle_market_type_and_params('fetchOrderTrades', $market, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'v1PrivateGetOrderOidTrades',
        ));
        $response = yield $this->$method (array_merge($request, $query));
        // {
        //     success => true,
        //     rows => array(
        //       {
        //         $id => '99111647',
        //         $symbol => 'SPOT_WOO_USDT',
        //         fee => '0.0024',
        //         side => 'BUY',
        //         executed_timestamp => '1641482113.084',
        //         order_id => '87541111',
        //         order_tag => 'default',
        //         executed_price => '1',
        //         executed_quantity => '12',
        //         fee_asset => 'WOO',
        //         is_maker => '1'
        //       }
        //     )
        // }
        $trades = $this->safe_value($response, 'rows', array());
        return $this->parse_trades($trades, $market, $since, $limit, $params);
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            $request['start_t'] = $since;
        }
        list($marketType, $query) = $this->handle_market_type_and_params('fetchMyTrades', $market, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'v1PrivateGetClientTrades',
        ));
        $response = yield $this->$method (array_merge($request, $query));
        // {
        //     "success" => true,
        //     "meta" => array(
        //         "records_per_page" => 25,
        //         "current_page" => 1
        //     ),
        //     "rows" => array(
        //         array(
        //             "id" => 5,
        //             "symbol" => "SPOT_BTC_USDT",
        //             "order_id" => 211,
        //             "order_tag" => "default",
        //             "executed_price" => 10892.84,
        //             "executed_quantity" => 0.002,
        //             "is_maker" => 0,
        //             "side" => "SELL",
        //             "fee" => 0,
        //             "fee_asset" => "USDT",
        //             "executed_timestamp" => "1566264290.250"
        //         ),
        //         ...
        //     )
        // }
        $trades = $this->safe_value($response, 'rows', array());
        return $this->parse_trades($trades, $market, $since, $limit, $params);
    }

    public function fetch_accounts($params = array ()) {
        /**
         * query to fetchAccounts
         * @param {dict} $params extra parameters specific to the woo api endpoint
         * @return {dict} a ~@link https://docs.ccxt.com/en/latest/manual.html?#account-structure account structure~
         */
        $response = yield $this->v1PrivateGetSubAccountAssets ($params);
        //
        //     {
        //         $rows => [array(
        //                 application_id => '13e4fc34-e2ff-4cb7-b1e4-4c22fee7d365',
        //                 account => 'Main',
        //                 usdt_balance => '4.0'
        //             ),
        //             {
        //                 application_id => '432952aa-a401-4e26-aff6-972920aebba3',
        //                 account => 'subaccount',
        //                 usdt_balance => '1.0'
        //             }
        //         ],
        //         success => true
        //     }
        //
        $rows = $this->safe_value($response, 'rows', array());
        return $this->parse_accounts($rows, $params);
    }

    public function parse_account($account) {
        //
        //     {
        //         application_id => '336952aa-a401-4e26-aff6-972920aebba3',
        //         $account => 'subaccount',
        //         usdt_balance => '1.0',
        //     }
        //
        $accountId = $this->safe_string($account, 'account');
        return array(
            'info' => $account,
            'id' => $this->safe_string($account, 'application_id'),
            'name' => $accountId,
            'code' => null,
            'type' => $accountId === 'Main' ? 'main' : 'subaccount',
        );
    }

    public function fetch_balance($params = array ()) {
        /**
         * $query for balance and get the amount of funds available for trading or funds locked in orders
         * @param {dict} $params extra parameters specific to the woo api endpoint
         * @return {dict} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
         */
        yield $this->load_markets();
        list($marketType, $query) = $this->handle_market_type_and_params('fetchBalance', null, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'v2PrivateGetClientHolding',
        ));
        $response = yield $this->$method ($query);
        //
        // {
        //     holding => array(
        //       array(
        //         token => 'USDT',
        //         holding => '23.56', // free balance
        //         frozen => '888.0', // i.e. if in processing withdrawal
        //         interest => '0.0',
        //         outstanding_holding => '-56.7', // this value is set (negative number) if there is an open limit order, and this is QUOTE currency of order
        //         pending_exposure => '333.45', //  this value is set  (positive number) if there is an open limit order, and this is BASE currency of order
        //         opening_cost => '0.00000000',
        //         holding_cost => '0.00000000',
        //         realised_pnl => '0.00000000',
        //         settled_pnl => '0.00000000',
        //         fee_24_h => '0',
        //         settled_pnl_24_h => '0',
        //         updated_time => '1641370779'
        //       ),
        //       ...
        //     ),
        //     success => true
        // }
        //
        return $this->parse_balance($response);
    }

    public function parse_balance($response) {
        $result = array(
            'info' => $response,
        );
        $balances = $this->safe_value($response, 'holding', array());
        for ($i = 0; $i < count($balances); $i++) {
            $balance = $balances[$i];
            $code = $this->safe_currency_code($this->safe_string($balance, 'token'));
            $account = $this->account();
            $account['total'] = $this->safe_string($balance, 'holding');
            $used = $this->safe_string($balance, 'outstanding_holding');
            $account['used'] = Precise::string_neg($used);
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function fetch_deposit_address($code, $params = array ()) {
        // this $method is TODO because of networks unification
        yield $this->load_markets();
        $currency = $this->currency($code);
        $networkCodeDefault = $this->default_network_code_for_currency($code);
        $networkCode = $this->safe_value($params, 'network', $networkCodeDefault);
        $params = $this->omit($params, 'network');
        $networkAliases = $this->safe_value($this->options, 'network-aliases', array());
        $networkId = $this->getKeyByValue ($networkAliases, $networkCode);
        $codeForExchange = $networkId . '_' . $currency['code'];
        $request = array(
            'token' => $codeForExchange,
        );
        list($marketType, $query) = $this->handle_market_type_and_params('fetchDepositAddress', null, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'v1PrivateGetAssetDeposit',
        ));
        $response = yield $this->$method (array_merge($request, $query));
        // {
        //     success => true,
        //     $address => '3Jmtjx5544T4smrit9Eroe4PCrRkpDeKjP',
        //     extra => ''
        // }
        $tag = $this->safe_string($response, 'extra');
        $address = $this->safe_string($response, 'address');
        $this->check_address($address);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => $tag,
            'network' => $networkCode,
            'info' => $response,
        );
    }

    public function get_asset_history_rows($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array( );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['balance_token'] = $currency['id'];
        }
        if ($since !== null) {
            $request['start_t'] = $since;
        }
        if ($limit !== null) {
            $request['pageSize'] = $limit;
        }
        $transactionType = $this->safe_string($params, 'type');
        $params = $this->omit($params, 'type');
        if ($transactionType !== null) {
            $request['type'] = $transactionType;
        }
        $response = yield $this->v1PrivateGetAssetHistory (array_merge($request, $params));
        // {
        //     rows => array(
        //       {
        //         id => '22010508193900165',
        //         token => 'TRON_USDT',
        //         extra => '',
        //         amount => '13.75848500',
        //         status => 'COMPLETED',
        //         account => null,
        //         description => null,
        //         user_id => '42222',
        //         application_id => '6ad2b303-f354-45c0-8105-9f5f19d0e335',
        //         external_id => '220105081900134',
        //         target_address => 'TXnyFSnAYad3YCaqtwMw9jvXKkeU39NLnK',
        //         source_address => 'TYDzsYUEpvnYmQk4zGP9sWWcTEd2MiAtW6',
        //         type => 'BALANCE',
        //         token_side => 'DEPOSIT',
        //         tx_id => '35b0004022f6b3ad07f39a0b7af199f6b258c2c3e2c7cdc93c67efa74fd625ee',
        //         fee_token => '',
        //         fee_amount => '0.00000000',
        //         created_time => '1641370779.442',
        //         updated_time => '1641370779.465',
        //         is_new_target_address => null,
        //         confirmed_number => '29',
        //         confirming_threshold => '27',
        //         audit_tag => '1',
        //         audit_result => '0',
        //         balance_token => null, // TODO -write to support, that this seems broken. here should be the token id
        //         network_name => null // TODO -write to support, that this seems broken. here should be the network id
        //       }
        //     ),
        //     meta => array( total => '1', records_per_page => '25', current_page => '1' ),
        //     success => true
        // }
        return array( $currency, $this->safe_value($response, 'rows', array()) );
    }

    public function fetch_ledger($code = null, $since = null, $limit = null, $params = array ()) {
        list($currency, $rows) = yield $this->get_asset_history_rows($code, $since, $limit, $params);
        return $this->parse_ledger($rows, $currency, $since, $limit, $params);
    }

    public function parse_ledger_entry($item, $currency = null) {
        $networkizedCode = $this->safe_string($item, 'token');
        $currencyDefined = $this->get_currency_from_chaincode($networkizedCode, $currency);
        $code = $currencyDefined['code'];
        $amount = $this->safe_number($item, 'amount');
        $side = $this->safe_number($item, 'token_side');
        $direction = ($side === 'DEPOSIT') ? 'in' : 'out';
        $timestamp = $this->safe_timestamp($item, 'created_time');
        $fee = $this->parse_token_and_fee_temp($item, 'fee_token', 'fee_amount');
        return array(
            'id' => $this->safe_string($item, 'id'),
            'currency' => $code,
            'account' => $this->safe_string($item, 'account'),
            'referenceAccount' => null,
            'referenceId' => $this->safe_string($item, 'tx_id'),
            'status' => $this->parse_transaction_status($item, 'status'),
            'amount' => $amount,
            'before' => null,
            'after' => null,
            'fee' => $fee,
            'direction' => $direction,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'type' => $this->parse_ledger_entry_type($this->safe_string($item, 'type')),
            'info' => $item,
        );
    }

    public function parse_ledger_entry_type($type) {
        $types = array(
            'BALANCE' => 'transaction', // Funds moved in/out wallet
            'COLLATERAL' => 'transfer', // Funds moved between portfolios
        );
        return $this->safe_string($types, $type, $type);
    }

    public function get_currency_from_chaincode($networkizedCode, $currency) {
        if ($currency !== null) {
            return $currency;
        } else {
            $parts = explode('_', $networkizedCode);
            $partsLength = is_array($parts) ? count($parts) : 0;
            $firstPart = $this->safe_string($parts, 0);
            $currencyId = $this->safe_string($parts, 1, $firstPart);
            if ($partsLength > 2) {
                $currencyId .= '_' . $this->safe_string($parts, 2);
            }
            $currency = $this->safe_currency($currencyId);
        }
        return $currency;
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        $request = array(
            'token_side' => 'DEPOSIT',
        );
        return yield $this->fetch_transactions($code, $since, $limit, array_merge($request, $params));
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        $request = array(
            'token_side' => 'WITHDRAW',
        );
        return yield $this->fetch_transactions($code, $since, $limit, array_merge($request, $params));
    }

    public function fetch_transactions($code = null, $since = null, $limit = null, $params = array ()) {
        $request = array(
            'type' => 'BALANCE',
        );
        list($currency, $rows) = yield $this->get_asset_history_rows($code, $since, $limit, array_merge($request, $params));
        return $this->parse_transactions($rows, $currency, $since, $limit, $params);
    }

    public function parse_transaction($transaction, $currency = null) {
        // example in fetchLedger
        $networkizedCode = $this->safe_string($transaction, 'token');
        $currencyDefined = $this->get_currency_from_chaincode($networkizedCode, $currency);
        $code = $currencyDefined['code'];
        $movementDirection = $this->safe_string_lower($transaction, 'token_side');
        if ($movementDirection === 'withdraw') {
            $movementDirection = 'withdrawal';
        }
        $fee = $this->parse_token_and_fee_temp($transaction, 'fee_token', 'fee_amount');
        $fee['rate'] = null;
        $addressTo = $this->safe_string($transaction, 'target_address');
        $addressFrom = $this->safe_string($transaction, 'source_address');
        $timestamp = $this->safe_timestamp($transaction, 'created_time');
        return array(
            'id' => $this->safe_string($transaction, 'id'),
            'txid' => $this->safe_string($transaction, 'tx_id'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'address' => null,
            'addressFrom' => $addressFrom,
            'addressTo' => $addressTo,
            'tag' => $this->safe_string($transaction, 'extra'),
            'type' => $movementDirection,
            'amount' => $this->safe_number($transaction, 'amount'),
            'currency' => $code,
            'status' => $this->parse_transaction_status($this->safe_string($transaction, 'status')),
            'updated' => $this->safe_timestamp($transaction, 'updated_time'),
            'fee' => $fee,
            'info' => $transaction,
        );
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            'NEW' => 'pending',
            'CONFIRMING' => 'pending',
            'PROCESSING' => 'pending',
            'COMPLETED' => 'ok',
            'CANCELED' => 'canceled',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function transfer($code, $amount, $fromAccount, $toAccount, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'token' => $currency['id'],
            'amount' => $this->parse_number($amount),
            'from_application_id' => $fromAccount,
            'to_application_id' => $toAccount,
        );
        $response = yield $this->v1PrivatePostAssetMainSubTransfer (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "id" => 200
        //     }
        //
        $transfer = $this->parse_transfer($response, $currency);
        $transferOptions = $this->safe_value($this->options, 'transfer', array());
        $fillResponseFromRequest = $this->safe_value($transferOptions, 'fillResponseFromRequest', true);
        if ($fillResponseFromRequest) {
            $transfer['amount'] = $amount;
            $transfer['fromAccount'] = $fromAccount;
            $transfer['toAccount'] = $toAccount;
        }
        return $transfer;
    }

    public function fetch_transfers($code = null, $since = null, $limit = null, $params = array ()) {
        $request = array(
            'type' => 'COLLATERAL',
        );
        list($currency, $rows) = yield $this->get_asset_history_rows($code, $since, $limit, array_merge($request, $params));
        return $this->parse_transfers($rows, $currency, $since, $limit, $params);
    }

    public function parse_transfer($transfer, $currency = null) {
        //
        //    getAssetHistoryRows
        //        {
        //            "created_time" => "1579399877.041",  // Unix epoch time in seconds
        //            "updated_time" => "1579399877.041",  // Unix epoch time in seconds
        //            "id" => "202029292829292",
        //            "external_id" => "202029292829292",
        //            "application_id" => null,
        //            "token" => "ETH",
        //            "target_address" => "0x31d64B3230f8baDD91dE1710A65DF536aF8f7cDa",
        //            "source_address" => "0x70fd25717f769c7f9a46b319f0f9103c0d887af0",
        //            "extra" => "",
        //            "type" => "BALANCE",
        //            "token_side" => "DEPOSIT",
        //            "amount" => 1000,
        //            "tx_id" => "0x8a74c517bc104c8ebad0c3c3f64b1f302ed5f8bca598ae4459c63419038106b6",
        //            "fee_token" => null,
        //            "fee_amount" => null,
        //            "status" => "CONFIRMING"
        //        }
        //
        //    v1PrivatePostAssetMainSubTransfer
        //        {
        //            "success" => true,
        //            "id" => 200
        //        }
        //
        $networkizedCode = $this->safe_string($transfer, 'token');
        $currencyDefined = $this->get_currency_from_chaincode($networkizedCode, $currency);
        $code = $currencyDefined['code'];
        $movementDirection = $this->safe_string_lower($transfer, 'token_side');
        if ($movementDirection === 'withdraw') {
            $movementDirection = 'withdrawal';
        }
        $fromAccount = null;
        $toAccount = null;
        if ($movementDirection === 'withdraw') {
            $fromAccount = null;
            $toAccount = 'spot';
        } elseif ($movementDirection === 'deposit') {
            $fromAccount = 'spot';
            $toAccount = null;
        }
        $timestamp = $this->safe_timestamp($transfer, 'created_time');
        $success = $this->safe_value($transfer, 'success');
        $status = null;
        if ($success !== null) {
            $status = $success ? 'ok' : 'failed';
        }
        return array(
            'id' => $this->safe_string($transfer, 'id'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'currency' => $code,
            'amount' => $this->safe_number($transfer, 'amount'),
            'fromAccount' => $fromAccount,
            'toAccount' => $toAccount,
            'status' => $this->parse_transfer_status($this->safe_string($transfer, 'status', $status)),
            'info' => $transfer,
        );
    }

    public function parse_transfer_status($status) {
        $statuses = array(
            'NEW' => 'pending',
            'CONFIRMING' => 'pending',
            'PROCESSING' => 'pending',
            'COMPLETED' => 'ok',
            'CANCELED' => 'canceled',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function nonce() {
        return $this->milliseconds();
    }

    public function sign($path, $section = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $version = $section[0];
        $access = $section[1];
        $url = $this->implode_hostname($this->urls['api'][$access]);
        $url .= '/' . $version . '/';
        $path = $this->implode_params($path, $params);
        $params = $this->omit($params, $this->extract_params($path));
        $params = $this->keysort($params);
        if ($access === 'public') {
            $url .= $access . '/' . $path;
            if ($params) {
                $url .= '?' . $this->urlencode($params);
            }
        } else {
            $this->check_required_credentials();
            $url .= $path;
            $ts = (string) $this->nonce();
            $auth = $this->urlencode($params);
            if ($method === 'POST' || $method === 'DELETE') {
                $body = $auth;
            } else {
                $url .= '?' . $auth;
            }
            $auth .= '|' . $ts;
            $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256');
            $headers = array(
                'x-api-key' => $this->apiKey,
                'x-api-signature' => $signature,
                'x-api-timestamp' => $ts,
                'Content-Type' => 'application/x-www-form-urlencoded',
            );
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($httpCode, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if (!$response) {
            return; // fallback to default error handler
        }
        //
        //     400 Bad Request array("success":false,"code":-1012,"message":"Amount is required for buy market orders when margin disabled.")
        //
        $success = $this->safe_value($response, 'success');
        $errorCode = $this->safe_string($response, 'code');
        if (!$success) {
            $feedback = $this->id . ' ' . $this->json($response);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $body, $feedback);
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
        }
    }

    public function default_network_code_for_currency($code) {
        // at first, try to find if user or exchange has defined default $networks for the specific currency
        $defaultNetworkCodeForCurrencies = $this->safe_value($this->options, 'defaultNetworkCodeForCurrencies');
        if ($defaultNetworkCodeForCurrencies !== null) {
            $defaultNetworkCode = $this->safe_string_upper($defaultNetworkCodeForCurrencies, $code);
            if ($defaultNetworkCode !== null) {
                return $defaultNetworkCode;
            }
        }
        // if not found by above 'defaultNetworkCodeForCurrencies' for specific currency, then try with `$defaultNetworkCodePriorities`
        $currencyItem = $this->currency($code);
        $networks = $currencyItem['networks'];
        $defaultNetworkCodePriorities = $this->safe_value($this->options, 'defaultNetworkCodePriorities');
        if ($defaultNetworkCodePriorities !== null) {
            // itterate according to priority $networks
            $networksKeys = is_array($networks) ? array_keys($networks) : array();
            $networksKeysLength = is_array($networksKeys) ? count($networksKeys) : 0;
            if ($networksKeysLength > 0) {
                for ($i = 0; $i < count($defaultNetworkCodePriorities); $i++) {
                    $networkCode = $defaultNetworkCodePriorities[$i];
                    if (is_array($networks) && array_key_exists($networkCode, $networks)) {
                        return $networkCode;
                    }
                }
            }
        }
        // if it was not returned according to above options, then return the first network of currency
        $networkKeys = is_array($networks) ? array_keys($networks) : array();
        return $this->safe_value($networkKeys, 0);
    }
}
