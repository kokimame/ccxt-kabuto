<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\ArgumentsRequired;
use \ccxt\BadRequest;
use \ccxt\BadSymbol;
use \ccxt\InvalidAddress;
use \ccxt\InvalidOrder;
use \ccxt\NotSupported;
use \ccxt\NetworkError;
use \ccxt\Precise;

class huobi extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'huobi',
            'name' => 'Huobi',
            'countries' => array( 'CN' ),
            'rateLimit' => 100,
            'userAgent' => $this->userAgents['chrome100'],
            'certified' => true,
            'version' => 'v1',
            'accounts' => null,
            'accountsById' => null,
            'hostname' => 'api.huobi.pro', // api.testnet.huobi.pro
            'pro' => true,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => true,
                'swap' => true,
                'future' => true,
                'option' => null,
                'addMargin' => null,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'cancelOrders' => true,
                'createDepositAddress' => null,
                'createOrder' => true,
                'createReduceOnlyOrder' => false,
                'createStopLimitOrder' => true,
                'createStopMarketOrder' => true,
                'createStopOrder' => true,
                'fetchAccounts' => true,
                'fetchBalance' => true,
                'fetchBidsAsks' => null,
                'fetchBorrowInterest' => true,
                'fetchBorrowRate' => null,
                'fetchBorrowRateHistories' => null,
                'fetchBorrowRateHistory' => null,
                'fetchBorrowRates' => true,
                'fetchBorrowRatesPerSymbol' => true,
                'fetchCanceledOrders' => null,
                'fetchClosedOrder' => null,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => true,
                'fetchDeposit' => null,
                'fetchDepositAddress' => true,
                'fetchDepositAddresses' => null,
                'fetchDepositAddressesByNetwork' => true,
                'fetchDeposits' => true,
                'fetchFundingHistory' => true,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => true,
                'fetchFundingRates' => true,
                'fetchIndexOHLCV' => true,
                'fetchL3OrderBook' => null,
                'fetchLedger' => true,
                'fetchLedgerEntry' => null,
                'fetchLeverage' => false,
                'fetchLeverageTiers' => true,
                'fetchMarketLeverageTiers' => true,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => true,
                'fetchMyBuys' => null,
                'fetchMySells' => null,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterestHistory' => true,
                'fetchOpenOrder' => null,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrderBooks' => null,
                'fetchOrders' => true,
                'fetchOrderTrades' => true,
                'fetchPosition' => true,
                'fetchPositions' => true,
                'fetchPositionsRisk' => false,
                'fetchPremiumIndexOHLCV' => true,
                'fetchStatus' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => true,
                'fetchTradingFees' => false,
                'fetchTradingLimits' => true,
                'fetchTransactionFee' => null,
                'fetchTransactionFees' => null,
                'fetchTransactions' => null,
                'fetchTransfers' => null,
                'fetchWithdrawAddressesByNetwork' => true,
                'fetchWithdrawal' => null,
                'fetchWithdrawals' => true,
                'fetchWithdrawalWhitelist' => null,
                'reduceMargin' => null,
                'setLeverage' => true,
                'setMarginMode' => false,
                'setPositionMode' => false,
                'signIn' => null,
                'transfer' => true,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1min',
                '5m' => '5min',
                '15m' => '15min',
                '30m' => '30min',
                '1h' => '60min',
                '4h' => '4hour',
                '1d' => '1day',
                '1w' => '1week',
                '1M' => '1mon',
                '1y' => '1year',
            ),
            'urls' => array(
                // 'test' => array(
                //     'market' => 'https://api.testnet.huobi.pro',
                //     'public' => 'https://api.testnet.huobi.pro',
                //     'private' => 'https://api.testnet.huobi.pro',
                // ),
                'logo' => 'https://user-images.githubusercontent.com/1294454/76137448-22748a80-604e-11ea-8069-6e389271911d.jpg',
                'hostnames' => array(
                    'contract' => 'api.hbdm.com',
                    'spot' => 'api.huobi.pro',
                    'status' => array(
                        'spot' => 'status.huobigroup.com',
                        'future' => array(
                            'inverse' => 'status-dm.huobigroup.com',
                            'linear' => 'status-linear-swap.huobigroup.com', // USDT-Margined Contracts
                        ),
                        'swap' => array(
                            'inverse' => 'status-swap.huobigroup.com',
                            'linear' => 'status-linear-swap.huobigroup.com', // USDT-Margined Contracts
                        ),
                    ),
                    // recommended for AWS
                    // 'contract' => 'api.hbdm.vn',
                    // 'spot' => 'api-aws.huobi.pro',
                ),
                'api' => array(
                    'status' => 'https://{hostname}',
                    'contract' => 'https://{hostname}',
                    'spot' => 'https://{hostname}',
                    'market' => 'https://{hostname}',
                    'public' => 'https://{hostname}',
                    'private' => 'https://{hostname}',
                    'v2Public' => 'https://{hostname}',
                    'v2Private' => 'https://{hostname}',
                ),
                'www' => 'https://www.huobi.com',
                'referral' => array(
                    'url' => 'https://www.huobi.com/en-us/topic/double-reward/?invite_code=6rmm2223',
                    'discount' => 0.15,
                ),
                'doc' => array(
                    'https://huobiapi.github.io/docs/spot/v1/cn/',
                    'https://huobiapi.github.io/docs/dm/v1/cn/',
                    'https://huobiapi.github.io/docs/coin_margined_swap/v1/cn/',
                    'https://huobiapi.github.io/docs/usdt_swap/v1/cn/',
                    'https://huobiapi.github.io/docs/option/v1/cn/',
                ),
                'fees' => 'https://www.huobi.com/about/fee/',
            ),
            'api' => array(
                // ------------------------------------------------------------
                // old api definitions
                'v2Public' => array(
                    'get' => array(
                        'reference/currencies' => 1, // 币链参考信息
                        'market-status' => 1, // 获取当前市场状态
                    ),
                ),
                'v2Private' => array(
                    'get' => array(
                        'account/ledger' => 1,
                        'account/withdraw/quota' => 1,
                        'account/withdraw/address' => 1, // 提币地址查询(限母用户可用)
                        'account/deposit/address' => 1,
                        'account/repayment' => 5, // 还币交易记录查询
                        'reference/transact-fee-rate' => 1,
                        'account/asset-valuation' => 0.2, // 获取账户资产估值
                        'point/account' => 5, // 点卡余额查询
                        'sub-user/user-list' => 1, // 获取子用户列表
                        'sub-user/user-state' => 1, // 获取特定子用户的用户状态
                        'sub-user/account-list' => 1, // 获取特定子用户的账户列表
                        'sub-user/deposit-address' => 1, // 子用户充币地址查询
                        'sub-user/query-deposit' => 1, // 子用户充币记录查询
                        'user/api-key' => 1, // 母子用户API key信息查询
                        'user/uid' => 1, // 母子用户获取用户UID
                        'algo-orders/opening' => 1, // 查询未触发OPEN策略委托
                        'algo-orders/history' => 1, // 查询策略委托历史
                        'algo-orders/specific' => 1, // 查询特定策略委托
                        'c2c/offers' => 1, // 查询借入借出订单
                        'c2c/offer' => 1, // 查询特定借入借出订单及其交易记录
                        'c2c/transactions' => 1, // 查询借入借出交易记录
                        'c2c/repayment' => 1, // 查询还币交易记录
                        'c2c/account' => 1, // 查询账户余额
                        'etp/reference' => 1, // 基础参考信息
                        'etp/transactions' => 5, // 获取杠杆ETP申赎记录
                        'etp/transaction' => 5, // 获取特定杠杆ETP申赎记录
                        'etp/rebalance' => 1, // 获取杠杆ETP调仓记录
                        'etp/limit' => 1, // 获取ETP持仓限额
                    ),
                    'post' => array(
                        'account/transfer' => 1,
                        'account/repayment' => 5, // 归还借币（全仓逐仓通用）
                        'point/transfer' => 5, // 点卡划转
                        'sub-user/management' => 1, // 冻结/解冻子用户
                        'sub-user/creation' => 1, // 子用户创建
                        'sub-user/tradable-market' => 1, // 设置子用户交易权限
                        'sub-user/transferability' => 1, // 设置子用户资产转出权限
                        'sub-user/api-key-generation' => 1, // 子用户API key创建
                        'sub-user/api-key-modification' => 1, // 修改子用户API key
                        'sub-user/api-key-deletion' => 1, // 删除子用户API key
                        'sub-user/deduct-mode' => 1, // 设置子用户手续费抵扣模式
                        'algo-orders' => 1, // 策略委托下单
                        'algo-orders/cancel-all-after' => 1, // 自动撤销订单
                        'algo-orders/cancellation' => 1, // 策略委托（触发前）撤单
                        'c2c/offer' => 1, // 借入借出下单
                        'c2c/cancellation' => 1, // 借入借出撤单
                        'c2c/cancel-all' => 1, // 撤销所有借入借出订单
                        'c2c/repayment' => 1, // 还币
                        'c2c/transfer' => 1, // 资产划转
                        'etp/creation' => 5, // 杠杆ETP换入
                        'etp/redemption' => 5, // 杠杆ETP换出
                        'etp/{transactId}/cancel' => 10, // 杠杆ETP单个撤单
                        'etp/batch-cancel' => 50, // 杠杆ETP批量撤单
                    ),
                ),
                'market' => array(
                    'get' => array(
                        'history/kline' => 1, // 获取K线数据
                        'detail/merged' => 1, // 获取聚合行情(Ticker)
                        'depth' => 1, // 获取 Market Depth 数据
                        'trade' => 1, // 获取 Trade Detail 数据
                        'history/trade' => 1, // 批量获取最近的交易记录
                        'detail' => 1, // 获取 Market Detail 24小时成交量数据
                        'tickers' => 1,
                        'etp' => 1, // 获取杠杆ETP实时净值
                    ),
                ),
                'public' => array(
                    'get' => array(
                        'common/symbols' => 1, // 查询系统支持的所有交易对
                        'common/currencys' => 1, // 查询系统支持的所有币种
                        'common/timestamp' => 1, // 查询系统当前时间
                        'common/exchange' => 1, // order limits
                        'settings/currencys' => 1, // ?language=en-US
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'account/accounts' => 0.2, // 查询当前用户的所有账户(即account-id)
                        'account/accounts/{id}/balance' => 0.2, // 查询指定账户的余额
                        'account/accounts/{sub-uid}' => 1,
                        'account/history' => 4,
                        'cross-margin/loan-info' => 1,
                        'margin/loan-info' => 1, // 查询借币币息率及额度
                        'fee/fee-rate/get' => 1,
                        'order/openOrders' => 0.4,
                        'order/orders' => 0.4,
                        'order/orders/{id}' => 0.4, // 查询某个订单详情
                        'order/orders/{id}/matchresults' => 0.4, // 查询某个订单的成交明细
                        'order/orders/getClientOrder' => 0.4,
                        'order/history' => 1, // 查询当前委托、历史委托
                        'order/matchresults' => 1, // 查询当前成交、历史成交
                        // 'dw/withdraw-virtual/addresses', // 查询虚拟币提现地址（Deprecated）
                        'query/deposit-withdraw' => 1,
                        // 'margin/loan-info', // duplicate
                        'margin/loan-orders' => 0.2, // 借贷订单
                        'margin/accounts/balance' => 0.2, // 借贷账户详情
                        'cross-margin/loan-orders' => 1, // 查询借币订单
                        'cross-margin/accounts/balance' => 1, // 借币账户详情
                        'points/actions' => 1,
                        'points/orders' => 1,
                        'subuser/aggregate-balance' => 10,
                        'stable-coin/exchange_rate' => 1,
                        'stable-coin/quote' => 1,
                    ),
                    'post' => array(
                        'account/transfer' => 1, // 资产划转(该节点为母用户和子用户进行资产划转的通用接口。)
                        'futures/transfer' => 1,
                        'order/batch-orders' => 0.4,
                        'order/orders/place' => 0.2, // 创建并执行一个新订单 (一步下单， 推荐使用)
                        'order/orders/submitCancelClientOrder' => 0.2,
                        'order/orders/batchCancelOpenOrders' => 0.4,
                        // 'order/orders', // 创建一个新的订单请求 （仅创建订单，不执行下单）
                        // 'order/orders/{id}/place', // 执行一个订单 （仅执行已创建的订单）
                        'order/orders/{id}/submitcancel' => 0.2, // 申请撤销一个订单请求
                        'order/orders/batchcancel' => 0.4, // 批量撤销订单
                        // 'dw/balance/transfer', // 资产划转
                        'dw/withdraw/api/create' => 1, // 申请提现虚拟币
                        // 'dw/withdraw-virtual/create', // 申请提现虚拟币
                        // 'dw/withdraw-virtual/{id}/place', // 确认申请虚拟币提现（Deprecated）
                        'dw/withdraw-virtual/{id}/cancel' => 1, // 申请取消提现虚拟币
                        'dw/transfer-in/margin' => 10, // 现货账户划入至借贷账户
                        'dw/transfer-out/margin' => 10, // 借贷账户划出至现货账户
                        'margin/orders' => 10, // 申请借贷
                        'margin/orders/{id}/repay' => 10, // 归还借贷
                        'cross-margin/transfer-in' => 1, // 资产划转
                        'cross-margin/transfer-out' => 1, // 资产划转
                        'cross-margin/orders' => 1, // 申请借币
                        'cross-margin/orders/{id}/repay' => 1, // 归还借币
                        'stable-coin/exchange' => 1,
                        'subuser/transfer' => 10,
                    ),
                ),
                // ------------------------------------------------------------
                // new api definitions
                // 'https://status.huobigroup.com/api/v2/summary.json' => 1,
                // 'https://status-dm.huobigroup.com/api/v2/summary.json' => 1,
                // 'https://status-swap.huobigroup.com/api/v2/summary.json' => 1,
                // 'https://status-linear-swap.huobigroup.com/api/v2/summary.json' => 1,
                'status' => array(
                    'public' => array(
                        'spot' => array(
                            'get' => array(
                                'api/v2/summary.json' => 1,
                            ),
                        ),
                        'future' => array(
                            'inverse' => array(
                                'get' => array(
                                    'api/v2/summary.json' => 1,
                                ),
                            ),
                            'linear' => array(
                                'get' => array(
                                    'api/v2/summary.json' => 1,
                                ),
                            ),
                        ),
                        'swap' => array(
                            'inverse' => array(
                                'get' => array(
                                    'api/v2/summary.json' => 1,
                                ),
                            ),
                            'linear' => array(
                                'get' => array(
                                    'api/v2/summary.json' => 1,
                                ),
                            ),
                        ),
                    ),
                ),
                'spot' => array(
                    'public' => array(
                        'get' => array(
                            'v2/market-status' => 1,
                            'v1/common/symbols' => 1,
                            'v1/common/currencys' => 1,
                            'v2/reference/currencies' => 1,
                            'v1/common/timestamp' => 1,
                            'v1/common/exchange' => 1, // order limits
                            // Market Data
                            'market/history/candles' => 1,
                            'market/history/kline' => 1,
                            'market/detail/merged' => 1,
                            'market/tickers' => 1,
                            'market/depth' => 1,
                            'market/trade' => 1,
                            'market/history/trade' => 1,
                            'market/detail/' => 1,
                            'market/etp' => 1,
                            // ETP
                            'v2/etp/reference' => 1,
                            'v2/etp/rebalance' => 1,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            // Account
                            'v1/account/accounts' => 0.2,
                            'v1/account/accounts/{account-id}/balance' => 0.2,
                            'v2/account/valuation' => 1,
                            'v2/account/asset-valuation' => 0.2,
                            'v1/account/history' => 4,
                            'v2/account/ledger' => 1,
                            'v2/point/account' => 5,
                            // Wallet (Deposit and Withdraw)
                            'v2/account/deposit/address' => 1,
                            'v2/account/withdraw/quota' => 1,
                            'v2/account/withdraw/address' => 1,
                            'v2/reference/currencies' => 1,
                            'v1/query/deposit-withdraw' => 1,
                            // Sub user management
                            'v2/user/api-key' => 1,
                            'v2/user/uid' => 1,
                            'v2/sub-user/user-list' => 1,
                            'v2/sub-user/user-state' => 1,
                            'v2/sub-user/account-list' => 1,
                            'v2/sub-user/deposit-address' => 1,
                            'v2/sub-user/query-deposit' => 1,
                            'v1/subuser/aggregate-balance' => 10,
                            'v1/account/accounts/{sub-uid}' => 1,
                            // Trading
                            'v1/order/openOrders' => 0.4,
                            'v1/order/orders/{order-id}' => 0.4,
                            'v1/order/orders/getClientOrder' => 0.4,
                            'v1/order/orders/{order-id}/matchresults' => 0.4,
                            'v1/order/orders' => 0.4,
                            'v1/order/history' => 1,
                            'v1/order/matchresults' => 1,
                            'v2/reference/transact-fee-rate' => 1,
                            // Conditional Order
                            'v2/algo-orders/opening' => 1,
                            'v2/algo-orders/history' => 1,
                            'v2/algo-orders/specific' => 1,
                            // Margin Loan (Cross/Isolated)
                            'v1/margin/loan-info' => 1,
                            'v1/margin/loan-orders' => 0.2,
                            'v1/margin/accounts/balance' => 0.2,
                            'v1/cross-margin/loan-info' => 1,
                            'v1/cross-margin/loan-orders' => 1,
                            'v1/cross-margin/accounts/balance' => 1,
                            'v2/account/repayment' => 5,
                            // Stable Coin Exchange
                            'v1/stable-coin/quote' => 1,
                            // ETP
                            'v2/etp/transactions' => 5,
                            'v2/etp/transaction' => 5,
                            'v2/etp/limit' => 1,
                        ),
                        'post' => array(
                            // Account
                            'v1/account/transfer' => 1,
                            'v1/futures/transfer' => 1, // future transfers
                            'v2/point/transfer' => 5,
                            'v2/account/transfer' => 1, // swap transfers
                            // Wallet (Deposit and Withdraw)
                            'v1/dw/withdraw/api/create' => 1,
                            'v1/dw/withdraw-virtual/{withdraw-id}/cancel' => 1,
                            // Sub user management
                            'v2/sub-user/deduct-mode' => 1,
                            'v2/sub-user/creation' => 1,
                            'v2/sub-user/management' => 1,
                            'v2/sub-user/tradable-market' => 1,
                            'v2/sub-user/transferability' => 1,
                            'v2/sub-user/api-key-generation' => 1,
                            'v2/sub-user/api-key-modification' => 1,
                            'v2/sub-user/api-key-deletion' => 1,
                            'v1/subuser/transfer' => 10,
                            // Trading
                            'v1/order/orders/place' => 0.2,
                            'v1/order/batch-orders' => 0.4,
                            'v1/order/orders/{order-id}/submitcancel' => 0.2,
                            'v1/order/orders/submitCancelClientOrder' => 0.2,
                            'v1/order/orders/batchCancelOpenOrders' => 0.4,
                            'v1/order/orders/batchcancel' => 0.4,
                            'v2/algo-orders/cancel-all-after' => 1,
                            // Conditional Order
                            'v2/algo-orders' => 1,
                            'v2/algo-orders/cancellation' => 1,
                            // Margin Loan (Cross/Isolated)
                            'v2/account/repayment' => 5,
                            'v1/dw/transfer-in/margin' => 10,
                            'v1/dw/transfer-out/margin' => 10,
                            'v1/margin/orders' => 10,
                            'v1/margin/orders/{order-id}/repay' => 10,
                            'v1/cross-margin/transfer-in' => 1,
                            'v1/cross-margin/transfer-out' => 1,
                            'v1/cross-margin/orders' => 1,
                            'v1/cross-margin/orders/{order-id}/repay' => 1,
                            // Stable Coin Exchange
                            'v1/stable-coin/exchange' => 1,
                            // ETP
                            'v2/etp/creation' => 5,
                            'v2/etp/redemption' => 5,
                            'v2/etp/{transactId}/cancel' => 10,
                            'v2/etp/batch-cancel' => 50,
                        ),
                    ),
                ),
                'contract' => array(
                    'public' => array(
                        'get' => array(
                            'api/v1/timestamp' => 1,
                            'heartbeat/' => 1, // backslash is not a typo
                            // Future Market Data interface
                            'api/v1/contract_contract_info' => 1,
                            'api/v1/contract_index' => 1,
                            'api/v1/contract_price_limit' => 1,
                            'api/v1/contract_open_interest' => 1,
                            'api/v1/contract_delivery_price' => 1,
                            'market/depth' => 1,
                            'market/bbo' => 1,
                            'market/history/kline' => 1,
                            'index/market/history/mark_price_kline' => 1,
                            'market/detail/merged' => 1,
                            'market/detail/batch_merged' => 1,
                            'market/trade' => 1,
                            'market/history/trade' => 1,
                            'api/v1/contract_risk_info' => 1,
                            'api/v1/contract_insurance_fund' => 1,
                            'api/v1/contract_adjustfactor' => 1,
                            'api/v1/contract_his_open_interest' => 1,
                            'api/v1/contract_ladder_margin' => 1,
                            'api/v1/contract_api_state' => 1,
                            'api/v1/contract_elite_account_ratio' => 1,
                            'api/v1/contract_elite_position_ratio' => 1,
                            'api/v1/contract_liquidation_orders' => 1,
                            'api/v1/contract_settlement_records' => 1,
                            'index/market/history/index' => 1,
                            'index/market/history/basis' => 1,
                            'api/v1/contract_estimated_settlement_price' => 1,
                            // Swap Market Data interface
                            'swap-api/v1/swap_contract_info' => 1,
                            'swap-api/v1/swap_index' => 1,
                            'swap-api/v1/swap_price_limit' => 1,
                            'swap-api/v1/swap_open_interest' => 1,
                            'swap-ex/market/depth' => 1,
                            'swap-ex/market/bbo' => 1,
                            'swap-ex/market/history/kline' => 1,
                            'index/market/history/swap_mark_price_kline' => 1,
                            'swap-ex/market/detail/merged' => 1,
                            'swap-ex/market/detail/batch_merged' => 1,
                            'swap-ex/market/trade' => 1,
                            'swap-ex/market/history/trade' => 1,
                            'swap-api/v1/swap_risk_info' => 1,
                            'swap-api/v1/swap_insurance_fund' => 1,
                            'swap-api/v1/swap_adjustfactor' => 1,
                            'swap-api/v1/swap_his_open_interest' => 1,
                            'swap-api/v1/swap_ladder_margin' => 1,
                            'swap-api/v1/swap_api_state' => 1,
                            'swap-api/v1/swap_elite_account_ratio' => 1,
                            'swap-api/v1/swap_elite_position_ratio' => 1,
                            'swap-api/v1/swap_estimated_settlement_price' => 1,
                            'swap-api/v1/swap_liquidation_orders' => 1,
                            'swap-api/v1/swap_settlement_records' => 1,
                            'swap-api/v1/swap_funding_rate' => 1,
                            'swap-api/v1/swap_batch_funding_rate' => 1,
                            'swap-api/v1/swap_historical_funding_rate' => 1,
                            'index/market/history/swap_premium_index_kline' => 1,
                            'index/market/history/swap_estimated_rate_kline' => 1,
                            'index/market/history/swap_basis' => 1,
                            // Swap Market Data interface
                            'linear-swap-api/v1/swap_contract_info' => 1,
                            'linear-swap-api/v1/swap_index' => 1,
                            'linear-swap-api/v1/swap_price_limit' => 1,
                            'linear-swap-api/v1/swap_open_interest' => 1,
                            'linear-swap-ex/market/depth' => 1,
                            'linear-swap-ex/market/bbo' => 1,
                            'linear-swap-ex/market/history/kline' => 1,
                            'index/market/history/linear_swap_mark_price_kline' => 1,
                            'linear-swap-ex/market/detail/merged' => 1,
                            'linear-swap-ex/market/detail/batch_merged' => 1,
                            'linear-swap-ex/market/trade' => 1,
                            'linear-swap-ex/market/history/trade' => 1,
                            'linear-swap-api/v1/swap_risk_info' => 1,
                            'swap-api/v1/linear-swap-api/v1/swap_insurance_fund' => 1,
                            'linear-swap-api/v1/swap_adjustfactor' => 1,
                            'linear-swap-api/v1/swap_cross_adjustfactor' => 1,
                            'linear-swap-api/v1/swap_his_open_interest' => 1,
                            'linear-swap-api/v1/swap_ladder_margin' => 1,
                            'linear-swap-api/v1/swap_cross_ladder_margin' => 1,
                            'linear-swap-api/v1/swap_api_state' => 1,
                            'linear-swap-api/v1/swap_cross_transfer_state' => 1,
                            'linear-swap-api/v1/swap_cross_trade_state' => 1,
                            'linear-swap-api/v1/swap_elite_account_ratio' => 1,
                            'linear-swap-api/v1/swap_elite_position_ratio' => 1,
                            'linear-swap-api/v1/swap_liquidation_orders' => 1,
                            'linear-swap-api/v1/swap_settlement_records' => 1,
                            'linear-swap-api/v1/swap_funding_rate' => 1,
                            'linear-swap-api/v1/swap_batch_funding_rate' => 1,
                            'linear-swap-api/v1/swap_historical_funding_rate' => 1,
                            'index/market/history/linear_swap_premium_index_kline' => 1,
                            'index/market/history/linear_swap_estimated_rate_kline' => 1,
                            'index/market/history/linear_swap_basis' => 1,
                            'linear-swap-api/v1/swap_estimated_settlement_price' => 1,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            // Future Account Interface
                            'api/v1/contract_api_trading_status' => 1,
                            // Swap Account Interface
                            'swap-api/v1/swap_api_trading_status' => 1,
                            // Swap Account Interface
                            'linear-swap-api/v1/swap_api_trading_status' => 1,
                        ),
                        'post' => array(
                            // Future Account Interface
                            'api/v1/contract_balance_valuation' => 1,
                            'api/v1/contract_account_info' => 1,
                            'api/v1/contract_position_info' => 1,
                            'api/v1/contract_sub_auth' => 1,
                            'api/v1/contract_sub_account_list' => 1,
                            'api/v1/contract_sub_account_info_list' => 1,
                            'api/v1/contract_sub_account_info' => 1,
                            'api/v1/contract_sub_position_info' => 1,
                            'api/v1/contract_financial_record' => 1,
                            'api/v1/contract_financial_record_exact' => 1,
                            'api/v1/contract_user_settlement_records' => 1,
                            'api/v1/contract_order_limit' => 1,
                            'api/v1/contract_fee' => 1,
                            'api/v1/contract_transfer_limit' => 1,
                            'api/v1/contract_position_limit' => 1,
                            'api/v1/contract_account_position_info' => 1,
                            'api/v1/contract_master_sub_transfer' => 1,
                            'api/v1/contract_master_sub_transfer_record' => 1,
                            'api/v1/contract_available_level_rate' => 1,
                            // Future Trade Interface
                            'api/v1/contract_order' => 1,
                            'v1/contract_batchorder' => 1,
                            'api/v1/contract_cancel' => 1,
                            'api/v1/contract_cancelall' => 1,
                            'api/v1/contract_switch_lever_rate' => 1,
                            'api/v1/lightning_close_position' => 1,
                            'api/v1/contract_order_info' => 1,
                            'api/v1/contract_order_detail' => 1,
                            'api/v1/contract_openorders' => 1,
                            'api/v1/contract_hisorders' => 1,
                            'api/v1/contract_hisorders_exact' => 1,
                            'api/v1/contract_matchresults' => 1,
                            'api/v1/contract_matchresults_exact' => 1,
                            // Contract Strategy Order Interface
                            'api/v1/contract_trigger_order' => 1,
                            'api/v1/contract_trigger_cancel' => 1,
                            'api/v1/contract_trigger_cancelall' => 1,
                            'api/v1/contract_trigger_openorders' => 1,
                            'api/v1/contract_trigger_hisorders' => 1,
                            'api/v1/contract_tpsl_order' => 1,
                            'api/v1/contract_tpsl_cancel' => 1,
                            'api/v1/contract_tpsl_cancelall' => 1,
                            'api/v1/contract_tpsl_openorders' => 1,
                            'api/v1/contract_tpsl_hisorders' => 1,
                            'api/v1/contract_relation_tpsl_order' => 1,
                            'api/v1/contract_track_order' => 1,
                            'api/v1/contract_track_cancel' => 1,
                            'api/v1/contract_track_cancelall' => 1,
                            'api/v1/contract_track_openorders' => 1,
                            'api/v1/contract_track_hisorders' => 1,
                            // Swap Account Interface
                            'swap-api/v1/swap_balance_valuation' => 1,
                            'swap-api/v1/swap_account_info' => 1,
                            'swap-api/v1/swap_position_info' => 1,
                            'swap-api/v1/swap_account_position_info' => 1,
                            'swap-api/v1/swap_sub_auth' => 1,
                            'swap-api/v1/swap_sub_account_list' => 1,
                            'swap-api/v1/swap_sub_account_info_list' => 1,
                            'swap-api/v1/swap_sub_account_info' => 1,
                            'swap-api/v1/swap_sub_position_info' => 1,
                            'swap-api/v1/swap_financial_record' => 1,
                            'swap-api/v1/swap_financial_record_exact' => 1,
                            'swap-api/v1/swap_user_settlement_records' => 1,
                            'swap-api/v1/swap_available_level_rate' => 1,
                            'swap-api/v1/swap_order_limit' => 1,
                            'swap-api/v1/swap_fee' => 1,
                            'swap-api/v1/swap_transfer_limit' => 1,
                            'swap-api/v1/swap_position_limit' => 1,
                            'swap-api/v1/swap_master_sub_transfer' => 1,
                            'swap-api/v1/swap_master_sub_transfer_record' => 1,
                            // Swap Trade Interface
                            'swap-api/v1/swap_order' => 1,
                            'swap-api/v1/swap_batchorder' => 1,
                            'swap-api/v1/swap_cancel' => 1,
                            'swap-api/v1/swap_cancelall' => 1,
                            'swap-api/v1/swap_lightning_close_position' => 1,
                            'swap-api/v1/swap_switch_lever_rate' => 1,
                            'swap-api/v1/swap_order_info' => 1,
                            'swap-api/v1/swap_order_detail' => 1,
                            'swap-api/v1/swap_openorders' => 1,
                            'swap-api/v1/swap_hisorders' => 1,
                            'swap-api/v1/swap_hisorders_exact' => 1,
                            'swap-api/v1/swap_matchresults' => 1,
                            'swap-api/v1/swap_matchresults_exact' => 1,
                            // Swap Strategy Order Interface
                            'swap-api/v1/swap_trigger_order' => 1,
                            'swap-api/v1/swap_trigger_cancel' => 1,
                            'swap-api/v1/swap_trigger_cancelall' => 1,
                            'swap-api/v1/swap_trigger_openorders' => 1,
                            'swap-api/v1/swap_trigger_hisorders' => 1,
                            'swap-api/v1/swap_tpsl_order' => 1,
                            'swap-api/v1/swap_tpsl_cancel' => 1,
                            'swap-api/v1/swap_tpsl_cancelall' => 1,
                            'swap-api/v1/swap_tpsl_openorders' => 1,
                            'swap-api/v1/swap_tpsl_hisorders' => 1,
                            'swap-api/v1/swap_relation_tpsl_order' => 1,
                            'swap-api/v1/swap_track_order' => 1,
                            'swap-api/v1/swap_track_cancel' => 1,
                            'swap-api/v1/swap_track_cancelall' => 1,
                            'swap-api/v1/swap_track_openorders' => 1,
                            'swap-api/v1/swap_track_hisorders' => 1,
                            // Swap Account Interface
                            'linear-swap-api/v1/swap_lever_position_limit' => 1,
                            'linear-swap-api/v1/swap_cross_lever_position_limit' => 1,
                            'linear-swap-api/v1/swap_balance_valuation' => 1,
                            'linear-swap-api/v1/swap_account_info' => 1,
                            'linear-swap-api/v1/swap_cross_account_info' => 1,
                            'linear-swap-api/v1/swap_position_info' => 1,
                            'linear-swap-api/v1/swap_cross_position_info' => 1,
                            'linear-swap-api/v1/swap_account_position_info' => 1,
                            'linear-swap-api/v1/swap_cross_account_position_info' => 1,
                            'linear-swap-api/v1/swap_sub_auth' => 1,
                            'linear-swap-api/v1/swap_sub_account_list' => 1,
                            'linear-swap-api/v1/swap_cross_sub_account_list' => 1,
                            'linear-swap-api/v1/swap_sub_account_info_list' => 1,
                            'linear-swap-api/v1/swap_cross_sub_account_info_list' => 1,
                            'linear-swap-api/v1/swap_sub_account_info' => 1,
                            'linear-swap-api/v1/swap_cross_sub_account_info' => 1,
                            'linear-swap-api/v1/swap_sub_position_info' => 1,
                            'linear-swap-api/v1/swap_cross_sub_position_info' => 1,
                            'linear-swap-api/v1/swap_financial_record' => 1,
                            'linear-swap-api/v1/swap_financial_record_exact' => 1,
                            'linear-swap-api/v1/swap_user_settlement_records' => 1,
                            'linear-swap-api/v1/swap_cross_user_settlement_records' => 1,
                            'linear-swap-api/v1/swap_available_level_rate' => 1,
                            'linear-swap-api/v1/swap_cross_available_level_rate' => 1,
                            'linear-swap-api/v1/swap_order_limit' => 1,
                            'linear-swap-api/v1/swap_fee' => 1,
                            'linear-swap-api/v1/swap_transfer_limit' => 1,
                            'linear-swap-api/v1/swap_cross_transfer_limit' => 1,
                            'linear-swap-api/v1/swap_position_limit' => 1,
                            'linear-swap-api/v1/swap_cross_position_limit' => 1,
                            'linear-swap-api/v1/swap_master_sub_transfer' => 1,
                            'linear-swap-api/v1/swap_master_sub_transfer_record' => 1,
                            'linear-swap-api/v1/swap_transfer_inner' => 1,
                            // Swap Trade Interface
                            'linear-swap-api/v1/swap_order' => 1,
                            'linear-swap-api/v1/swap_cross_order' => 1,
                            'linear-swap-api/v1/swap_batchorder' => 1,
                            'linear-swap-api/v1/swap_cross_batchorder' => 1,
                            'linear-swap-api/v1/swap_cancel' => 1,
                            'linear-swap-api/v1/swap_cross_cancel' => 1,
                            'linear-swap-api/v1/swap_cancelall' => 1,
                            'linear-swap-api/v1/swap_cross_cancelall' => 1,
                            'linear-swap-api/v1/swap_switch_lever_rate' => 1,
                            'linear-swap-api/v1/swap_cross_switch_lever_rate' => 1,
                            'linear-swap-api/v1/swap_lightning_close_position' => 1,
                            'linear-swap-api/v1/swap_cross_lightning_close_position' => 1,
                            'linear-swap-api/v1/swap_order_info' => 1,
                            'linear-swap-api/v1/swap_cross_order_info' => 1,
                            'linear-swap-api/v1/swap_order_detail' => 1,
                            'linear-swap-api/v1/swap_cross_order_detail' => 1,
                            'linear-swap-api/v1/swap_openorders' => 1,
                            'linear-swap-api/v1/swap_cross_openorders' => 1,
                            'linear-swap-api/v1/swap_hisorders' => 1,
                            'linear-swap-api/v1/swap_cross_hisorders' => 1,
                            'linear-swap-api/v1/swap_hisorders_exact' => 1,
                            'linear-swap-api/v1/swap_cross_hisorders_exact' => 1,
                            'linear-swap-api/v1/swap_matchresults' => 1,
                            'linear-swap-api/v1/swap_cross_matchresults' => 1,
                            'linear-swap-api/v1/swap_matchresults_exact' => 1,
                            'linear-swap-api/v1/swap_cross_matchresults_exact' => 1,
                            'linear-swap-api/v1/swap_switch_position_mode' => 1,
                            'linear-swap-api/v1/swap_cross_switch_position_mode' => 1,
                            // Swap Strategy Order Interface
                            'linear-swap-api/v1/swap_trigger_order' => 1,
                            'linear-swap-api/v1/swap_cross_trigger_order' => 1,
                            'linear-swap-api/v1/swap_trigger_cancel' => 1,
                            'linear-swap-api/v1/swap_cross_trigger_cancel' => 1,
                            'linear-swap-api/v1/swap_trigger_cancelall' => 1,
                            'linear-swap-api/v1/swap_cross_trigger_cancelall' => 1,
                            'linear-swap-api/v1/swap_trigger_openorders' => 1,
                            'linear-swap-api/v1/swap_cross_trigger_openorders' => 1,
                            'linear-swap-api/v1/swap_trigger_hisorders' => 1,
                            'linear-swap-api/v1/swap_cross_trigger_hisorders' => 1,
                            'linear-swap-api/v1/swap_tpsl_order' => 1,
                            'linear-swap-api/v1/swap_cross_tpsl_order' => 1,
                            'linear-swap-api/v1/swap_tpsl_cancel' => 1,
                            'linear-swap-api/v1/swap_cross_tpsl_cancel' => 1,
                            'linear-swap-api/v1/swap_tpsl_cancelall' => 1,
                            'linear-swap-api/v1/swap_cross_tpsl_cancelall' => 1,
                            'linear-swap-api/v1/swap_tpsl_openorders' => 1,
                            'linear-swap-api/v1/swap_cross_tpsl_openorders' => 1,
                            'linear-swap-api/v1/swap_tpsl_hisorders' => 1,
                            'linear-swap-api/v1/swap_cross_tpsl_hisorders' => 1,
                            'linear-swap-api/v1/swap_relation_tpsl_order' => 1,
                            'linear-swap-api/v1/swap_cross_relation_tpsl_order' => 1,
                            'linear-swap-api/v1/swap_track_order' => 1,
                            'linear-swap-api/v1/swap_cross_track_order' => 1,
                            'linear-swap-api/v1/swap_track_cancel' => 1,
                            'linear-swap-api/v1/swap_cross_track_cancel' => 1,
                            'linear-swap-api/v1/swap_track_cancelall' => 1,
                            'linear-swap-api/v1/swap_cross_track_cancelall' => 1,
                            'linear-swap-api/v1/swap_track_openorders' => 1,
                            'linear-swap-api/v1/swap_cross_track_openorders' => 1,
                            'linear-swap-api/v1/swap_track_hisorders' => 1,
                            'linear-swap-api/v1/swap_cross_track_hisorders' => 1,
                        ),
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'feeSide' => 'get',
                    'tierBased' => false,
                    'percentage' => true,
                    'maker' => $this->parse_number('0.002'),
                    'taker' => $this->parse_number('0.002'),
                ),
            ),
            'exceptions' => array(
                'broad' => array(
                    'contract is restricted of closing positions on API.  Please contact customer service' => '\\ccxt\\OnMaintenance',
                    'maintain' => '\\ccxt\\OnMaintenance',
                ),
                'exact' => array(
                    // err-code
                    '403' => '\\ccxt\\AuthenticationError',  // array("status":"error","err_code":403,"err_msg":"Incorrect Access key [Access key错误]","ts":1652774224344)
                    '1010' => '\\ccxt\\AccountNotEnabled', // array("status":"error","err_code":1010,"err_msg":"Account doesnt exist.","ts":1648137970490)
                    '1017' => '\\ccxt\\OrderNotFound', // array("status":"error","err_code":1017,"err_msg":"Order doesnt exist.","ts":1640550859242)
                    '1034' => '\\ccxt\\InvalidOrder', // array("status":"error","err_code":1034,"err_msg":"Incorrect field of order price type.","ts":1643802870182)
                    '1036' => '\\ccxt\\InvalidOrder', // array("status":"error","err_code":1036,"err_msg":"Incorrect field of open long form.","ts":1643802518986)
                    '1039' => '\\ccxt\\InvalidOrder', // array("status":"error","err_code":1039,"err_msg":"Buy price must be lower than 39270.9USDT. Sell price must exceed 37731USDT.","ts":1643802374403)
                    '1041' => '\\ccxt\\InvalidOrder', // array("status":"error","err_code":1041,"err_msg":"The order amount exceeds the limit (170000Cont), please modify and order again.","ts":1643802784940)
                    '1047' => '\\ccxt\\InsufficientFunds', // array("status":"error","err_code":1047,"err_msg":"Insufficient margin available.","ts":1643802672652)
                    '1048' => '\\ccxt\\InsufficientFunds',  // array("status":"error","err_code":1048,"err_msg":"Insufficient close amount available.","ts":1652772408864)
                    '1066' => '\\ccxt\\BadSymbol', // array("status":"error","err_code":1066,"err_msg":"The symbol field cannot be empty. Please re-enter.","ts":1640550819147)
                    '1067' => '\\ccxt\\InvalidOrder', // array("status":"error","err_code":1067,"err_msg":"The client_order_id field is invalid. Please re-enter.","ts":1643802119413)
                    '1013' => '\\ccxt\\BadSymbol', // array("status":"error","err_code":1013,"err_msg":"This contract symbol doesnt exist.","ts":1640550459583)
                    '1094' => '\\ccxt\\InvalidOrder', // array("status":"error","err_code":1094,"err_msg":"The leverage cannot be empty, please switch the leverage or contact customer service","ts":1640496946243)
                    '1220' => '\\ccxt\\AccountNotEnabled', // array("status":"error","err_code":1220,"err_msg":"You don’t have access permission as you have not opened contracts trading.","ts":1645096660718)
                    'bad-request' => '\\ccxt\\BadRequest',
                    'validation-format-error' => '\\ccxt\\BadRequest', // array("status":"error","err-code":"validation-format-error","err-msg":"Format Error => order-id.","data":null)
                    'validation-constraints-required' => '\\ccxt\\BadRequest', // array("status":"error","err-code":"validation-constraints-required","err-msg":"Field is missing => client-order-id.","data":null)
                    'base-date-limit-error' => '\\ccxt\\BadRequest', // array("status":"error","err-code":"base-date-limit-error","err-msg":"date less than system limit","data":null)
                    'api-not-support-temp-addr' => '\\ccxt\\PermissionDenied', // array("status":"error","err-code":"api-not-support-temp-addr","err-msg":"API withdrawal does not support temporary addresses","data":null)
                    'timeout' => '\\ccxt\\RequestTimeout', // array("ts":1571653730865,"status":"error","err-code":"timeout","err-msg":"Request Timeout")
                    'gateway-internal-error' => '\\ccxt\\ExchangeNotAvailable', // array("status":"error","err-code":"gateway-internal-error","err-msg":"Failed to load data. Try again later.","data":null)
                    'account-frozen-balance-insufficient-error' => '\\ccxt\\InsufficientFunds', // array("status":"error","err-code":"account-frozen-balance-insufficient-error","err-msg":"trade account balance is not enough, left => `0.0027`","data":null)
                    'invalid-amount' => '\\ccxt\\InvalidOrder', // eg "Paramemter `amount` is invalid."
                    'order-limitorder-amount-min-error' => '\\ccxt\\InvalidOrder', // limit order amount error, min => `0.001`
                    'order-limitorder-amount-max-error' => '\\ccxt\\InvalidOrder', // market order amount error, max => `1000000`
                    'order-marketorder-amount-min-error' => '\\ccxt\\InvalidOrder', // market order amount error, min => `0.01`
                    'order-limitorder-price-min-error' => '\\ccxt\\InvalidOrder', // limit order price error
                    'order-limitorder-price-max-error' => '\\ccxt\\InvalidOrder', // limit order price error
                    'order-invalid-price' => '\\ccxt\\InvalidOrder', // array("status":"error","err-code":"order-invalid-price","err-msg":"invalid price","data":null)
                    'order-holding-limit-failed' => '\\ccxt\\InvalidOrder', // array("status":"error","err-code":"order-holding-limit-failed","err-msg":"Order failed, exceeded the holding limit of this currency","data":null)
                    'order-orderprice-precision-error' => '\\ccxt\\InvalidOrder', // array("status":"error","err-code":"order-orderprice-precision-error","err-msg":"order price precision error, scale => `4`","data":null)
                    'order-etp-nav-price-max-error' => '\\ccxt\\InvalidOrder', // array("status":"error","err-code":"order-etp-nav-price-max-error","err-msg":"Order price cannot be higher than 5% of NAV","data":null)
                    'order-orderstate-error' => '\\ccxt\\OrderNotFound', // canceling an already canceled order
                    'order-queryorder-invalid' => '\\ccxt\\OrderNotFound', // querying a non-existent order
                    'order-update-error' => '\\ccxt\\ExchangeNotAvailable', // undocumented error
                    'api-signature-check-failed' => '\\ccxt\\AuthenticationError',
                    'api-signature-not-valid' => '\\ccxt\\AuthenticationError', // array("status":"error","err-code":"api-signature-not-valid","err-msg":"Signature not valid => Incorrect Access key [Access key错误]","data":null)
                    'base-record-invalid' => '\\ccxt\\OrderNotFound', // https://github.com/ccxt/ccxt/issues/5750
                    'base-symbol-trade-disabled' => '\\ccxt\\BadSymbol', // array("status":"error","err-code":"base-symbol-trade-disabled","err-msg":"Trading is disabled for this symbol","data":null)
                    'base-symbol-error' => '\\ccxt\\BadSymbol', // array("status":"error","err-code":"base-symbol-error","err-msg":"The symbol is invalid","data":null)
                    'system-maintenance' => '\\ccxt\\OnMaintenance', // array("status" => "error", "err-code" => "system-maintenance", "err-msg" => "System is in maintenance!", "data" => null)
                    'base-request-exceed-frequency-limit' => '\\ccxt\\RateLimitExceeded', // array("status":"error","err-code":"base-request-exceed-frequency-limit","err-msg":"Frequency of requests has exceeded the limit, please try again later","data":null)
                    // err-msg
                    'invalid symbol' => '\\ccxt\\BadSymbol', // array("ts":1568813334794,"status":"error","err-code":"invalid-parameter","err-msg":"invalid symbol")
                    'symbol trade not open now' => '\\ccxt\\BadSymbol', // array("ts":1576210479343,"status":"error","err-code":"invalid-parameter","err-msg":"symbol trade not open now")
                    'require-symbol' => '\\ccxt\\BadSymbol', // array("status":"error","err-code":"require-symbol","err-msg":"Parameter `symbol` is required.","data":null),
                    'invalid-address' => '\\ccxt\\BadRequest', // array("status":"error","err-code":"invalid-address","err-msg":"Invalid address.","data":null),
                    'base-currency-chain-error' => '\\ccxt\\BadRequest', // array("status":"error","err-code":"base-currency-chain-error","err-msg":"The current currency chain does not exist","data":null),
                    'dw-insufficient-balance' => '\\ccxt\\InsufficientFunds', // array("status":"error","err-code":"dw-insufficient-balance","err-msg":"Insufficient balance. You can only transfer `12.3456` at most.","data":null)
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'options' => array(
                'fetchMarkets' => array(
                    'types' => array(
                        'spot' => true,
                        'future' => array(
                            'linear' => true,
                            'inverse' => true,
                        ),
                        'swap' => array(
                            'linear' => true,
                            'inverse' => true,
                        ),
                    ),
                ),
                'defaultType' => 'spot', // spot, future, swap
                'defaultSubType' => 'inverse', // inverse, linear
                'defaultNetwork' => 'ERC20',
                'networks' => array(
                    'ETH' => 'erc20',
                    'TRX' => 'trc20',
                    'HRC20' => 'hrc20',
                    'HECO' => 'hrc20',
                    'HT' => 'hrc20',
                    'ALGO' => 'algo',
                    'OMNI' => '',
                ),
                // https://github.com/ccxt/ccxt/issues/5376
                'fetchOrdersByStatesMethod' => 'spot_private_get_v1_order_orders', // 'spot_private_get_v1_order_history' // https://github.com/ccxt/ccxt/pull/5392
                'createMarketBuyOrderRequiresPrice' => true,
                'language' => 'en-US',
                'broker' => array(
                    'id' => 'AA03022abc',
                ),
                'accountsByType' => array(
                    'spot' => 'pro',
                    'funding' => 'pro',
                    'future' => 'futures',
                ),
                'accountsById' => array(
                    'spot' => 'spot',
                    'margin' => 'margin',
                    'otc' => 'otc',
                    'point' => 'point',
                    'super-margin' => 'super-margin',
                    'investment' => 'investment',
                    'borrow' => 'borrow',
                    'grid-trading' => 'grid-trading',
                    'deposit-earning' => 'deposit-earning',
                    'otc-options' => 'otc-options',
                ),
                'typesByAccount' => array(
                    'pro' => 'spot',
                    'futures' => 'future',
                ),
                'spot' => array(
                    'stopOrderTypes' => array(
                        'stop-limit' => true,
                        'buy-stop-limit' => true,
                        'sell-stop-limit' => true,
                        'stop-limit-fok' => true,
                        'buy-stop-limit-fok' => true,
                        'sell-stop-limit-fok' => true,
                    ),
                    'limitOrderTypes' => array(
                        'limit' => true,
                        'buy-limit' => true,
                        'sell-limit' => true,
                        'ioc' => true,
                        'buy-ioc' => true,
                        'sell-ioc' => true,
                        'limit-maker' => true,
                        'buy-limit-maker' => true,
                        'sell-limit-maker' => true,
                        'stop-limit' => true,
                        'buy-stop-limit' => true,
                        'sell-stop-limit' => true,
                        'limit-fok' => true,
                        'buy-limit-fok' => true,
                        'sell-limit-fok' => true,
                        'stop-limit-fok' => true,
                        'buy-stop-limit-fok' => true,
                        'sell-stop-limit-fok' => true,
                    ),
                ),
            ),
            'commonCurrencies' => array(
                // https://github.com/ccxt/ccxt/issues/6081
                // https://github.com/ccxt/ccxt/issues/3365
                // https://github.com/ccxt/ccxt/issues/2873
                'GET' => 'Themis', // conflict with GET (Guaranteed Entrance Token, GET Protocol)
                'GTC' => 'Game.com', // conflict with Gitcoin and Gastrocoin
                'HIT' => 'HitChain',
                'HOT' => 'Hydro Protocol', // conflict with HOT (Holo) https://github.com/ccxt/ccxt/issues/4929
                // https://github.com/ccxt/ccxt/issues/7399
                // https://coinmarketcap.com/currencies/pnetwork/
                // https://coinmarketcap.com/currencies/penta/markets/
                // https://en.cryptonomist.ch/blog/eidoo/the-edo-to-pnt-upgrade-what-you-need-to-know-updated/
                'PNT' => 'Penta',
                'SBTC' => 'Super Bitcoin',
                'BIFI' => 'Bitcoin File', // conflict with Beefy.Finance https://github.com/ccxt/ccxt/issues/8706
            ),
        ));
    }

    public function fetch_status($params = array ()) {
        yield $this->load_markets();
        $marketType = null;
        list($marketType, $params) = $this->handle_market_type_and_params('fetchMyTrades', null, $params);
        $method = 'statusPublicSpotGetApiV2SummaryJson';
        if ($marketType !== 'spot') {
            $subType = $this->safe_string($params, 'subType', $this->options['defaultSubType']);
            if ($marketType === 'swap') {
                if ($subType === 'linear') {
                    $method = 'statusPublicSwapLinearGetApiV2SummaryJson';
                } elseif ($subType === 'inverse') {
                    $method = 'statusPublicSwapInverseGetApiV2SummaryJson';
                }
            } elseif ($marketType === 'future') {
                if ($subType === 'linear') {
                    $method = 'statusPublicFutureLinearGetApiV2SummaryJson';
                } elseif ($subType === 'inverse') {
                    $method = 'statusPublicFutureInverseGetApiV2SummaryJson';
                }
            } elseif ($marketType === 'contract') {
                $method = 'contractPublicGetHeartbeat';
            }
        }
        $response = yield $this->$method ();
        //
        // statusPublicSpotGetApiV2SummaryJson, statusPublicSwapInverseGetApiV2SummaryJson, statusPublicFutureLinearGetApiV2SummaryJson, statusPublicFutureInverseGetApiV2SummaryJson
        //
        //      {
        //          "page" => array(
        //              "id":"mn7l2lw8pz4p",
        //              "name":"Huobi Futures-USDT-margined Swaps",
        //              "url":"https://status-linear-swap.huobigroup.com",
        //              "time_zone":"Asia/Singapore",
        //              "updated_at":"2022-04-29T12:47:21.319+08:00"),
        //              "components" => array(
        //                  array(
        //                      "id":"lrv093qk3yp5",
        //                      "name":"market data",
        //                      "status":"operational",
        //                      "created_at":"2020-10-29T14:08:59.427+08:00",
        //                      "updated_at":"2020-10-29T14:08:59.427+08:00",
        //                      "position":1,"description":null,
        //                      "showcase":false,
        //                      "start_date":null,
        //                      "group_id":null,
        //                      "page_id":"mn7l2lw8pz4p",
        //                      "group":true,
        //                      "only_show_if_degraded":false,
        //                      "components" => array(
        //                          "82k5jxg7ltxd" // list of related components
        //                      )
        //                  ),
        //              ),
        //              "incidents" => array( // empty array if there are no issues
        //                  {
        //                      "id" => "rclfxz2g21ly",  // incident id
        //                      "name" => "Market data is delayed",  // incident name
        //                      "status" => "investigating",  // incident $status
        //                      "created_at" => "2020-02-11T03:15:01.913Z",  // incident create time
        //                      "updated_at" => "2020-02-11T03:15:02.003Z",   // incident update time
        //                      "monitoring_at" => null,
        //                      "resolved_at" => null,
        //                      "impact" => "minor",  // incident impact
        //                      "shortlink" => "http://stspg.io/pkvbwp8jppf9",
        //                      "started_at" => "2020-02-11T03:15:01.906Z",
        //                      "page_id" => "p0qjfl24znv5",
        //                      "incident_updates" => array(
        //                          {
        //                              "id" => "dwfsk5ttyvtb",
        //                              "status" => "investigating",
        //                              "body" => "Market data is delayed",
        //                              "incident_id" => "rclfxz2g21ly",
        //                              "created_at" => "2020-02-11T03:15:02.000Z",
        //                              "updated_at" => "2020-02-11T03:15:02.000Z",
        //                              "display_at" => "2020-02-11T03:15:02.000Z",
        //                              "affected_components" => array(
        //                                  {
        //                                      "code" => "nctwm9tghxh6",
        //                                      "name" => "Market data",
        //                                      "old_status" => "operational",
        //                                      "new_status" => "degraded_performance"
        //                                  }
        //                              ),
        //                              "deliver_notifications" => true,
        //                              "custom_tweet" => null,
        //                              "tweet_id" => null
        //                          }
        //                      ),
        //                      "components" => array(
        //                          array(
        //                              "id" => "nctwm9tghxh6",
        //                              "name" => "Market data",
        //                              "status" => "degraded_performance",
        //                              "created_at" => "2020-01-13T09:34:48.284Z",
        //                              "updated_at" => "2020-02-11T03:15:01.951Z",
        //                              "position" => 8,
        //                              "description" => null,
        //                              "showcase" => false,
        //                              "group_id" => null,
        //                              "page_id" => "p0qjfl24znv5",
        //                              "group" => false,
        //                              "only_show_if_degraded" => false
        //                          }
        //                      )
        //                  ), ...
        //              ),
        //              "scheduled_maintenances":array( // empty array if there are no scheduled maintenances
        //                  {
        //                      "id" => "k7g299zl765l", // incident id
        //                      "name" => "Schedule maintenance", // incident name
        //                      "status" => "scheduled", // incident $status
        //                      "created_at" => "2020-02-11T03:16:31.481Z",  // incident create time
        //                      "updated_at" => "2020-02-11T03:16:31.530Z",  // incident update time
        //                      "monitoring_at" => null,
        //                      "resolved_at" => null,
        //                      "impact" => "maintenance",  // incident impact
        //                      "shortlink" => "http://stspg.io/md4t4ym7nytd",
        //                      "started_at" => "2020-02-11T03:16:31.474Z",
        //                      "page_id" => "p0qjfl24znv5",
        //                      "incident_updates" => array(
        //                          {
        //                              "id" => "8whgr3rlbld8",
        //                              "status" => "scheduled",
        //                              "body" => "We will be undergoing scheduled maintenance during this time.",
        //                              "incident_id" => "k7g299zl765l",
        //                              "created_at" => "2020-02-11T03:16:31.527Z",
        //                              "updated_at" => "2020-02-11T03:16:31.527Z",
        //                              "display_at" => "2020-02-11T03:16:31.527Z",
        //                              "affected_components" => array(
        //                                  {
        //                                      "code" => "h028tnzw1n5l",
        //                                      "name" => "Deposit And Withdraw - Deposit",
        //                                      "old_status" => "operational",
        //                                      "new_status" => "operational"
        //                                  }
        //                              ),
        //                              "deliver_notifications" => true,
        //                              "custom_tweet" => null,
        //                              "tweet_id" => null
        //                          }
        //                      ),
        //                      "components" => array(
        //                          {
        //                              "id" => "h028tnzw1n5l",
        //                              "name" => "Deposit",
        //                              "status" => "operational",
        //                              "created_at" => "2019-12-05T02:07:12.372Z",
        //                              "updated_at" => "2020-02-10T12:34:52.970Z",
        //                              "position" => 1,
        //                              "description" => null,
        //                              "showcase" => false,
        //                              "group_id" => "gtd0nyr3pf0k",
        //                              "page_id" => "p0qjfl24znv5",
        //                              "group" => false,
        //                              "only_show_if_degraded" => false
        //                          }
        //                      ),
        //                      "scheduled_for" => "2020-02-15T00:00:00.000Z",  // scheduled maintenance start time
        //                      "scheduled_until" => "2020-02-15T01:00:00.000Z"  // scheduled maintenance end time
        //                  }
        //              ),
        //              "status" => {
        //                  "indicator":"none", // none, minor, major, critical, maintenance
        //                  "description":"all systems operational" // All Systems Operational, Minor Service Outage, Partial System Outage, Partially Degraded Service, Service Under Maintenance
        //              }
        //          }
        //
        //
        // contractPublicGetHeartbeat
        //
        //      {
        //          "status" => "ok", // 'ok', 'error'
        //          "data" => array(
        //              "heartbeat" => 1, // future 1 => available, 0 => maintenance with service suspended
        //              "estimated_recovery_time" => null, // estimated recovery time in milliseconds
        //              "swap_heartbeat" => 1,
        //              "swap_estimated_recovery_time" => null,
        //              "option_heartbeat" => 1,
        //              "option_estimated_recovery_time" => null,
        //              "linear_swap_heartbeat" => 1,
        //              "linear_swap_estimated_recovery_time" => null
        //          ),
        //          "ts" => 1557714418033
        //      }
        //
        $status = null;
        $updated = null;
        $url = null;
        if ($method === 'contractPublicGetHeartbeat') {
            $statusRaw = $this->safe_string($response, 'status');
            $status = ($statusRaw === 'ok') ? 'ok' : 'maintenance'; // 'ok', 'error'
            $updated = $this->safe_string($response, 'ts');
        } else {
            $statusData = $this->safe_value($response, 'status', array());
            $statusRaw = $this->safe_string($statusData, 'indicator');
            $status = ($statusRaw === 'none') ? 'ok' : 'maintenance'; // none, minor, major, critical, maintenance
            $pageData = $this->safe_value($response, 'page', array());
            $datetime = $this->safe_string($pageData, 'updated_at');
            $updated = $this->parse8601($datetime);
            $url = $this->safe_string($pageData, 'url');
        }
        return array(
            'status' => $status,
            'updated' => $updated,
            'eta' => null,
            'url' => $url,
            'info' => $response,
        );
    }

    public function fetch_time($params = array ()) {
        /**
         * fetches the current integer timestamp in milliseconds from the exchange server
         * @param {dict} $params extra parameters specific to the huobi api endpoint
         * @return {int} the current integer timestamp in milliseconds from the exchange server
         */
        $options = $this->safe_value($this->options, 'fetchTime', array());
        $defaultType = $this->safe_string($this->options, 'defaultType', 'spot');
        $type = $this->safe_string($options, 'type', $defaultType);
        $type = $this->safe_string($params, 'type', $type);
        $method = 'spotPublicGetV1CommonTimestamp';
        if (($type === 'future') || ($type === 'swap')) {
            $method = 'contractPublicGetApiV1Timestamp';
        }
        $response = yield $this->$method ($params);
        //
        // spot
        //
        //     array("status":"ok","data":1637504261099)
        //
        // future, swap
        //
        //     array("status":"ok","ts":1637504164707)
        //
        return $this->safe_integer_2($response, 'data', 'ts');
    }

    public function parse_trading_fee($fee, $market = null) {
        //
        //     {
        //         "symbol":"btcusdt",
        //         "actualMakerRate":"0.002",
        //         "actualTakerRate":"0.002",
        //         "takerFeeRate":"0.002",
        //         "makerFeeRate":"0.002"
        //     }
        //
        $marketId = $this->safe_string($fee, 'symbol');
        return array(
            'info' => $fee,
            'symbol' => $this->safe_symbol($marketId, $market),
            'maker' => $this->safe_number($fee, 'actualMakerRate'),
            'taker' => $this->safe_number($fee, 'actualTakerRate'),
        );
    }

    public function fetch_trading_fee($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbols' => $market['id'], // trading symbols comma-separated
        );
        $response = yield $this->spotPrivateGetV2ReferenceTransactFeeRate (array_merge($request, $params));
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             {
        //                 "symbol":"btcusdt",
        //                 "actualMakerRate":"0.002",
        //                 "actualTakerRate":"0.002",
        //                 "takerFeeRate":"0.002",
        //                 "makerFeeRate":"0.002"
        //             }
        //         ),
        //         "success":true
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $first = $this->safe_value($data, 0, array());
        return $this->parse_trading_fee($first, $market);
    }

    public function fetch_trading_limits($symbols = null, $params = array ()) {
        // this method should not be called directly, use loadTradingLimits () instead
        //  by default it will try load withdrawal fees of all currencies (with separate requests)
        //  however if you define $symbols = array( 'ETH/BTC', 'LTC/BTC' ) in args it will only load those
        yield $this->load_markets();
        if ($symbols === null) {
            $symbols = $this->symbols;
        }
        $result = array();
        for ($i = 0; $i < count($symbols); $i++) {
            $symbol = $symbols[$i];
            $result[$symbol] = yield $this->fetch_trading_limits_by_id($this->market_id($symbol), $params);
        }
        return $result;
    }

    public function fetch_trading_limits_by_id($id, $params = array ()) {
        $request = array(
            'symbol' => $id,
        );
        $response = yield $this->spotPublicGetV1CommonExchange (array_merge($request, $params));
        //
        //     { status =>   "ok",
        //         data => {                                  symbol => "aidocbtc",
        //                              'buy-limit-must-less-than' =>  1.1,
        //                          'sell-limit-must-greater-than' =>  0.9,
        //                         'limit-order-must-greater-than' =>  1,
        //                            'limit-order-must-less-than' =>  5000000,
        //                    'market-buy-order-must-greater-than' =>  0.0001,
        //                       'market-buy-order-must-less-than' =>  100,
        //                   'market-sell-order-must-greater-than' =>  1,
        //                      'market-sell-order-must-less-than' =>  500000,
        //                       'circuit-break-when-greater-than' =>  10000,
        //                          'circuit-break-when-less-than' =>  10,
        //                 'market-sell-order-rate-must-less-than' =>  0.1,
        //                  'market-buy-order-rate-must-less-than' =>  0.1        } }
        //
        return $this->parse_trading_limits($this->safe_value($response, 'data', array()));
    }

    public function parse_trading_limits($limits, $symbol = null, $params = array ()) {
        //
        //   {                                  $symbol => "aidocbtc",
        //                  'buy-limit-must-less-than' =>  1.1,
        //              'sell-limit-must-greater-than' =>  0.9,
        //             'limit-order-must-greater-than' =>  1,
        //                'limit-order-must-less-than' =>  5000000,
        //        'market-buy-order-must-greater-than' =>  0.0001,
        //           'market-buy-order-must-less-than' =>  100,
        //       'market-sell-order-must-greater-than' =>  1,
        //          'market-sell-order-must-less-than' =>  500000,
        //           'circuit-break-when-greater-than' =>  10000,
        //              'circuit-break-when-less-than' =>  10,
        //     'market-sell-order-rate-must-less-than' =>  0.1,
        //      'market-buy-order-rate-must-less-than' =>  0.1        }
        //
        return array(
            'info' => $limits,
            'limits' => array(
                'amount' => array(
                    'min' => $this->safe_number($limits, 'limit-order-must-greater-than'),
                    'max' => $this->safe_number($limits, 'limit-order-must-less-than'),
                ),
            ),
        );
    }

    public function cost_to_precision($symbol, $cost) {
        return $this->decimal_to_precision($cost, TRUNCATE, $this->markets[$symbol]['precision']['cost'], $this->precisionMode);
    }

    public function fetch_markets($params = array ()) {
        /**
         * retrieves data on all markets for huobi
         * @param {dict} $params extra parameters specific to the exchange api endpoint
         * @return {[dict]} an array of objects representing market data
         */
        $options = $this->safe_value($this->options, 'fetchMarkets', array());
        $types = $this->safe_value($options, 'types', array());
        $allMarkets = array();
        $promises = array();
        $keys = is_array($types) ? array_keys($types) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $type = $keys[$i];
            $value = $this->safe_value($types, $type);
            if ($value === true) {
                $promises[] = $this->fetch_markets_by_type_and_sub_type($type, null, $params);
            } else {
                $subKeys = is_array($value) ? array_keys($value) : array();
                for ($j = 0; $j < count($subKeys); $j++) {
                    $subType = $subKeys[$j];
                    $subValue = $this->safe_value($value, $subType);
                    if ($subValue) {
                        $promises[] = $this->fetch_markets_by_type_and_sub_type($type, $subType, $params);
                    }
                }
            }
        }
        $promises = yield $promises;
        for ($i = 0; $i < count($promises); $i++) {
            $allMarkets = $this->array_concat($allMarkets, $promises[$i]);
        }
        return $allMarkets;
    }

    public function fetch_markets_by_type_and_sub_type($type, $subType, $params = array ()) {
        $method = 'spotPublicGetV1CommonSymbols';
        $query = $this->omit($params, array( 'type', 'subType' ));
        $spot = ($type === 'spot');
        $contract = ($type !== 'spot');
        $future = ($type === 'future');
        $swap = ($type === 'swap');
        $linear = null;
        $inverse = null;
        $request = array();
        if ($contract) {
            $linear = ($subType === 'linear');
            $inverse = ($subType === 'inverse');
            if ($linear) {
                $method = 'contractPublicGetLinearSwapApiV1SwapContractInfo';
                if ($future) {
                    $request['business_type'] = 'futures';
                }
            } elseif ($inverse) {
                if ($future) {
                    $method = 'contractPublicGetApiV1ContractContractInfo';
                } elseif ($swap) {
                    $method = 'contractPublicGetSwapApiV1SwapContractInfo';
                }
            }
        }
        $response = yield $this->$method (array_merge($request, $query));
        //
        // $spot
        //
        //     {
        //         "status":"ok",
        //         "data":array(
        //             array(
        //                 "base-currency":"xrp3s",
        //                 "quote-currency":"usdt",
        //                 "price-precision":4,
        //                 "amount-precision":4,
        //                 "symbol-partition":"innovation",
        //                 "symbol":"xrp3susdt",
        //                 "state":"online",
        //                 "value-precision":8,
        //                 "min-order-amt":0.01,
        //                 "max-order-amt":1616.4353,
        //                 "min-order-value":5,
        //                 "limit-order-min-order-amt":0.01,
        //                 "limit-order-max-order-amt":1616.4353,
        //                 "limit-order-max-buy-amt":1616.4353,
        //                 "limit-order-max-sell-amt":1616.4353,
        //                 "sell-$market-min-order-amt":0.01,
        //                 "sell-$market-max-order-amt":1616.4353,
        //                 "buy-$market-max-order-value":2500,
        //                 "max-order-value":2500,
        //                 "underlying":"xrpusdt",
        //                 "mgmt-fee-rate":0.035000000000000000,
        //                 "charge-time":"23:55:00",
        //                 "rebal-time":"00:00:00",
        //                 "rebal-threshold":-5,
        //                 "init-nav":10.000000000000000000,
        //                 "api-trading":"enabled",
        //                 "tags":"etp,nav,holdinglimit"
        //             ),
        //         )
        //     }
        //
        // $inverse $future
        //
        //     {
        //         "status":"ok",
        //         "data":array(
        //             array(
        //                 "symbol":"BTC",
        //                 "contract_code":"BTC211126",
        //                 "contract_type":"this_week",
        //                 "contract_size":100.000000000000000000,
        //                 "price_tick":0.010000000000000000,
        //                 "delivery_date":"20211126",
        //                 "delivery_time":"1637913600000",
        //                 "create_date":"20211112",
        //                 "contract_status":1,
        //                 "settlement_time":"1637481600000"
        //             ),
        //         ),
        //         "ts":1637474595140
        //     }
        //
        // $linear futures
        //
        //     {
        //         "status":"ok",
        //         "data":array(
        //             array(
        //                 "symbol":"BTC",
        //                 "contract_code":"BTC-USDT-211231",
        //                 "contract_size":0.001000000000000000,
        //                 "price_tick":0.100000000000000000,
        //                 "delivery_date":"20211231",
        //                 "delivery_time":"1640937600000",
        //                 "create_date":"20211228",
        //                 "contract_status":1,
        //                 "settlement_date":"1640764800000",
        //                 "support_margin_mode":"cross",
        //                 "business_type":"futures",
        //                 "pair":"BTC-USDT",
        //                 "contract_type":"this_week" // next_week, quarter
        //             ),
        //         ),
        //         "ts":1640736207263
        //     }
        //
        // swaps
        //
        //     {
        //         "status":"ok",
        //         "data":array(
        //             array(
        //                 "symbol":"BTC",
        //                 "contract_code":"BTC-USDT",
        //                 "contract_size":0.001000000000000000,
        //                 "price_tick":0.100000000000000000,
        //                 "delivery_time":"",
        //                 "create_date":"20201021",
        //                 "contract_status":1,
        //                 "settlement_date":"1637481600000",
        //                 "support_margin_mode":"all", // isolated
        //             ),
        //         ),
        //         "ts":1637474774467
        //     }
        //
        $markets = $this->safe_value($response, 'data', array());
        $numMarkets = is_array($markets) ? count($markets) : 0;
        if ($numMarkets < 1) {
            throw new NetworkError($this->id . ' fetchMarkets() returned an empty $response => ' . $this->json($markets));
        }
        $result = array();
        for ($i = 0; $i < count($markets); $i++) {
            $market = $markets[$i];
            $baseId = null;
            $quoteId = null;
            $settleId = null;
            $id = null;
            $lowercaseId = null;
            $lowercaseBaseId = null;
            if ($contract) {
                $id = $this->safe_string($market, 'contract_code');
                $lowercaseId = strtolower($id);
                if ($swap) {
                    $parts = explode('-', $id);
                    $baseId = $this->safe_string($market, 'symbol');
                    $lowercaseBaseId = strtolower($baseId);
                    $quoteId = $this->safe_string_lower($parts, 1);
                    $settleId = $inverse ? $baseId : $quoteId;
                } elseif ($future) {
                    $baseId = $this->safe_string($market, 'symbol');
                    $lowercaseBaseId = strtolower($baseId);
                    if ($inverse) {
                        $quoteId = 'USD';
                        $settleId = $baseId;
                    } else {
                        $pair = $this->safe_string($market, 'pair');
                        $parts = explode('-', $pair);
                        $quoteId = $this->safe_string($parts, 1);
                        $settleId = $quoteId;
                    }
                }
            } else {
                $baseId = $this->safe_string($market, 'base-currency');
                $lowercaseBaseId = strtolower($baseId);
                $quoteId = $this->safe_string($market, 'quote-currency');
                $id = $baseId . $quoteId;
                $lowercaseId = strtolower($id);
            }
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $settle = $this->safe_currency_code($settleId);
            $symbol = $base . '/' . $quote;
            $expiry = null;
            if ($contract) {
                if ($inverse) {
                    $symbol .= ':' . $base;
                } elseif ($linear) {
                    $symbol .= ':' . $quote;
                }
                if ($future) {
                    $expiry = $this->safe_integer($market, 'delivery_time');
                    $symbol .= '-' . $this->yymmdd($expiry);
                }
            }
            $contractSize = $this->safe_number($market, 'contract_size');
            $pricePrecision = null;
            $amountPrecision = null;
            $costPrecision = null;
            if ($spot) {
                $pricePrecision = $this->safe_string($market, 'price-precision');
                $pricePrecision = $this->parse_number('1e-' . $pricePrecision);
                $amountPrecision = $this->safe_string($market, 'amount-precision');
                $amountPrecision = $this->parse_number('1e-' . $amountPrecision);
                $costPrecision = $this->safe_string($market, 'value-precision');
                $costPrecision = $this->parse_number('1e-' . $costPrecision);
            } else {
                $pricePrecision = $this->safe_number($market, 'price_tick');
                $amountPrecision = 1;
            }
            $maker = null;
            $taker = null;
            if ($spot) {
                $maker = ($base === 'OMG') ? 0 : 0.2 / 100;
                $taker = ($base === 'OMG') ? 0 : 0.2 / 100;
            }
            $minAmount = $this->safe_number($market, 'min-order-amt');
            $maxAmount = $this->safe_number($market, 'max-order-amt');
            $minCost = $this->safe_number($market, 'min-order-value', 0);
            $active = null;
            if ($spot) {
                $state = $this->safe_string($market, 'state');
                $active = ($state === 'online');
            } elseif ($contract) {
                $contractStatus = $this->safe_integer($market, 'contract_status');
                $active = ($contractStatus === 1);
            }
            $leverageRatio = $this->safe_string($market, 'leverage-ratio', '1');
            $superLeverageRatio = $this->safe_string($market, 'super-margin-leverage-ratio', '1');
            $hasLeverage = Precise::string_gt($leverageRatio, '1') || Precise::string_gt($superLeverageRatio, '1');
            // 0 Delisting
            // 1 Listing
            // 2 Pending Listing
            // 3 Suspension
            // 4 Suspending of Listing
            // 5 In Settlement
            // 6 Delivering
            // 7 Settlement Completed
            // 8 Delivered
            // 9 Suspending of Trade
            $result[] = array(
                'id' => $id,
                'lowercaseId' => $lowercaseId,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'settle' => $settle,
                'baseId' => $baseId,
                'lowercaseBaseId' => $lowercaseBaseId,
                'quoteId' => $quoteId,
                'settleId' => $settleId,
                'type' => $type,
                'spot' => $spot,
                'margin' => ($spot && $hasLeverage),
                'swap' => $swap,
                'future' => $future,
                'option' => false,
                'active' => $active,
                'contract' => $contract,
                'linear' => $linear,
                'inverse' => $inverse,
                'taker' => $taker,
                'maker' => $maker,
                'contractSize' => $contractSize,
                'expiry' => $expiry,
                'expiryDatetime' => $this->iso8601($expiry),
                'strike' => null,
                'optionType' => null,
                'precision' => array(
                    'amount' => $amountPrecision,
                    'price' => $pricePrecision,
                    'cost' => $costPrecision,
                ),
                'limits' => array(
                    'leverage' => array(
                        'min' => $this->parse_number('1'),
                        'max' => $this->parse_number($leverageRatio),
                        'superMax' => $this->parse_number($superLeverageRatio),
                    ),
                    'amount' => array(
                        'min' => $minAmount,
                        'max' => $maxAmount,
                    ),
                    'price' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => $minCost,
                        'max' => null,
                    ),
                ),
                'info' => $market,
            );
        }
        return $result;
    }

    public function parse_ticker($ticker, $market = null) {
        //
        // fetchTicker
        //
        //     {
        //         "amount" => 26228.672978342216,
        //         "open" => 9078.95,
        //         "close" => 9146.86,
        //         "high" => 9155.41,
        //         "id" => 209988544334,
        //         "count" => 265846,
        //         "low" => 8988.0,
        //         "version" => 209988544334,
        //         "ask" => array( 9146.87, 0.156134 ),
        //         "vol" => 2.3822168242201668E8,
        //         "bid" => array( 9146.86, 0.080758 ),
        //     }
        //
        // fetchTickers
        //
        //     {
        //         $symbol => "bhdht",
        //         $open =>  2.3938,
        //         high =>  2.4151,
        //         low =>  2.3323,
        //         $close =>  2.3909,
        //         amount =>  628.992,
        //         vol =>  1493.71841095,
        //         count =>  2088,
        //         $bid =>  2.3643,
        //         bidSize =>  0.7136,
        //         $ask =>  2.4061,
        //         askSize =>  0.4156
        //     }
        //
        $marketId = $this->safe_string_2($ticker, 'symbol', 'contract_code');
        $symbol = $this->safe_symbol($marketId, $market);
        $timestamp = $this->safe_integer($ticker, 'ts');
        $bid = null;
        $bidVolume = null;
        $ask = null;
        $askVolume = null;
        if (is_array($ticker) && array_key_exists('bid', $ticker)) {
            if (gettype($ticker['bid']) === 'array' && count(array_filter(array_keys($ticker['bid']), 'is_string')) == 0) {
                $bid = $this->safe_string($ticker['bid'], 0);
                $bidVolume = $this->safe_string($ticker['bid'], 1);
            } else {
                $bid = $this->safe_string($ticker, 'bid');
                $bidVolume = $this->safe_string($ticker, 'bidSize');
            }
        }
        if (is_array($ticker) && array_key_exists('ask', $ticker)) {
            if (gettype($ticker['ask']) === 'array' && count(array_filter(array_keys($ticker['ask']), 'is_string')) == 0) {
                $ask = $this->safe_string($ticker['ask'], 0);
                $askVolume = $this->safe_string($ticker['ask'], 1);
            } else {
                $ask = $this->safe_string($ticker, 'ask');
                $askVolume = $this->safe_string($ticker, 'askSize');
            }
        }
        $open = $this->safe_string($ticker, 'open');
        $close = $this->safe_string($ticker, 'close');
        $baseVolume = $this->safe_string($ticker, 'amount');
        $quoteVolume = $this->safe_string($ticker, 'vol');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($ticker, 'high'),
            'low' => $this->safe_string($ticker, 'low'),
            'bid' => $bid,
            'bidVolume' => $bidVolume,
            'ask' => $ask,
            'askVolume' => $askVolume,
            'vwap' => null,
            'open' => $open,
            'close' => $close,
            'last' => $close,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_ticker($symbol, $params = array ()) {
        /**
         * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
         * @param {str} $symbol unified $symbol of the $market to fetch the $ticker for
         * @param {dict} $params extra parameters specific to the huobi api endpoint
         * @return {dict} a {@link https://docs.ccxt.com/en/latest/manual.html#$ticker-structure $ticker structure}
         */
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array();
        $fieldName = 'symbol';
        $method = 'spotPublicGetMarketDetailMerged';
        if ($market['linear']) {
            $method = 'contractPublicGetLinearSwapExMarketDetailMerged';
            $fieldName = 'contract_code';
        } elseif ($market['inverse']) {
            if ($market['future']) {
                $method = 'contractPublicGetMarketDetailMerged';
            } elseif ($market['swap']) {
                $method = 'contractPublicGetSwapExMarketDetailMerged';
                $fieldName = 'contract_code';
            }
        }
        $request[$fieldName] = $market['id'];
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot
        //
        //     {
        //         "status" => "ok",
        //         "ch" => "market.btcusdt.detail.merged",
        //         "ts" => 1583494336669,
        //         "tick" => {
        //             "amount" => 26228.672978342216,
        //             "open" => 9078.95,
        //             "close" => 9146.86,
        //             "high" => 9155.41,
        //             "id" => 209988544334,
        //             "count" => 265846,
        //             "low" => 8988.0,
        //             "version" => 209988544334,
        //             "ask" => array( 9146.87, 0.156134 ),
        //             "vol" => 2.3822168242201668E8,
        //             "bid" => array( 9146.86, 0.080758 ),
        //         }
        //     }
        //
        // future, swap
        //
        //     {
        //         "ch":"market.BTC211126.detail.merged",
        //         "status":"ok",
        //         "tick":array(
        //             "amount":"669.3385682049668320322569544150680718474",
        //             "ask":[59117.44,48],
        //             "bid":[59082,48],
        //             "close":"59087.97",
        //             "count":5947,
        //             "high":"59892.62",
        //             "id":1637502670,
        //             "low":"57402.87",
        //             "open":"57638",
        //             "ts":1637502670059,
        //             "vol":"394598"
        //         ),
        //         "ts":1637502670059
        //     }
        //
        $tick = $this->safe_value($response, 'tick', array());
        $ticker = $this->parse_ticker($tick, $market);
        $timestamp = $this->safe_integer($response, 'ts');
        $ticker['timestamp'] = $timestamp;
        $ticker['datetime'] = $this->iso8601($timestamp);
        return $ticker;
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        /**
         * fetches price $tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each $market
         * @param {[str]|null} $symbols unified $symbols of the markets to fetch the $ticker for, all $market $tickers are returned if not assigned
         * @param {dict} $params extra parameters specific to the huobi api endpoint
         * @return {dict} an array of {@link https://docs.ccxt.com/en/latest/manual.html#$ticker-structure $ticker structures}
         */
        yield $this->load_markets();
        $options = $this->safe_value($this->options, 'fetchTickers', array());
        $defaultType = $this->safe_string($this->options, 'defaultType', 'spot');
        $type = $this->safe_string($options, 'type', $defaultType);
        $type = $this->safe_string($params, 'type', $type);
        $method = 'spotPublicGetMarketTickers';
        $defaultSubType = $this->safe_string($this->options, 'defaultSubType', 'inverse');
        $subType = $this->safe_string($options, 'subType', $defaultSubType);
        $subType = $this->safe_string($params, 'subType', $subType);
        $request = array();
        $future = ($type === 'future');
        $swap = ($type === 'swap');
        $linear = ($subType === 'linear');
        $inverse = ($subType === 'inverse');
        if ($future || $swap) {
            if ($linear) {
                $method = 'contractPublicGetLinearSwapExMarketDetailBatchMerged';
                if ($future) {
                    $request['business_type'] = 'futures';
                }
            } elseif ($inverse) {
                if ($future) {
                    $method = 'contractPublicGetMarketDetailBatchMerged';
                } elseif ($swap) {
                    $method = 'contractPublicGetSwapExMarketDetailBatchMerged';
                }
            }
        }
        $params = $this->omit($params, array( 'type', 'subType' ));
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot
        //
        //     {
        //         "data":array(
        //             array(
        //                 "symbol":"hbcbtc",
        //                 "open":5.313E-5,
        //                 "high":5.34E-5,
        //                 "low":5.112E-5,
        //                 "close":5.175E-5,
        //                 "amount":1183.87,
        //                 "vol":0.0618599229,
        //                 "count":205,
        //                 "bid":5.126E-5,
        //                 "bidSize":5.25,
        //                 "ask":5.214E-5,
        //                 "askSize":150.0
        //             ),
        //         ),
        //         "status":"ok",
        //         "ts":1639547261293
        //     }
        //
        // $inverse swaps, $linear swaps, $inverse futures
        //
        //     {
        //         "status":"ok",
        //         "ticks":[
        //             {
        //                 "id":1637504679,
        //                 "ts":1637504679372,
        //                 "ask":[0.10644,100],
        //                 "bid":[0.10624,26],
        //                 "symbol":"TRX_CW",
        //                 "open":"0.10233",
        //                 "close":"0.10644",
        //                 "low":"0.1017",
        //                 "high":"0.10725",
        //                 "amount":"2340267.415144052378486261756692535687481566",
        //                 "count":882,
        //                 "vol":"24706"
        //             }
        //         ],
        //         "ts":1637504679376
        //     }
        //
        // $linear futures
        //
        //     {
        //         "status":"ok",
        //         "ticks":[
        //             {
        //                 "id":1640745627,
        //                 "ts":1640745627957,
        //                 "ask":[48079.1,20],
        //                 "bid":[47713.8,125],
        //                 "business_type":"futures",
        //                 "contract_code":"BTC-USDT-CW",
        //                 "open":"49011.8",
        //                 "close":"47934",
        //                 "low":"47292.3",
        //                 "high":"49011.8",
        //                 "amount":"17.398",
        //                 "count":1515,
        //                 "vol":"17398",
        //                 "trade_turnover":"840726.5048"
        //             }
        //         ],
        //         "ts":1640745627988
        //     }
        //
        $tickers = $this->safe_value_2($response, 'data', 'ticks', array());
        $timestamp = $this->safe_integer($response, 'ts');
        $result = array();
        for ($i = 0; $i < count($tickers); $i++) {
            $ticker = $this->parse_ticker($tickers[$i]);
            // the $market ids for $linear futures are non-standard and differ from all the other endpoints
            // we are doing a $linear-matching here
            if ($future && $linear) {
                for ($j = 0; $j < count($this->symbols); $j++) {
                    $symbol = $this->symbols[$j];
                    $market = $this->market($symbol);
                    $contractType = $this->safe_string($market['info'], 'contract_type');
                    if (($contractType === 'this_week') && ($ticker['symbol'] === ($market['baseId'] . '-' . $market['quoteId'] . '-CW'))) {
                        $ticker['symbol'] = $market['symbol'];
                        break;
                    } elseif (($contractType === 'next_week') && ($ticker['symbol'] === ($market['baseId'] . '-' . $market['quoteId'] . '-NW'))) {
                        $ticker['symbol'] = $market['symbol'];
                        break;
                    } elseif (($contractType === 'this_quarter') && ($ticker['symbol'] === ($market['baseId'] . '-' . $market['quoteId'] . '-CQ'))) {
                        $ticker['symbol'] = $market['symbol'];
                        break;
                    } elseif (($contractType === 'next_quarter') && ($ticker['symbol'] === ($market['baseId'] . '-' . $market['quoteId'] . '-NQ'))) {
                        $ticker['symbol'] = $market['symbol'];
                        break;
                    }
                }
            }
            $symbol = $ticker['symbol'];
            $ticker['timestamp'] = $timestamp;
            $ticker['datetime'] = $this->iso8601($timestamp);
            $result[$symbol] = $ticker;
        }
        return $this->filter_by_array($result, 'symbol', $symbols);
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        /**
         * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
         * @param {str} $symbol unified $symbol of the $market to fetch the order book for
         * @param {int|null} $limit the maximum amount of order book entries to return
         * @param {dict} $params extra parameters specific to the huobi api endpoint
         * @return {dict} A dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure order book structures} indexed by $market symbols
         */
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            //
            // from the API docs
            //
            //     to get depth data within step 150, use step0, step1, step2, step3, step4, step5, step14, step15（merged depth data 0-5,14-15, when step is 0，depth data will not be merged
            //     to get depth data within step 20, use step6, step7, step8, step9, step10, step11, step12, step13(merged depth data 7-13), when step is 6, depth data will not be merged
            //
            'type' => 'step0',
            // 'symbol' => $market['id'], // spot, future
            // 'contract_code' => $market['id'], // swap
        );
        $fieldName = 'symbol';
        $method = 'spotPublicGetMarketDepth';
        if ($market['linear']) {
            $method = 'contractPublicGetLinearSwapExMarketDepth';
            $fieldName = 'contract_code';
        } elseif ($market['inverse']) {
            if ($market['future']) {
                $method = 'contractPublicGetMarketDepth';
            } elseif ($market['swap']) {
                $method = 'contractPublicGetSwapExMarketDepth';
                $fieldName = 'contract_code';
            }
        } else {
            if ($limit !== null) {
                // Valid depths are 5, 10, 20 or empty https://huobiapi.github.io/docs/spot/v1/en/#get-$market-depth
                if (($limit !== 5) && ($limit !== 10) && ($limit !== 20) && ($limit !== 150)) {
                    throw new BadRequest($this->id . ' fetchOrderBook() $limit argument must be null, 5, 10, 20, or 150, default is 150');
                }
                // only set the depth if it is not 150
                // 150 is the implicit default on the exchange side for step0 and no orderbook aggregation
                // it is not accepted by the exchange if you set it explicitly
                if ($limit !== 150) {
                    $request['depth'] = $limit;
                }
            }
        }
        $request[$fieldName] = $market['id'];
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot, future, swap
        //
        //     {
        //         "status" => "ok",
        //         "ch" => "market.btcusdt.depth.step0",
        //         "ts" => 1583474832790,
        //         "tick" => {
        //             "bids" => array(
        //                 array( 9100.290000000000000000, 0.200000000000000000 ),
        //                 array( 9099.820000000000000000, 0.200000000000000000 ),
        //                 array( 9099.610000000000000000, 0.205000000000000000 ),
        //             ),
        //             "asks" => array(
        //                 array( 9100.640000000000000000, 0.005904000000000000 ),
        //                 array( 9101.010000000000000000, 0.287311000000000000 ),
        //                 array( 9101.030000000000000000, 0.012121000000000000 ),
        //             ),
        //             "ch":"market.BTC-USD.depth.step0",
        //             "ts":1583474832008,
        //             "id":1637554816,
        //             "mrid":121654491624,
        //             "version":104999698780
        //         }
        //     }
        //
        if (is_array($response) && array_key_exists('tick', $response)) {
            if (!$response['tick']) {
                throw new BadSymbol($this->id . ' fetchOrderBook() returned empty $response => ' . $this->json($response));
            }
            $tick = $this->safe_value($response, 'tick');
            $timestamp = $this->safe_integer($tick, 'ts', $this->safe_integer($response, 'ts'));
            $result = $this->parse_order_book($tick, $symbol, $timestamp);
            $result['nonce'] = $this->safe_integer($tick, 'version');
            return $result;
        }
        throw new ExchangeError($this->id . ' fetchOrderBook() returned unrecognized $response => ' . $this->json($response));
    }

    public function parse_trade($trade, $market = null) {
        //
        // spot fetchTrades (public)
        //
        //     {
        //         "amount" => 0.010411000000000000,
        //         "trade-$id" => 102090736910,
        //         "ts" => 1583497692182,
        //         "id" => 10500517034273194594947,
        //         "price" => 9096.050000000000000000,
        //         "direction" => "sell"
        //     }
        //
        // spot fetchMyTrades (private)
        //
        //     {
        //          'symbol' => 'swftcbtc',
        //          'fee-currency' => 'swftc',
        //          'filled-fees' => '0',
        //          'source' => 'spot-api',
        //          'id' => 83789509854000,
        //          'type' => 'buy-limit',
        //          'order-id' => 83711103204909,
        //          'filled-points' => '0.005826843283532154',
        //          'fee-deduct-currency' => 'ht',
        //          'filled-amount' => '45941.53',
        //          'price' => '0.0000001401',
        //          'created-at' => 1597933260729,
        //          'match-id' => 100087455560,
        //          'role' => 'maker',
        //          'trade-id' => 100050305348
        //     }
        //
        // linear swap isolated margin fetchOrder details
        //
        //     {
        //         "trade_id" => 131560927,
        //         "trade_price" => 13059.800000000000000000,
        //         "trade_volume" => 1.000000000000000000,
        //         "trade_turnover" => 13.059800000000000000,
        //         "trade_fee" => -0.005223920000000000,
        //         "created_at" => 1603703614715,
        //         "role" => "taker",
        //         "fee_asset" => "USDT",
        //         "profit" => 0,
        //         "real_profit" => 0,
        //         "id" => "131560927-770334322963152896-1"
        //     }
        //
        // inverse swap cross margin fetchMyTrades
        //
        //     {
        //         "contract_type":"swap",
        //         "pair":"O3-USDT",
        //         "business_type":"swap",
        //         "query_id":652123190,
        //         "match_id":28306009409,
        //         "order_id":941137865226903553,
        //         "symbol":"O3",
        //         "contract_code":"O3-USDT",
        //         "direction":"sell",
        //         "offset":"open",
        //         "trade_volume":100.000000000000000000,
        //         "trade_price":0.398500000000000000,
        //         "trade_turnover":39.850000000000000000,
        //         "trade_fee":-0.007970000000000000,
        //         "offset_profitloss":0E-18,
        //         "create_date":1644426352999,
        //         "role":"Maker",
        //         "order_source":"api",
        //         "order_id_str":"941137865226903553",
        //         "id":"28306009409-941137865226903553-1",
        //         "fee_asset":"USDT",
        //         "margin_mode":"cross",
        //         "margin_account":"USDT",
        //         "real_profit":0E-18,
        //         "trade_partition":"USDT"
        //     }
        //
        $marketId = $this->safe_string_2($trade, 'contract_code', 'symbol');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $timestamp = $this->safe_integer_2($trade, 'ts', 'created-at');
        $timestamp = $this->safe_integer_2($trade, 'created_at', 'create_date', $timestamp);
        $order = $this->safe_string_2($trade, 'order-id', 'order_id');
        $side = $this->safe_string($trade, 'direction');
        $type = $this->safe_string($trade, 'type');
        if ($type !== null) {
            $typeParts = explode('-', $type);
            $side = $typeParts[0];
            $type = $typeParts[1];
        }
        $takerOrMaker = $this->safe_string_lower($trade, 'role');
        $priceString = $this->safe_string_2($trade, 'price', 'trade_price');
        $amountString = $this->safe_string_2($trade, 'filled-amount', 'amount');
        $amountString = $this->safe_string($trade, 'trade_volume', $amountString);
        $costString = $this->safe_string($trade, 'trade_turnover');
        $fee = null;
        $feeCost = $this->safe_string_2($trade, 'filled-fees', 'trade_fee');
        $feeCurrencyId = $this->safe_string_2($trade, 'fee-currency', 'fee_asset');
        $feeCurrency = $this->safe_currency_code($feeCurrencyId);
        $filledPoints = $this->safe_string($trade, 'filled-points');
        if ($filledPoints !== null) {
            if (($feeCost === null) || Precise::string_equals($feeCost, '0')) {
                $feeDeductCurrency = $this->safe_string($trade, 'fee-deduct-currency');
                if ($feeDeductCurrency !== '') {
                    $feeCost = $filledPoints;
                    $feeCurrency = $this->safe_currency_code($feeDeductCurrency);
                }
            }
        }
        if ($feeCost !== null) {
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrency,
            );
        }
        $tradeId = $this->safe_string_2($trade, 'trade-id', 'tradeId');
        $id = $this->safe_string_2($trade, 'trade_id', 'id', $tradeId);
        return $this->safe_trade(array(
            'id' => $id,
            'info' => $trade,
            'order' => $order,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'type' => $type,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => $costString,
            'fee' => $fee,
        ), $market);
    }

    public function fetch_order_trades($id, $symbol = null, $since = null, $limit = null, $params = array ()) {
        $marketType = null;
        list($marketType, $params) = $this->handle_market_type_and_params('fetchOrderTrades', null, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'fetchSpotOrderTrades',
            // 'swap' => 'fetchContractOrderTrades',
            // 'future' => 'fetchContractOrderTrades',
        ));
        return yield $this->$method ($id, $symbol, $since, $limit, $params);
    }

    public function fetch_spot_order_trades($id, $symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array(
            'order-id' => $id,
        );
        $response = yield $this->spotPrivateGetV1OrderOrdersOrderIdMatchresults (array_merge($request, $params));
        return $this->parse_trades($response['data'], null, $since, $limit);
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $marketType = null;
        list($marketType, $params) = $this->handle_market_type_and_params('fetchMyTrades', null, $params);
        $request = array(
            // spot -----------------------------------------------------------
            // 'symbol' => $market['id'],
            // 'types' => 'buy-$market,sell-$market,buy-$limit,sell-$limit,buy-ioc,sell-ioc,buy-$limit-maker,sell-$limit-maker,buy-stop-$limit,sell-stop-limit',
            // 'start-time' => $since, // max 48 hours within 120 days
            // 'end-time' => $this->milliseconds(), // max 48 hours within 120 days
            // 'from' => 'id', // tring false N/A Search internal id to begin with if search next page, then this should be the last id (not trade-id) of last page; if search previous page, then this should be the first id (not trade-id) of last page
            // 'direct' => 'next', // next, prev
            // 'size' => $limit, // default 100, max 500 The number of orders to return [1-500]
            // contracts ------------------------------------------------------
            // 'symbol' => $market['settleId'], // required
            // 'trade_type' => 0, // required, 0 all, 1 open long, 2 open short, 3 close short, 4 close long, 5 liquidate long positions, 6 liquidate short positions
            // 'contract_code' => $market['id'],
            // 'start_time' => $since, // max 48 hours within 120 days
            // 'end_time' => $this->milliseconds(), // max 48 hours within 120 days
            // 'from_id' => 'id', // tring false N/A Search internal id to begin with if search next page, then this should be the last id (not trade-id) of last page; if search previous page, then this should be the first id (not trade-id) of last page
            // 'direct' => 'prev', // next, prev
            // 'size' => $limit, // default 20, max 50
        );
        $method = null;
        $market = null;
        if ($marketType === 'spot') {
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            if ($limit !== null) {
                $request['size'] = $limit; // default 100, max 500
            }
            if ($since !== null) {
                $request['start-time'] = $since; // a date within 120 days from today
                // $request['end-time'] = $this->sum($since, 172800000); // 48 hours window
            }
            $method = 'spotPrivateGetV1OrderMatchresults';
        } else {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchMyTrades() requires a $symbol for ' . $marketType . ' orders');
            }
            $market = $this->market($symbol);
            $request['contract_code'] = $market['id'];
            $request['trade_type'] = 0; // 0 all, 1 open long, 2 open short, 3 close short, 4 close long, 5 liquidate long positions, 6 liquidate short positions
            if ($market['linear']) {
                $defaultMargin = $market['future'] ? 'cross' : 'isolated';
                $marginMode = $this->safe_string_2($this->options, 'defaultMarginMode', 'marginMode', $defaultMargin);
                if ($marginMode === 'isolated') {
                    $method = 'contractPrivatePostLinearSwapApiV1SwapMatchresultsExact';
                } elseif ($marginMode === 'cross') {
                    $method = 'contractPrivatePostLinearSwapApiV1SwapCrossMatchresultsExact';
                }
            } elseif ($market['inverse']) {
                if ($marketType === 'future') {
                    $method = 'contractPrivatePostApiV1ContractMatchresultsExact';
                    $request['symbol'] = $market['settleId'];
                } elseif ($marketType === 'swap') {
                    $method = 'contractPrivatePostSwapApiV1SwapMatchresultsExact';
                } else {
                    throw new NotSupported($this->id . ' fetchMyTrades() does not support ' . $marketType . ' markets');
                }
            }
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot
        //
        //     {
        //         "status" => "ok",
        //         "data" => array(
        //             {
        //                 "symbol" => "polyusdt",
        //                 "fee-currency" => "poly",
        //                 "source" => "spot-web",
        //                 "price" => "0.338",
        //                 "created-at" => 1629443051839,
        //                 "role" => "taker",
        //                 "order-id" => 345487249132375,
        //                 "match-id" => 5014,
        //                 "trade-id" => 1085,
        //                 "filled-amount" => "147.928994082840236",
        //                 "filled-fees" => "0",
        //                 "filled-points" => "0.1",
        //                 "fee-deduct-currency" => "hbpoint",
        //                 "fee-deduct-state" => "done",
        //                 "id" => 313288753120940,
        //                 "type" => "buy-$market"
        //             }
        //         )
        //     }
        //
        // contracts
        //
        //     {
        //         "status" => "ok",
        //         "data" => {
        //             "trades" => array(
        //                 array(
        //                     "query_id" => 2424420723,
        //                     "match_id" => 113891764710,
        //                     "order_id" => 773135295142658048,
        //                     "symbol" => "ADA",
        //                     "contract_type" => "quarter", // swap
        //                     "business_type" => "futures", // swap
        //                     "contract_code" => "ADA201225",
        //                     "direction" => "buy",
        //                     "offset" => "open",
        //                     "trade_volume" => 1,
        //                     "trade_price" => 0.092,
        //                     "trade_turnover" => 10,
        //                     "trade_fee" => -0.021739130434782608,
        //                     "offset_profitloss" => 0,
        //                     "create_date" => 1604371703183,
        //                     "role" => "Maker",
        //                     "order_source" => "web",
        //                     "order_id_str" => "773135295142658048",
        //                     "fee_asset" => "ADA",
        //                     "margin_mode" => "isolated", // cross
        //                     "margin_account" => "BTC-USDT",
        //                     "real_profit" => 0,
        //                     "id" => "113891764710-773135295142658048-1",
        //                     "trade_partition":"USDT",
        //                 }
        //             ),
        //             "remain_size" => 15,
        //             "next_id" => 2424413094
        //         ),
        //         "ts" => 1604372202243
        //     }
        //
        $trades = $this->safe_value($response, 'data');
        if (gettype($trades) === 'array' && count(array_filter(array_keys($trades), 'is_string')) != 0) {
            $trades = $this->safe_value($trades, 'trades');
        }
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function fetch_trades($symbol, $since = null, $limit = 1000, $params = array ()) {
        /**
         * get the list of most recent $trades for a particular $symbol
         * @param {str} $symbol unified $symbol of the $market to fetch $trades for
         * @param {int|null} $since timestamp in ms of the earliest $trade to fetch
         * @param {int|null} $limit the maximum amount of $trades to fetch
         * @param {dict} $params extra parameters specific to the huobi api endpoint
         * @return {[dict]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades $trade structures~
         */
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            // 'symbol' => $market['id'], // spot, future
            // 'contract_code' => $market['id'], // swap
        );
        $fieldName = 'symbol';
        $method = 'spotPublicGetMarketHistoryTrade';
        if ($market['future']) {
            if ($market['inverse']) {
                $method = 'contractPublicGetMarketHistoryTrade';
            } elseif ($market['linear']) {
                $method = 'contractPublicGetLinearSwapExMarketHistoryTrade';
                $fieldName = 'contract_code';
            }
        } elseif ($market['swap']) {
            if ($market['inverse']) {
                $method = 'contractPublicGetSwapExMarketHistoryTrade';
            } elseif ($market['linear']) {
                $method = 'contractPublicGetLinearSwapExMarketHistoryTrade';
            }
            $fieldName = 'contract_code';
        }
        $request[$fieldName] = $market['id'];
        if ($limit !== null) {
            $request['size'] = $limit; // max 2000
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        //     {
        //         "status" => "ok",
        //         "ch" => "market.btcusdt.trade.detail",
        //         "ts" => 1583497692365,
        //         "data" => array(
        //             {
        //                 "id" => 105005170342,
        //                 "ts" => 1583497692182,
        //                 "data" => array(
        //                     array(
        //                         "amount" => 0.010411000000000000,
        //                         "trade-id" => 102090736910,
        //                         "ts" => 1583497692182,
        //                         "id" => 10500517034273194594947,
        //                         "price" => 9096.050000000000000000,
        //                         "direction" => "sell"
        //                     }
        //                 )
        //             ),
        //             // ...
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $trades = $this->safe_value($data[$i], 'data', array());
            for ($j = 0; $j < count($trades); $j++) {
                $trade = $this->parse_trade($trades[$j], $market);
                $result[] = $trade;
            }
        }
        $result = $this->sort_by($result, 'timestamp');
        return $this->filter_by_symbol_since_limit($result, $market['symbol'], $since, $limit);
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        //
        //     {
        //         "amount":1.2082,
        //         "open":0.025096,
        //         "close":0.025095,
        //         "high":0.025096,
        //         "id":1591515300,
        //         "count":6,
        //         "low":0.025095,
        //         "vol":0.0303205097
        //     }
        //
        return array(
            $this->safe_timestamp($ohlcv, 'id'),
            $this->safe_number($ohlcv, 'open'),
            $this->safe_number($ohlcv, 'high'),
            $this->safe_number($ohlcv, 'low'),
            $this->safe_number($ohlcv, 'close'),
            $this->safe_number($ohlcv, 'amount'),
        );
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        /**
         * fetches historical candlestick $data containing the open, high, low, and close $price, and the volume of a $market
         * @param {str} $symbol unified $symbol of the $market to fetch OHLCV $data for
         * @param {str} $timeframe the length of time each candle represents
         * @param {int|null} $since timestamp in ms of the earliest candle to fetch
         * @param {int|null} $limit the maximum amount of candles to fetch
         * @param {dict} $params extra parameters specific to the huobi api endpoint
         * @return {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
         */
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'period' => $this->timeframes[$timeframe],
            // 'symbol' => $market['id'], // spot, future
            // 'contract_code' => $market['id'], // swap
            // 'size' => 1000, // max 1000 for spot, 2000 for contracts
            // 'from' => intval($since / 1000), spot only
            // 'to' => $this->seconds(), spot only
        );
        $fieldName = 'symbol';
        $price = $this->safe_string($params, 'price');
        $params = $this->omit($params, 'price');
        $method = 'spotPublicGetMarketHistoryCandles';
        if ($market['spot']) {
            if ($since !== null) {
                $request['from'] = intval($since / 1000);
            }
            if ($limit !== null) {
                $request['size'] = $limit; // max 2000
            }
        } elseif ($market['future']) {
            if ($market['inverse']) {
                if ($price === 'mark') {
                    $method = 'contractPublicGetIndexMarketHistoryMarkPriceKline';
                } elseif ($price === 'index') {
                    $method = 'contractPublicGetIndexMarketHistoryIndex';
                } elseif ($price === 'premiumIndex') {
                    throw new BadRequest($this->id . ' ' . $market['type'] . ' has no api endpoint for ' . $price . ' kline data');
                } else {
                    $method = 'contractPublicGetMarketHistoryKline';
                }
            } elseif ($market['linear']) {
                if ($price === 'mark') {
                    $method = 'contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline';
                } elseif ($price === 'index') {
                    throw new BadRequest($this->id . ' ' . $market['type'] . ' has no api endpoint for ' . $price . ' kline data');
                } elseif ($price === 'premiumIndex') {
                    $method = 'contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline';
                } else {
                    $method = 'contractPublicGetLinearSwapExMarketHistoryKline';
                }
                $fieldName = 'contract_code';
            }
        } elseif ($market['swap']) {
            if ($market['inverse']) {
                if ($price === 'mark') {
                    $method = 'contractPublicGetIndexMarketHistorySwapMarkPriceKline';
                } elseif ($price === 'index') {
                    throw new BadRequest($this->id . ' ' . $market['type'] . ' has no api endpoint for ' . $price . ' kline data');
                } elseif ($price === 'premiumIndex') {
                    $method = 'contractPublicGetIndexMarketHistorySwapPremiumIndexKline';
                } else {
                    $method = 'contractPublicGetSwapExMarketHistoryKline';
                }
            } elseif ($market['linear']) {
                if ($price === 'mark') {
                    $method = 'contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline';
                } elseif ($price === 'index') {
                    throw new BadRequest($this->id . ' ' . $market['type'] . ' has no api endpoint for ' . $price . ' kline data');
                } elseif ($price === 'premiumIndex') {
                    $method = 'contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline';
                } else {
                    $method = 'contractPublicGetLinearSwapExMarketHistoryKline';
                }
            }
            $fieldName = 'contract_code';
        }
        if ($market['contract']) {
            if ($limit === null) {
                $limit = 2000;
            }
            $request['size'] = $limit;
            if ($price === null) {
                $duration = $this->parse_timeframe($timeframe);
                if ($since === null) {
                    $now = $this->seconds();
                    $request['from'] = $now - $duration * ($limit - 1);
                    $request['to'] = $now;
                } else {
                    $start = intval($since / 1000);
                    $request['from'] = $start;
                    $request['to'] = $this->sum($start, $duration * ($limit - 1));
                }
            }
        }
        $request[$fieldName] = $market['id'];
        $response = yield $this->$method (array_merge($request, $params));
        //
        //     {
        //         "status":"ok",
        //         "ch":"market.ethbtc.kline.1min",
        //         "ts":1591515374371,
        //         "data":array(
        //             array("amount":0.0,"open":0.025095,"close":0.025095,"high":0.025095,"id":1591515360,"count":0,"low":0.025095,"vol":0.0),
        //             array("amount":1.2082,"open":0.025096,"close":0.025095,"high":0.025096,"id":1591515300,"count":6,"low":0.025095,"vol":0.0303205097),
        //             array("amount":0.0648,"open":0.025096,"close":0.025096,"high":0.025096,"id":1591515240,"count":2,"low":0.025096,"vol":0.0016262208),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_ohlcvs($data, $market, $timeframe, $since, $limit);
    }

    public function fetch_accounts($params = array ()) {
        yield $this->load_markets();
        $response = yield $this->spotPrivateGetV1AccountAccounts ($params);
        //
        //     {
        //         "status":"ok",
        //         "data":array(
        //             array("id":5202591,"type":"point","subtype":"","state":"working"),
        //             array("id":1528640,"type":"spot","subtype":"","state":"working"),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data');
        return $this->parse_accounts($data);
    }

    public function parse_account($account) {
        //
        //     {
        //         "id" => 5202591,
        //         "type" => "point",   // spot, margin, otc, point, super-margin, investment, borrow, grid-trading, deposit-earning, otc-options
        //         "subtype" => "",     // The corresponding trading symbol (currency pair) the isolated margin is based on, e.g. btcusdt
        //         "state" => "working" // working, lock
        //     }
        //
        $typeId = $this->safe_string($account, 'type');
        $accountsById = $this->safe_value($this->options, 'accountsById', array());
        $type = $this->safe_value($accountsById, $typeId, $typeId);
        return array(
            'info' => $account,
            'id' => $this->safe_string($account, 'id'),
            'type' => $type,
            'code' => null,
        );
    }

    public function fetch_account_id_by_type($type, $params = array ()) {
        $accounts = yield $this->load_accounts();
        $accountId = $this->safe_value($params, 'account-id');
        if ($accountId !== null) {
            return $accountId;
        }
        $indexedAccounts = $this->index_by($accounts, 'type');
        $defaultAccount = $this->safe_value($accounts, 0, array());
        $account = $this->safe_value($indexedAccounts, $type, $defaultAccount);
        return $this->safe_string($account, 'id');
    }

    public function fetch_currencies($params = array ()) {
        /**
         * fetches all available currencies on an exchange
         * @param {dict} $params extra parameters specific to the huobi api endpoint
         * @return {dict} an associative dictionary of currencies
         */
        $response = yield $this->spotPublicGetV2ReferenceCurrencies ();
        //     {
        //       "code" => 200,
        //       "data" => array(
        //         {
        //           "currency" => "sxp",
        //           "assetType" => "1",
        //           "chains" => array(
        //             {
        //               "chain" => "sxp",
        //               "displayName" => "ERC20",
        //               "baseChain" => "ETH",
        //               "baseChainProtocol" => "ERC20",
        //               "isDynamic" => true,
        //               "numOfConfirmations" => "12",
        //               "numOfFastConfirmations" => "12",
        //               "depositStatus" => "allowed",
        //               "minDepositAmt" => "0.23",
        //               "withdrawStatus" => "allowed",
        //               "minWithdrawAmt" => "0.23",
        //               "withdrawPrecision" => "8",
        //               "maxWithdrawAmt" => "227000.000000000000000000",
        //               "withdrawQuotaPerDay" => "227000.000000000000000000",
        //               "withdrawQuotaPerYear" => null,
        //               "withdrawQuotaTotal" => null,
        //               "withdrawFeeType" => "fixed",
        //               "transactFeeWithdraw" => "11.1653",
        //               "addrWithTag" => false,
        //               "addrDepositTag" => false
        //             }
        //           ),
        //           "instStatus" => "normal"
        //         }
        //       )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $entry = $data[$i];
            $currencyId = $this->safe_string($entry, 'currency');
            $code = $this->safe_currency_code($currencyId);
            $chains = $this->safe_value($entry, 'chains', array());
            $networks = array();
            $instStatus = $this->safe_string($entry, 'instStatus');
            $currencyActive = $instStatus === 'normal';
            $fee = null;
            $minPrecision = null;
            $minWithdraw = null;
            $maxWithdraw = null;
            $deposit = null;
            $withdraw = null;
            for ($j = 0; $j < count($chains); $j++) {
                $chain = $chains[$j];
                $networkId = $this->safe_string($chain, 'chain');
                $baseChainProtocol = $this->safe_string($chain, 'baseChainProtocol');
                $huobiToken = 'h' . $currencyId;
                if ($baseChainProtocol === null) {
                    if ($huobiToken === $networkId) {
                        $baseChainProtocol = 'ERC20';
                    } else {
                        $baseChainProtocol = $this->safe_string($chain, 'displayName');
                    }
                }
                $network = $this->safe_network($baseChainProtocol);
                $minWithdraw = $this->safe_number($chain, 'minWithdrawAmt');
                $maxWithdraw = $this->safe_number($chain, 'maxWithdrawAmt');
                $withdrawStatus = $this->safe_string($chain, 'withdrawStatus');
                $depositStatus = $this->safe_string($chain, 'depositStatus');
                $withdrawEnabled = ($withdrawStatus === 'allowed');
                $depositEnabled = ($depositStatus === 'allowed');
                $active = $withdrawEnabled && $depositEnabled;
                $precision = $this->safe_string($chain, 'withdrawPrecision');
                if ($precision !== null) {
                    $precision = $this->parse_number('1e-' . $precision);
                    $minPrecision = ($minPrecision === null) ? $precision : max ($precision, $minPrecision);
                }
                if ($withdrawEnabled && !$withdraw) {
                    $withdraw = true;
                } elseif (!$withdrawEnabled) {
                    $withdraw = false;
                }
                if ($depositEnabled && !$deposit) {
                    $deposit = true;
                } elseif (!$depositEnabled) {
                    $deposit = false;
                }
                $fee = $this->safe_number($chain, 'transactFeeWithdraw');
                $networks[$network] = array(
                    'info' => $chain,
                    'id' => $networkId,
                    'network' => $network,
                    'limits' => array(
                        'withdraw' => array(
                            'min' => $minWithdraw,
                            'max' => $maxWithdraw,
                        ),
                    ),
                    'active' => $active,
                    'deposit' => $depositEnabled,
                    'withdraw' => $withdrawEnabled,
                    'fee' => $fee,
                    'precision' => $precision,
                );
            }
            $networksKeys = is_array($networks) ? array_keys($networks) : array();
            $networkLength = is_array($networksKeys) ? count($networksKeys) : 0;
            $result[$code] = array(
                'info' => $entry,
                'code' => $code,
                'id' => $currencyId,
                'active' => $currencyActive,
                'deposit' => $deposit,
                'withdraw' => $withdraw,
                'fee' => ($networkLength <= 1) ? $fee : null,
                'name' => null,
                'limits' => array(
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'withdraw' => array(
                        'min' => ($networkLength <= 1) ? $minWithdraw : null,
                        'max' => ($networkLength <= 1) ? $maxWithdraw : null,
                    ),
                ),
                'precision' => $minPrecision,
                'networks' => $networks,
            );
        }
        return $result;
    }

    public function fetch_balance($params = array ()) {
        /**
         * query for $balance and get the amount of funds available for trading or funds locked in orders
         * @param {dict} $params extra parameters specific to the huobi api endpoint
         * @return {dict} a ~@link https://docs.ccxt.com/en/latest/manual.html?#$balance-structure $balance structure~
         */
        yield $this->load_markets();
        $type = null;
        list($type, $params) = $this->handle_market_type_and_params('fetchBalance', null, $params);
        $options = $this->safe_value($this->options, 'fetchBalance', array());
        $request = array();
        $method = null;
        $spot = ($type === 'spot');
        $future = ($type === 'future');
        $swap = ($type === 'swap');
        $defaultSubType = $this->safe_string_2($this->options, 'defaultSubType', 'subType', 'inverse');
        $subType = $this->safe_string_2($options, 'defaultSubType', 'subType', $defaultSubType);
        $subType = $this->safe_string_2($params, 'defaultSubType', 'subType', $subType);
        $inverse = ($subType === 'inverse');
        $linear = ($subType === 'linear');
        $marginMode = $this->safe_string_2($this->options, 'defaultMarginMode', 'marginMode', 'isolated');
        $marginMode = $this->safe_string_2($options, 'defaultMarginMode', 'marginMode', $marginMode);
        $marginMode = $this->safe_string_2($params, 'defaultMarginMode', 'marginMode', $marginMode);
        $params = $this->omit($params, array( 'defaultSubType', 'subType', 'defaultMarginMode', 'marginMode' ));
        $isolated = ($marginMode === 'isolated');
        $cross = ($marginMode === 'cross');
        if ($spot) {
            yield $this->load_accounts();
            $accountId = yield $this->fetch_account_id_by_type($type, $params);
            $request['account-id'] = $accountId;
            $method = 'spotPrivateGetV1AccountAccountsAccountIdBalance';
        } elseif ($linear) {
            if ($marginMode === 'isolated') {
                $method = 'contractPrivatePostLinearSwapApiV1SwapAccountInfo';
            } else {
                $method = 'contractPrivatePostLinearSwapApiV1SwapCrossAccountInfo';
            }
        } elseif ($inverse) {
            if ($future) {
                $method = 'contractPrivatePostApiV1ContractAccountInfo';
            } elseif ($swap) {
                $method = 'contractPrivatePostSwapApiV1SwapAccountInfo';
            }
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // $spot
        //
        //     {
        //         "status":"ok",
        //         "data":array(
        //             "id":1528640,
        //             "type":"spot",
        //             "state":"working",
        //             "list":array(
        //                 array("currency":"lun","type":"trade","balance":"0","seq-num":"0"),
        //                 array("currency":"lun","type":"frozen","balance":"0","seq-num":"0"),
        //                 array("currency":"ht","type":"frozen","balance":"0","seq-num":"145"),
        //             )
        //         ),
        //         "ts":1637644827566
        //     }
        //
        // $future, $swap $isolated
        //
        //     {
        //         "status":"ok",
        //         "data":array(
        //             array(
        //                 "symbol":"BTC",
        //                 "margin_balance":0,
        //                 "margin_position":0E-18,
        //                 "margin_frozen":0,
        //                 "margin_available":0E-18,
        //                 "profit_real":0,
        //                 "profit_unreal":0,
        //                 "risk_rate":null,
        //                 "withdraw_available":0,
        //                 "liquidation_price":null,
        //                 "lever_rate":5,
        //                 "adjust_factor":0.025000000000000000,
        //                 "margin_static":0,
        //                 "is_debit":0, // $future only
        //                 "contract_code":"BTC-USD", // $swap only
        //                 "margin_asset":"USDT", // $linear only
        //                 "margin_mode":"isolated", // $linear only
        //                 "margin_account":"BTC-USDT" // $linear only
        //                 "transfer_profit_ratio":null // $inverse only
        //             ),
        //         ),
        //         "ts":1637644827566
        //     }
        //
        // $linear $cross futures and $linear $cross $swap
        //
        //     {
        //         "status":"ok",
        //         "data":array(
        //             {
        //                 "futures_contract_detail":array(
        //                     array(
        //                         "symbol":"ETH",
        //                         "contract_code":"ETH-USDT-220325",
        //                         "margin_position":0,
        //                         "margin_frozen":0,
        //                         "margin_available":200.000000000000000000,
        //                         "profit_unreal":0E-18,
        //                         "liquidation_price":null,
        //                         "lever_rate":5,
        //                         "adjust_factor":0.060000000000000000,
        //                         "contract_type":"quarter",
        //                         "pair":"ETH-USDT",
        //                         "business_type":"futures"
        //                     ),
        //                 ),
        //                 "margin_mode":"cross",
        //                 "margin_account":"USDT",
        //                 "margin_asset":"USDT",
        //                 "margin_balance":200.000000000000000000,
        //                 "margin_static":200.000000000000000000,
        //                 "margin_position":0,
        //                 "margin_frozen":0,
        //                 "profit_real":0E-18,
        //                 "profit_unreal":0,
        //                 "withdraw_available":2E+2,
        //                 "risk_rate":null,
        //                 "contract_detail":array(
        //                     array(
        //                         "symbol":"MANA",
        //                         "contract_code":"MANA-USDT",
        //                         "margin_position":0,
        //                         "margin_frozen":0,
        //                         "margin_available":200.000000000000000000,
        //                         "profit_unreal":0E-18,
        //                         "liquidation_price":null,
        //                         "lever_rate":5,
        //                         "adjust_factor":0.100000000000000000,
        //                         "contract_type":"swap",
        //                         "pair":"MANA-USDT",
        //                         "business_type":"swap"
        //                     ),
        //                 )
        //             }
        //         ),
        //         "ts":1640915104870
        //     }
        //
        // TODO add $balance parsing for $linear $swap
        //
        $result = array( 'info' => $response );
        $data = $this->safe_value($response, 'data');
        if ($spot) {
            $balances = $this->safe_value($data, 'list', array());
            for ($i = 0; $i < count($balances); $i++) {
                $balance = $balances[$i];
                $currencyId = $this->safe_string($balance, 'currency');
                $code = $this->safe_currency_code($currencyId);
                $account = null;
                if (is_array($result) && array_key_exists($code, $result)) {
                    $account = $result[$code];
                } else {
                    $account = $this->account();
                }
                if ($balance['type'] === 'trade') {
                    $account['free'] = $this->safe_string($balance, 'balance');
                }
                if ($balance['type'] === 'frozen') {
                    $account['used'] = $this->safe_string($balance, 'balance');
                }
                $result[$code] = $account;
            }
        } elseif ($linear) {
            $first = $this->safe_value($data, 0, array());
            if ($cross) {
                $account = $this->account();
                $account['free'] = $this->safe_string($first, 'margin_balance', 'margin_available');
                $account['used'] = $this->safe_string($first, 'margin_frozen');
                $currencyId = $this->safe_string_2($first, 'margin_asset', 'symbol');
                $code = $this->safe_currency_code($currencyId);
                $result[$code] = $account;
            } elseif ($isolated) {
                for ($i = 0; $i < count($data); $i++) {
                    $balance = $data[$i];
                    $marketId = $this->safe_string_2($balance, 'contract_code', 'margin_account');
                    $market = $this->safe_market($marketId);
                    $currencyId = $this->safe_string($balance, 'margin_asset');
                    $currency = $this->safe_currency($currencyId);
                    $code = $this->safe_string($market, 'settle', $currency['code']);
                    // the exchange outputs positions for delisted markets
                    // https://www.huobi.com/support/en-us/detail/74882968522337
                    // we skip it if the $market was delisted
                    if ($code !== null) {
                        $account = $this->account();
                        $account['free'] = $this->safe_string($balance, 'margin_balance');
                        $account['used'] = $this->safe_string($balance, 'margin_frozen');
                        $accountsByCode = array();
                        $accountsByCode[$code] = $account;
                        $symbol = $market['symbol'];
                        $result[$symbol] = $this->safe_balance($accountsByCode);
                    }
                }
                return $result;
            }
        } elseif ($inverse) {
            for ($i = 0; $i < count($data); $i++) {
                $balance = $data[$i];
                $currencyId = $this->safe_string($balance, 'symbol');
                $code = $this->safe_currency_code($currencyId);
                $account = $this->account();
                $account['free'] = $this->safe_string($balance, 'margin_available');
                $account['used'] = $this->safe_string($balance, 'margin_frozen');
                $result[$code] = $account;
            }
        }
        return $this->safe_balance($result);
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        yield $this->load_markets();
        $marketType = null;
        list($marketType, $params) = $this->handle_market_type_and_params('fetchOrder', null, $params);
        $request = array(
            // spot -----------------------------------------------------------
            // 'order-id' => 'id',
            // 'symbol' => $market['id'],
            // 'client-$order-id' => $clientOrderId,
            // 'clientOrderId' => $clientOrderId,
            // contracts ------------------------------------------------------
            // 'order_id' => $id,
            // 'client_order_id' => $clientOrderId,
            // 'contract_code' => $market['id'],
            // 'pair' => 'BTC-USDT',
            // 'contract_type' => 'this_week', // swap, this_week, next_week, quarter, next_ quarter
        );
        $method = null;
        $market = null;
        if ($marketType === 'spot') {
            $clientOrderId = $this->safe_string($params, 'clientOrderId');
            $method = 'spotPrivateGetV1OrderOrdersOrderId';
            if ($clientOrderId !== null) {
                $method = 'spotPrivateGetV1OrderOrdersGetClientOrder';
                // will be filled below in extend ()
                // they expect $clientOrderId instead of client-$order-$id
                // $request['clientOrderId'] = $clientOrderId;
            } else {
                $request['order-id'] = $id;
            }
        } else {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchOrder() requires a $symbol for ' . $marketType . ' orders');
            }
            $market = $this->market($symbol);
            $request['contract_code'] = $market['id'];
            if ($market['linear']) {
                $defaultMargin = $market['future'] ? 'cross' : 'isolated';
                $marginMode = $this->safe_string_2($this->options, 'defaultMarginMode', 'marginMode', $defaultMargin);
                if ($marginMode === 'isolated') {
                    $method = 'contractPrivatePostLinearSwapApiV1SwapOrderInfo';
                } elseif ($marginMode === 'cross') {
                    $method = 'contractPrivatePostLinearSwapApiV1SwapCrossOrderInfo';
                }
            } elseif ($market['inverse']) {
                if ($marketType === 'future') {
                    $method = 'contractPrivatePostApiV1ContractOrderInfo';
                    $request['symbol'] = $market['settleId'];
                } elseif ($marketType === 'swap') {
                    $method = 'contractPrivatePostSwapApiV1SwapOrderInfo';
                } else {
                    throw new NotSupported($this->id . ' fetchOrder() does not support ' . $marketType . ' markets');
                }
            }
            $clientOrderId = $this->safe_string_2($params, 'client_order_id', 'clientOrderId');
            if ($clientOrderId === null) {
                $request['order_id'] = $id;
            } else {
                $request['client_order_id'] = $clientOrderId;
                $params = $this->omit($params, array( 'client_order_id', 'clientOrderId' ));
            }
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot
        //
        //     {
        //         "status":"ok",
        //         "data":{
        //             "id":438398393065481,
        //             "symbol":"ethusdt",
        //             "account-$id":1528640,
        //             "client-$order-$id":"AA03022abc2163433e-006b-480e-9ad1-d4781478c5e7",
        //             "amount":"0.100000000000000000",
        //             "price":"3000.000000000000000000",
        //             "created-at":1640549994642,
        //             "type":"buy-limit",
        //             "field-amount":"0.0",
        //             "field-cash-amount":"0.0",
        //             "field-fees":"0.0",
        //             "finished-at":0,
        //             "source":"spot-api",
        //             "state":"submitted",
        //             "canceled-at":0
        //         }
        //     }
        //
        // linear swap cross margin
        //
        //     {
        //         "status":"ok",
        //         "data":array(
        //             {
        //                 "business_type":"swap",
        //                 "contract_type":"swap",
        //                 "pair":"BTC-USDT",
        //                 "symbol":"BTC",
        //                 "contract_code":"BTC-USDT",
        //                 "volume":1,
        //                 "price":3000,
        //                 "order_price_type":"limit",
        //                 "order_type":1,
        //                 "direction":"buy",
        //                 "offset":"open",
        //                 "lever_rate":1,
        //                 "order_id":924912513206878210,
        //                 "client_order_id":null,
        //                 "created_at":1640557927189,
        //                 "trade_volume":0,
        //                 "trade_turnover":0,
        //                 "fee":0,
        //                 "trade_avg_price":null,
        //                 "margin_frozen":3.000000000000000000,
        //                 "profit":0,
        //                 "status":3,
        //                 "order_source":"api",
        //                 "order_id_str":"924912513206878210",
        //                 "fee_asset":"USDT",
        //                 "liquidation_type":"0",
        //                 "canceled_at":0,
        //                 "margin_asset":"USDT",
        //                 "margin_account":"USDT",
        //                 "margin_mode":"cross",
        //                 "is_tpsl":0,
        //                 "real_profit":0
        //             }
        //         ),
        //         "ts":1640557982556
        //     }
        //
        // linear swap isolated margin detail
        //
        //     {
        //         "status" => "ok",
        //         "data" => {
        //             "symbol" => "BTC",
        //             "contract_code" => "BTC-USDT",
        //             "instrument_price" => 0,
        //             "final_interest" => 0,
        //             "adjust_value" => 0,
        //             "lever_rate" => 10,
        //             "direction" => "sell",
        //             "offset" => "open",
        //             "volume" => 1.000000000000000000,
        //             "price" => 13059.800000000000000000,
        //             "created_at" => 1603703614712,
        //             "canceled_at" => 0,
        //             "order_source" => "api",
        //             "order_price_type" => "opponent",
        //             "margin_frozen" => 0,
        //             "profit" => 0,
        //             "trades" => array(
        //                 array(
        //                     "trade_id" => 131560927,
        //                     "trade_price" => 13059.800000000000000000,
        //                     "trade_volume" => 1.000000000000000000,
        //                     "trade_turnover" => 13.059800000000000000,
        //                     "trade_fee" => -0.005223920000000000,
        //                     "created_at" => 1603703614715,
        //                     "role" => "taker",
        //                     "fee_asset" => "USDT",
        //                     "profit" => 0,
        //                     "real_profit" => 0,
        //                     "id" => "131560927-770334322963152896-1"
        //                 }
        //             ),
        //             "total_page" => 1,
        //             "current_page" => 1,
        //             "total_size" => 1,
        //             "liquidation_type" => "0",
        //             "fee_asset" => "USDT",
        //             "fee" => -0.005223920000000000,
        //             "order_id" => 770334322963152896,
        //             "order_id_str" => "770334322963152896",
        //             "client_order_id" => 57012021045,
        //             "order_type" => "1",
        //             "status" => 6,
        //             "trade_avg_price" => 13059.800000000000000000,
        //             "trade_turnover" => 13.059800000000000000,
        //             "trade_volume" => 1.000000000000000000,
        //             "margin_asset" => "USDT",
        //             "margin_mode" => "isolated",
        //             "margin_account" => "BTC-USDT",
        //             "real_profit" => 0,
        //             "is_tpsl" => 0
        //         ),
        //         "ts" => 1603703678477
        //     }
        $order = $this->safe_value($response, 'data');
        if (gettype($order) === 'array' && count(array_filter(array_keys($order), 'is_string')) == 0) {
            $order = $this->safe_value($order, 0);
        }
        return $this->parse_order($order);
    }

    public function fetch_spot_orders_by_states($states, $symbol = null, $since = null, $limit = null, $params = array ()) {
        $method = $this->safe_string($this->options, 'fetchOrdersByStatesMethod', 'spot_private_get_v1_order_orders'); // spot_private_get_v1_order_history
        if ($method === 'spot_private_get_v1_order_orders') {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchOrders() requires a $symbol argument');
            }
        }
        yield $this->load_markets();
        $market = null;
        $request = array(
            // spot_private_get_v1_order_orders GET /v1/order/orders ----------
            // 'symbol' => $market['id'], // required
            // 'types' => 'buy-$market,sell-$market,buy-$limit,sell-$limit,buy-ioc,sell-ioc,buy-stop-$limit,sell-stop-$limit,buy-$limit-fok,sell-$limit-fok,buy-stop-$limit-fok,sell-stop-$limit-fok',
            // 'start-time' => $since, // max window of 48h within a range of 180 days, within past 2 hours for cancelled orders
            // 'end-time' => $this->milliseconds(),
            'states' => $states, // filled, partial-canceled, canceled
            // 'from' => order['id'],
            // 'direct' => 'next', // next, prev, used with from
            // 'size' => 100, // max 100
            // spot_private_get_v1_order_history GET /v1/order/history --------
            // 'symbol' => $market['id'], // optional
            // 'start-time' => $since, // max window of 48h within a range of 180 days, within past 2 hours for cancelled orders
            // 'end-time' => $this->milliseconds(),
            // 'direct' => 'next', // next, prev, used with from
            // 'size' => 100, // max 100
        );
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            $request['start-time'] = $since; // a window of 48 hours within 180 days
            $request['end-time'] = $this->sum($since, 48 * 60 * 60 * 1000);
        }
        if ($limit !== null) {
            $request['size'] = $limit;
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot_private_get_v1_order_orders GET /v1/order/orders
        //
        //     {
        //         status => "ok",
        //         $data => array(
        //             {
        //                 id => 13997833014,
        //                 $symbol => "ethbtc",
        //                 'account-id' => 3398321,
        //                 'client-order-id' => "23456",
        //                 amount => "0.045000000000000000",
        //                 price => "0.034014000000000000",
        //                 'created-at' => 1545836976871,
        //                 type => "sell-$limit",
        //                 'field-amount' => "0.045000000000000000",
        //                 'field-cash-amount' => "0.001530630000000000",
        //                 'field-fees' => "0.000003061260000000",
        //                 'finished-at' => 1545837948214,
        //                 source => "spot-api",
        //                 state => "filled",
        //                 'canceled-at' => 0
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_orders($data, $market, $since, $limit);
    }

    public function fetch_spot_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return yield $this->fetch_spot_orders_by_states('pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled', $symbol, $since, $limit, $params);
    }

    public function fetch_closed_spot_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return yield $this->fetch_spot_orders_by_states('filled,partial-canceled,canceled', $symbol, $since, $limit, $params);
    }

    public function fetch_contract_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchContractOrders() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $marketType = null;
        list($marketType, $params) = $this->handle_market_type_and_params('fetchOrders', $market, $params);
        $request = array(
            // POST /api/v1/contract_hisorders inverse futures ----------------
            // 'symbol' => $market['settleId'], // BTC, ETH, ...
            // 'order_type' => '1', // 1 $limit，3 opponent，4 lightning, 5 trigger order, 6 pst_only, 7 optimal_5, 8 optimal_10, 9 optimal_20, 10 fok, 11 ioc
            // POST /swap-api/v1/swap_hisorders inverse swap ------------------
            // POST /linear-swap-api/v1/swap_hisorders linear isolated --------
            // POST /linear-swap-api/v1/swap_cross_hisorders linear cross -----
            'contract_code' => $market['id'],
            'trade_type' => 0, // 0 all, 1 buy long, 2 sell short, 3 buy short, 4 sell long, 5 sell liquidation, 6 buy liquidation, 7 Delivery long, 8 Delivery short 11 reduce positions to close long, 12 reduce positions to close short
            'type' => 1, // 1 all $orders, 2 finished $orders
            'status' => '0', // comma separated, 0 all, 3 submitted $orders, 4 partially matched, 5 partially cancelled, 6 fully matched and closed, 7 canceled
            'create_date' => 90, // in days?
            // 'page_index' => 1,
            // 'page_size' => $limit, // default 20, max 50
            // 'sort_by' => 'create_date', // create_date descending, update_time descending
        );
        $method = null;
        $request['contract_code'] = $market['id'];
        if ($market['linear']) {
            $defaultMargin = $market['future'] ? 'cross' : 'isolated';
            $marginMode = $this->safe_string_2($this->options, 'defaultMarginMode', 'marginMode', $defaultMargin);
            $method = $this->get_supported_mapping($marginMode, array(
                'isolated' => 'contractPrivatePostLinearSwapApiV1SwapHisorders',
                'cross' => 'contractPrivatePostLinearSwapApiV1SwapCrossHisorders',
            ));
        } elseif ($market['inverse']) {
            $method = $this->get_supported_mapping($marketType, array(
                'future' => 'contractPrivatePostApiV1ContractHisorders',
                'swap' => 'contractPrivatePostSwapApiV1SwapHisorders',
            ));
            if ($marketType === 'future') {
                $request['symbol'] = $market['settleId'];
            }
        }
        if ($limit !== null) {
            $request['page_size'] = $limit;
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        //     {
        //         "status" => "ok",
        //         "data" => {
        //             "orders" => array(
        //                 array(
        //                     "order_id" => 773131315209248768,
        //                     "contract_code" => "ADA201225",
        //                     "symbol" => "ADA",
        //                     "lever_rate" => 20,
        //                     "direction" => "buy",
        //                     "offset" => "close",
        //                     "volume" => 1,
        //                     "price" => 0.0925,
        //                     "create_date" => 1604370469629,
        //                     "update_time" => 1603704221118,
        //                     "order_source" => "web",
        //                     "order_price_type" => 6,
        //                     "order_type" => 1,
        //                     "margin_frozen" => 0,
        //                     "profit" => 0,
        //                     "contract_type" => "quarter",
        //                     "trade_volume" => 0,
        //                     "trade_turnover" => 0,
        //                     "fee" => 0,
        //                     "trade_avg_price" => 0,
        //                     "status" => 3,
        //                     "order_id_str" => "773131315209248768",
        //                     "fee_asset" => "ADA",
        //                     "liquidation_type" => "0",
        //                     "is_tpsl" => 0,
        //                     "real_profit" => 0
        //                     "margin_asset" => "USDT",
        //                     "margin_mode" => "cross",
        //                     "margin_account" => "USDT",
        //                     "trade_partition" => "USDT", // only in isolated & cross of linear
        //                     "reduce_only" => "1", // only in isolated & cross of linear
        //                     "contract_type" => "quarter", // only in cross-margin (inverse & linear)
        //                     "pair" => "BTC-USDT", // only in cross-margin (inverse & linear)
        //                     "business_type" => "futures" // only in cross-margin (inverse & linear)
        //                 }
        //             ),
        //             "total_page" => 19,
        //             "current_page" => 1,
        //             "total_size" => 19
        //         ),
        //         "ts" => 1604370617322
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $orders = $this->safe_value($data, 'orders', array());
        return $this->parse_orders($orders, $market, $since, $limit);
    }

    public function fetch_closed_contract_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $request = array(
            'status' => '5,6,7', // comma separated, 0 all, 3 submitted orders, 4 partially matched, 5 partially cancelled, 6 fully matched and closed, 7 canceled
        );
        return yield $this->fetch_contract_orders($symbol, $since, $limit, array_merge($request, $params));
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $marketType = null;
        list($marketType, $params) = $this->handle_market_type_and_params('fetchOrders', null, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'fetchSpotOrders',
            'swap' => 'fetchContractOrders',
            'future' => 'fetchContractOrders',
        ));
        if ($method === null) {
            throw new NotSupported($this->id . ' fetchOrders() does not support ' . $marketType . ' markets yet');
        }
        $contract = ($marketType === 'swap') || ($marketType === 'future');
        if ($contract && ($symbol === null)) {
            throw new ArgumentsRequired($this->id . ' fetchOrders() requires a $symbol argument for ' . $marketType . ' orders');
        }
        return yield $this->$method ($symbol, $since, $limit, $params);
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $marketType = null;
        list($marketType, $params) = $this->handle_market_type_and_params('fetchClosedOrders', null, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'fetchClosedSpotOrders',
            'swap' => 'fetchClosedContractOrders',
            'future' => 'fetchClosedContractOrders',
        ));
        if ($method === null) {
            throw new NotSupported($this->id . ' fetchClosedOrders() does not support ' . $marketType . ' markets yet');
        }
        return yield $this->$method ($symbol, $since, $limit, $params);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $marketType = null;
        list($marketType, $params) = $this->handle_market_type_and_params('fetchOpenOrders', null, $params);
        $request = array(
            // spot -----------------------------------------------------------
            // 'account-id' => $account['id'],
            // 'symbol' => $market['id'],
            // 'side' => 'buy', // buy, sell
            // 'from' => 'id', // order id to begin with
            // 'direct' => 'prev', // prev, next, mandatory if from is defined
            // 'size' => 100, // default 100, max 500
            // futures --------------------------------------------------------
            // 'symbol' => $market['settleId'],
            // 'page_index' => 1, // default 1
            // 'page_size' => $limit, // default 20, max 50
            // 'sort_by' => 'created_at', // created_at, update_time, descending sorting field
            // 'trade_type' => 0, // 0 all, 1 buy long, 2 sell short, 3 buy short, 4 sell long
        );
        $method = null;
        $market = null;
        if ($marketType === 'spot') {
            $method = 'spotPrivateGetV1OrderOpenOrders';
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            // todo replace with fetchAccountIdByType
            $accountId = $this->safe_string($params, 'account-id');
            if ($accountId === null) {
                // pick the first $account
                yield $this->load_accounts();
                for ($i = 0; $i < count($this->accounts); $i++) {
                    $account = $this->accounts[$i];
                    if ($account['type'] === 'spot') {
                        $accountId = $this->safe_string($account, 'id');
                        if ($accountId !== null) {
                            break;
                        }
                    }
                }
            }
            $request['account-id'] = $accountId;
            if ($limit !== null) {
                $request['size'] = $limit;
            }
            $params = $this->omit($params, 'account-id');
        } else {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchOpenOrders() requires a $symbol for ' . $marketType . ' orders');
            }
            $market = $this->market($symbol);
            $request['contract_code'] = $market['id'];
            if ($market['linear']) {
                $defaultMargin = $market['future'] ? 'cross' : 'isolated';
                $marginMode = $this->safe_string_2($this->options, 'defaultMarginMode', 'marginMode', $defaultMargin);
                if ($marginMode === 'isolated') {
                    $method = 'contractPrivatePostLinearSwapApiV1SwapOpenorders';
                } elseif ($marginMode === 'cross') {
                    $method = 'contractPrivatePostLinearSwapApiV1SwapCrossOpenorders';
                }
            } elseif ($market['inverse']) {
                if ($market['future']) {
                    $method = 'contractPrivatePostApiV1ContractOpenorders';
                    $request['symbol'] = $market['settleId'];
                } elseif ($market['swap']) {
                    $method = 'contractPrivatePostSwapApiV1SwapOpenorders';
                }
            }
            if ($limit !== null) {
                $request['page_size'] = $limit;
            }
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot
        //
        //     {
        //         "status":"ok",
        //         "data":array(
        //             {
        //                 "symbol":"ethusdt",
        //                 "source":"api",
        //                 "amount":"0.010000000000000000",
        //                 "account-id":1528640,
        //                 "created-at":1561597491963,
        //                 "price":"400.000000000000000000",
        //                 "filled-amount":"0.0",
        //                 "filled-cash-amount":"0.0",
        //                 "filled-fees":"0.0",
        //                 "id":38477101630,
        //                 "state":"submitted",
        //                 "type":"sell-$limit"
        //             }
        //         )
        //     }
        //
        // futures
        //
        //     {
        //         "status" => "ok",
        //         "data" => {
        //             "orders" => array(
        //                 array(
        //                     "symbol" => "ADA",
        //                     "contract_code" => "ADA201225",
        //                     "contract_type" => "quarter",
        //                     "volume" => 1,
        //                     "price" => 0.0925,
        //                     "order_price_type" => "post_only",
        //                     "order_type" => 1,
        //                     "direction" => "buy",
        //                     "offset" => "close",
        //                     "lever_rate" => 20,
        //                     "order_id" => 773131315209248768,
        //                     "client_order_id" => null,
        //                     "created_at" => 1604370469629,
        //                     "trade_volume" => 0,
        //                     "trade_turnover" => 0,
        //                     "fee" => 0,
        //                     "trade_avg_price" => null,
        //                     "margin_frozen" => 0,
        //                     "profit" => 0,
        //                     "status" => 3,
        //                     "order_source" => "web",
        //                     "order_id_str" => "773131315209248768",
        //                     "fee_asset" => "ADA",
        //                     "liquidation_type" => null,
        //                     "canceled_at" => null,
        //                     "is_tpsl" => 0,
        //                     "update_time" => 1606975980467,
        //                     "real_profit" => 0
        //                 }
        //             ),
        //             "total_page" => 1,
        //             "current_page" => 1,
        //             "total_size" => 1
        //         ),
        //         "ts" => 1604370488518
        //     }
        //
        $orders = $this->safe_value($response, 'data');
        if (gettype($orders) === 'array' && count(array_filter(array_keys($orders), 'is_string')) != 0) {
            $orders = $this->safe_value($orders, 'orders', array());
        }
        return $this->parse_orders($orders, $market, $since, $limit);
    }

    public function parse_order_status($status) {
        $statuses = array(
            // spot
            'partial-filled' => 'open',
            'partial-canceled' => 'canceled',
            'filled' => 'closed',
            'canceled' => 'canceled',
            'submitted' => 'open',
            'created' => 'open',  // For stop orders
            // contract
            '1' => 'open',
            '2' => 'open',
            '3' => 'open',
            '4' => 'open',
            '5' => 'canceled', // partially matched
            '6' => 'closed',
            '7' => 'canceled',
            '11' => 'canceling',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order($order, $market = null) {
        //
        // spot
        //
        //     {
        //         $id =>  13997833014,
        //         symbol => "ethbtc",
        //         'account-id' =>  3398321,
        //         $amount => "0.045000000000000000",
        //         $price => "0.034014000000000000",
        //         'created-at' =>  1545836976871,
        //         $type => "sell-limit",
        //         'field-amount' => "0.045000000000000000", // they have fixed it for $filled-$amount
        //         'field-cash-amount' => "0.001530630000000000", // they have fixed it for $filled-cash-$amount
        //         'field-fees' => "0.000003061260000000", // they have fixed it for $filled-fees
        //         'finished-at' =>  1545837948214,
        //         source => "spot-api",
        //         state => "filled",
        //         'canceled-at' =>  0
        //     }
        //
        //     {
        //         $id =>  20395337822,
        //         symbol => "ethbtc",
        //         'account-id' =>  5685075,
        //         $amount => "0.001000000000000000",
        //         $price => "0.0",
        //         'created-at' =>  1545831584023,
        //         $type => "buy-$market",
        //         'field-amount' => "0.029100000000000000", // they have fixed it for $filled-$amount
        //         'field-cash-amount' => "0.000999788700000000", // they have fixed it for $filled-cash-$amount
        //         'field-fees' => "0.000058200000000000", // they have fixed it for $filled-fees
        //         'finished-at' =>  1545831584181,
        //         source => "spot-api",
        //         state => "filled",
        //         'canceled-at' =>  0
        //     }
        //
        // linear swap cross margin createOrder
        //
        //     {
        //         "order_id":924660854912552960,
        //         "order_id_str":"924660854912552960"
        //     }
        //
        // contracts fetchOrder
        //
        //     {
        //         "business_type":"swap",
        //         "contract_type":"swap",
        //         "pair":"BTC-USDT",
        //         "symbol":"BTC",
        //         "contract_code":"BTC-USDT",
        //         "volume":1,
        //         "price":3000,
        //         "order_price_type":"limit",
        //         "order_type":1,
        //         "direction":"buy",
        //         "offset":"open",
        //         "lever_rate":1,
        //         "order_id":924912513206878210,
        //         "client_order_id":null,
        //         "created_at":1640557927189,
        //         "trade_volume":0,
        //         "trade_turnover":0,
        //         "fee":0,
        //         "trade_avg_price":null,
        //         "margin_frozen":3.000000000000000000,
        //         "profit":0,
        //         "status":3,
        //         "order_source":"api",
        //         "order_id_str":"924912513206878210",
        //         "fee_asset":"USDT",
        //         "liquidation_type":"0",
        //         "canceled_at":0,
        //         "margin_asset":"USDT",
        //         "margin_account":"USDT",
        //         "margin_mode":"cross",
        //         "is_tpsl":0,
        //         "real_profit":0
        //     }
        //
        // contracts fetchOrder detailed
        //
        //     {
        //         "symbol" => "BTC",
        //         "contract_code" => "BTC-USDT",
        //         "instrument_price" => 0,
        //         "final_interest" => 0,
        //         "adjust_value" => 0,
        //         "lever_rate" => 10,
        //         "direction" => "sell",
        //         "offset" => "open",
        //         "volume" => 1.000000000000000000,
        //         "price" => 13059.800000000000000000,
        //         "created_at" => 1603703614712,
        //         "canceled_at" => 0,
        //         "order_source" => "api",
        //         "order_price_type" => "opponent",
        //         "margin_frozen" => 0,
        //         "profit" => 0,
        //         "trades" => array(
        //             {
        //                 "trade_id" => 131560927,
        //                 "trade_price" => 13059.800000000000000000,
        //                 "trade_volume" => 1.000000000000000000,
        //                 "trade_turnover" => 13.059800000000000000,
        //                 "trade_fee" => -0.005223920000000000,
        //                 "created_at" => 1603703614715,
        //                 "role" => "taker",
        //                 "fee_asset" => "USDT",
        //                 "profit" => 0,
        //                 "real_profit" => 0,
        //                 "id" => "131560927-770334322963152896-1"
        //             }
        //         ),
        //         "total_page" => 1,
        //         "current_page" => 1,
        //         "total_size" => 1,
        //         "liquidation_type" => "0",
        //         "fee_asset" => "USDT",
        //         "fee" => -0.005223920000000000,
        //         "order_id" => 770334322963152896,
        //         "order_id_str" => "770334322963152896",
        //         "client_order_id" => 57012021045,
        //         "order_type" => "1",
        //         "status" => 6,
        //         "trade_avg_price" => 13059.800000000000000000,
        //         "trade_turnover" => 13.059800000000000000,
        //         "trade_volume" => 1.000000000000000000,
        //         "margin_asset" => "USDT",
        //         "margin_mode" => "isolated",
        //         "margin_account" => "BTC-USDT",
        //         "real_profit" => 0,
        //         "is_tpsl" => 0
        //     }
        //
        // fetchOrders
        //
        //     {
        //         "order_id" => 773131315209248768,
        //         "contract_code" => "ADA201225",
        //         "symbol" => "ADA",
        //         "lever_rate" => 20,
        //         "direction" => "buy",
        //         "offset" => "close",
        //         "volume" => 1,
        //         "price" => 0.0925,
        //         "create_date" => 1604370469629,
        //         "update_time" => 1603704221118,
        //         "order_source" => "web",
        //         "order_price_type" => 6,
        //         "order_type" => 1,
        //         "margin_frozen" => 0,
        //         "profit" => 0,
        //         "contract_type" => "quarter",
        //         "trade_volume" => 0,
        //         "trade_turnover" => 0,
        //         "fee" => 0,
        //         "trade_avg_price" => 0,
        //         "status" => 3,
        //         "order_id_str" => "773131315209248768",
        //         "fee_asset" => "ADA",
        //         "liquidation_type" => "0",
        //         "is_tpsl" => 0,
        //         "real_profit" => 0
        //         "margin_asset" => "USDT",
        //         "margin_mode" => "cross",
        //         "margin_account" => "USDT",
        //         "trade_partition" => "USDT", // only in isolated & cross of linear
        //         "reduce_only" => "1", // only in isolated & cross of linear
        //         "contract_type" => "quarter", // only in cross-margin (inverse & linear)
        //         "pair" => "BTC-USDT", // only in cross-margin (inverse & linear)
        //         "business_type" => "futures" // only in cross-margin (inverse & linear)
        //     }
        //
        $id = $this->safe_string_2($order, 'id', 'order_id_str');
        $side = $this->safe_string($order, 'direction');
        $type = $this->safe_string($order, 'order_price_type');
        if (is_array($order) && array_key_exists('type', $order)) {
            $orderType = explode('-', $order['type']);
            $side = $orderType[0];
            $type = $orderType[1];
        }
        $status = $this->parse_order_status($this->safe_string_2($order, 'state', 'status'));
        $marketId = $this->safe_string_2($order, 'contract_code', 'symbol');
        $market = $this->safe_market($marketId, $market);
        $timestamp = $this->safe_integer_n($order, array( 'created_at', 'created-at', 'create_date' ));
        $clientOrderId = $this->safe_string_2($order, 'client_order_id', 'client-$order-id');
        $amount = $this->safe_string_2($order, 'volume', 'amount');
        $filled = $this->safe_string_2($order, 'filled-amount', 'field-amount'); // typo in their API, $filled $amount
        $filled = $this->safe_string($order, 'trade_volume', $filled);
        $price = $this->safe_string($order, 'price');
        $cost = $this->safe_string_2($order, 'filled-cash-amount', 'field-cash-amount'); // same typo
        $cost = $this->safe_string($order, 'trade_turnover', $cost);
        $feeCost = $this->safe_string_2($order, 'filled-fees', 'field-fees'); // typo in their API, $filled feeSide
        $feeCost = $this->safe_string($order, 'fee', $feeCost);
        $fee = null;
        if ($feeCost !== null) {
            $feeCurrency = null;
            $feeCurrencyId = $this->safe_string($order, 'fee_asset');
            if ($feeCurrencyId !== null) {
                $feeCurrency = $this->safe_currency_code($feeCurrencyId);
            } else {
                $feeCurrency = ($side === 'sell') ? $market['quote'] : $market['base'];
            }
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrency,
            );
        }
        $stopPrice = $this->safe_string($order, 'stop-price');
        $average = $this->safe_string($order, 'trade_avg_price');
        $trades = $this->safe_value($order, 'trades');
        return $this->safe_order(array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'symbol' => $market['symbol'],
            'type' => $type,
            'timeInForce' => null,
            'postOnly' => null,
            'side' => $side,
            'price' => $price,
            'stopPrice' => $stopPrice,
            'average' => $average,
            'cost' => $cost,
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => null,
            'status' => $status,
            'fee' => $fee,
            'trades' => $trades,
        ), $market);
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        list($marketType, $query) = $this->handle_market_type_and_params('createOrder', $market, $params);
        $method = $this->get_supported_mapping($marketType, array(
            'spot' => 'createSpotOrder',
            'swap' => 'createContractOrder',
            'future' => 'createContractOrder',
        ));
        if ($method === null) {
            throw new NotSupported($this->id . ' createOrder() does not support ' . $marketType . ' markets yet');
        }
        return yield $this->$method ($symbol, $type, $side, $amount, $price, $query);
    }

    public function create_spot_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        yield $this->load_markets();
        yield $this->load_accounts();
        $market = $this->market($symbol);
        $accountId = yield $this->fetch_account_id_by_type($market['type']);
        $request = array(
            // spot -----------------------------------------------------------
            'account-id' => $accountId,
            'symbol' => $market['id'],
            // 'type' => $side . '-' . $type, // buy-$market, sell-$market, buy-limit, sell-limit, buy-ioc, sell-ioc, buy-limit-maker, sell-limit-maker, buy-stop-limit, sell-stop-limit, buy-limit-fok, sell-limit-fok, buy-stop-limit-fok, sell-stop-limit-fok
            // 'amount' => $this->amount_to_precision($symbol, $amount), // for buy $market orders it's the order cost
            // 'price' => $this->price_to_precision($symbol, $price),
            // 'source' => 'spot-api', // optional, spot-api, margin-api = isolated margin, super-margin-api = cross margin, c2c-margin-api
            // 'client-order-id' => $clientOrderId, // optional, max 64 chars, must be unique within 8 hours
            // 'stop-price' => $this->price_to_precision($symbol, $stopPrice), // trigger $price for stop limit orders
            // 'operator' => 'gte', // gte, lte, trigger $price condition
        );
        $orderType = str_replace('buy-', '', $type);
        $orderType = str_replace('sell-', '', $orderType);
        $options = $this->safe_value($this->options, $market['type'], array());
        $stopPrice = $this->safe_string_2($params, 'stopPrice', 'stop-price');
        if ($stopPrice === null) {
            $stopOrderTypes = $this->safe_value($options, 'stopOrderTypes', array());
            if (is_array($stopOrderTypes) && array_key_exists($orderType, $stopOrderTypes)) {
                throw new ArgumentsRequired($this->id . ' createOrder() requires a $stopPrice or a stop-$price parameter for a stop order');
            }
        } else {
            $stopOperator = $this->safe_string($params, 'operator');
            if ($stopOperator === null) {
                throw new ArgumentsRequired($this->id . ' createOrder() requires an operator parameter "gte" or "lte" for a stop order');
            }
            $params = $this->omit($params, array( 'stopPrice', 'stop-price' ));
            $request['stop-price'] = $this->price_to_precision($symbol, $stopPrice);
            $request['operator'] = $stopOperator;
            if (($orderType === 'limit') || ($orderType === 'limit-fok')) {
                $orderType = 'stop-' . $orderType;
            } elseif (($orderType !== 'stop-limit') && ($orderType !== 'stop-limit-fok')) {
                throw new NotSupported($this->id . ' createOrder() does not support ' . $type . ' orders');
            }
        }
        $postOnly = $this->safe_value($params, 'postOnly', false);
        if ($postOnly) {
            $orderType = 'limit-maker';
        }
        $request['type'] = $side . '-' . $orderType;
        $clientOrderId = $this->safe_string_2($params, 'clientOrderId', 'client-order-id'); // must be 64 chars max and unique within 24 hours
        if ($clientOrderId === null) {
            $broker = $this->safe_value($this->options, 'broker', array());
            $brokerId = $this->safe_string($broker, 'id');
            $request['client-order-id'] = $brokerId . $this->uuid();
        } else {
            $request['client-order-id'] = $clientOrderId;
        }
        $params = $this->omit($params, array( 'clientOrderId', 'client-order-id', 'postOnly' ));
        if (($orderType === 'market') && ($side === 'buy')) {
            if ($this->options['createMarketBuyOrderRequiresPrice']) {
                if ($price === null) {
                    throw new InvalidOrder($this->id . " $market buy order requires $price argument to calculate cost (total $amount of quote currency to spend for buying, $amount * $price). To switch off this warning exception and specify cost in the $amount argument, set .options['createMarketBuyOrderRequiresPrice'] = false. Make sure you know what you're doing.");
                } else {
                    // despite that cost = $amount * $price is in quote currency and should have quote precision
                    // the exchange API requires the cost supplied in 'amount' to be of base precision
                    // more about it here:
                    // https://github.com/ccxt/ccxt/pull/4395
                    // https://github.com/ccxt/ccxt/issues/7611
                    // we use amountToPrecision here because the exchange requires cost in base precision
                    $request['amount'] = $this->cost_to_precision($symbol, floatval($amount) * floatval($price));
                }
            } else {
                $request['amount'] = $this->cost_to_precision($symbol, $amount);
            }
        } else {
            $request['amount'] = $this->amount_to_precision($symbol, $amount);
        }
        $limitOrderTypes = $this->safe_value($options, 'limitOrderTypes', array());
        if (is_array($limitOrderTypes) && array_key_exists($orderType, $limitOrderTypes)) {
            $request['price'] = $this->price_to_precision($symbol, $price);
        }
        $response = yield $this->spotPrivatePostV1OrderOrdersPlace (array_merge($request, $params));
        //
        // spot
        //
        //     array("status":"ok","data":"438398393065481")
        //
        $id = $this->safe_string($response, 'data');
        return array(
            'info' => $response,
            'id' => $id,
            'timestamp' => null,
            'datetime' => null,
            'lastTradeTimestamp' => null,
            'status' => null,
            'symbol' => null,
            'type' => null,
            'side' => null,
            'price' => null,
            'amount' => null,
            'filled' => null,
            'remaining' => null,
            'cost' => null,
            'trades' => null,
            'fee' => null,
            'clientOrderId' => null,
            'average' => null,
        );
    }

    public function create_contract_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $offset = $this->safe_string($params, 'offset');
        if ($offset === null) {
            throw new ArgumentsRequired($this->id . ' createOrder() requires a string $offset parameter for contract orders, open or close');
        }
        $stopPrice = $this->safe_string($params, 'stopPrice');
        if ($stopPrice !== null) {
            throw new NotSupported($this->id . ' createOrder() supports tp_trigger_price . tp_order_price for take profit orders and/or sl_trigger_price . sl_order $price for stop loss orders, stop orders are supported only with open long orders and open short orders');
        }
        $market = $this->market($symbol);
        $request = array(
            // 'symbol' => 'BTC', // optional, case-insenstive, both uppercase and lowercase are supported, "BTC", "ETH", ...
            // 'contract_type' => 'this_week', // optional, this_week, next_week, quarter, next_quarter
            'contract_code' => $market['id'], // optional BTC180914
            // 'client_order_id' => $clientOrderId, // optional, must be less than 9223372036854775807
            // 'price' => $this->price_to_precision($symbol, $price), // optional
            'volume' => $this->amount_to_precision($symbol, $amount),
            'direction' => $side, // buy, sell
            'offset' => $offset, // open, close
            //
            //     direction buy, $offset open = open long
            //     direction sell, $offset close = close long
            //     direction sell, $offset open = open short
            //     direction buy, $offset close = close short
            //
            // 'reduce_only' => 0, // 1 or 0, in hedge mode it is invalid, and in one-way mode its value is 0 when not filled
            'lever_rate' => 1, // required, using leverage greater than 20x requires prior approval of high-leverage agreement
            // 'order_price_type' => 'limit', // required
            //
            //     order_price_type can be:
            //
            //     limit
            //     opponent // BBO
            //     post_only
            //     optimal_5
            //     optimal_10
            //     optimal_20
            //     ioc
            //     fok
            //     opponent_ioc // IOC order using the BBO $price
            //     optimal_5_ioc
            //     optimal_10_ioc
            //     optimal_20_ioc
            //     opponent_fok // FOR order using the BBO $price
            //     optimal_5_fok
            //     optimal_10_fok
            //     optimal_20_fok
            //
            // 'tp_trigger_price' => $this->price_to_precision($symbol, triggerPrice),
            // 'tp_order_price' => $this->price_to_precision($symbol, $price),
            // 'tp_order_price_type' => 'limit', // limit，optimal_5，optimal_10，optimal_20
            // 'sl_trigger_price' => $this->price_to_precision($symbol, stopLossPrice),
            // 'sl_order_price' => $this->price_to_precision($symbol, $price),
            // 'sl_order_price_type' => 'limit', // limit，optimal_5，optimal_10，optimal_20
        );
        $stopLossOrderPrice = $this->safe_string($params, 'sl_order_price');
        $stopLossTriggerPrice = $this->safe_string($params, 'sl_trigger_price');
        $takeProfitOrderPrice = $this->safe_string($params, 'tp_order_price');
        $takeProfitTriggerPrice = $this->safe_string($params, 'tp_trigger_price');
        $isOpenOrder = ($offset === 'open');
        $isStopOrder = false;
        if ($stopLossTriggerPrice !== null) {
            $request['sl_trigger_price'] = $this->price_to_precision($symbol, $stopLossTriggerPrice);
            $isStopOrder = true;
            if ($price !== null) {
                $request['sl_order_price'] = $this->price_to_precision($symbol, $price);
            }
        }
        if ($stopLossOrderPrice !== null) {
            $request['sl_order_price'] = $this->price_to_precision($symbol, $stopLossOrderPrice);
            $isStopOrder = true;
        }
        if ($takeProfitTriggerPrice !== null) {
            $request['tp_trigger_price'] = $this->price_to_precision($symbol, $takeProfitTriggerPrice);
            $isStopOrder = true;
            if ($price !== null) {
                $request['tp_order_price'] = $this->price_to_precision($symbol, $price);
            }
        }
        if ($takeProfitOrderPrice !== null) {
            $request['tp_order_price'] = $this->price_to_precision($symbol, $takeProfitOrderPrice);
            $isStopOrder = true;
        }
        if ($isStopOrder && !$isOpenOrder) {
            throw new NotSupported($this->id . ' createOrder() supports tp_trigger_price . tp_order_price for take profit orders and/or sl_trigger_price . sl_order $price for stop loss orders, stop orders are supported only with open long orders and open short orders');
        }
        $params = $this->omit($params, array( 'sl_order_price', 'sl_trigger_price', 'tp_order_price', 'tp_trigger_price' ));
        $postOnly = $this->safe_value($params, 'postOnly', false);
        if ($postOnly) {
            $type = 'post_only';
        }
        if ($type === 'limit' || $type === 'ioc' || $type === 'fok' || $type === 'post_only') {
            $request['price'] = $this->price_to_precision($symbol, $price);
        }
        $request['order_price_type'] = $type;
        $broker = $this->safe_value($this->options, 'broker', array());
        $brokerId = $this->safe_string($broker, 'id');
        $request['channel_code'] = $brokerId;
        $clientOrderId = $this->safe_string_2($params, 'client_order_id', 'clientOrderId');
        if ($clientOrderId !== null) {
            $request['client_order_id'] = $clientOrderId;
            $params = $this->omit($params, array( 'client_order_id', 'clientOrderId' ));
        }
        $method = null;
        if ($market['linear']) {
            $defaultMargin = $market['future'] ? 'cross' : 'isolated';
            $marginMode = $this->safe_string_2($this->options, 'defaultMarginMode', 'marginMode', $defaultMargin);
            if ($marginMode === 'isolated') {
                $method = 'contractPrivatePostLinearSwapApiV1SwapOrder';
            } elseif ($marginMode === 'cross') {
                $method = 'contractPrivatePostLinearSwapApiV1SwapCrossOrder';
            }
        } elseif ($market['inverse']) {
            if ($market['swap']) {
                $method = 'contractPrivatePostSwapApiV1SwapOrder';
            } elseif ($market['future']) {
                $method = 'contractPrivatePostApiV1ContractOrder';
            }
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // linear swap cross margin
        //
        //     {
        //         "status":"ok",
        //         "data":array(
        //             "order_id":924660854912552960,
        //             "order_id_str":"924660854912552960"
        //         ),
        //         "ts":1640497927185
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_order($data, $market);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        yield $this->load_markets();
        $marketType = null;
        list($marketType, $params) = $this->handle_market_type_and_params('cancelOrder', null, $params);
        $request = array(
            // spot -----------------------------------------------------------
            // 'order-id' => 'id',
            // 'symbol' => $market['id'],
            // 'client-order-id' => $clientOrderId,
            // contracts ------------------------------------------------------
            // 'order_id' => $id,
            // 'client_order_id' => $clientOrderId,
            // 'contract_code' => $market['id'],
            // 'pair' => 'BTC-USDT',
            // 'contract_type' => 'this_week', // swap, this_week, next_week, quarter, next_ quarter
        );
        $method = null;
        $market = null;
        if ($marketType === 'spot') {
            $clientOrderId = $this->safe_string_2($params, 'client-order-id', 'clientOrderId');
            $method = 'spotPrivatePostV1OrderOrdersOrderIdSubmitcancel';
            if ($clientOrderId === null) {
                $request['order-id'] = $id;
            } else {
                $request['client-order-id'] = $clientOrderId;
                $method = 'spotPrivatePostV1OrderOrdersSubmitCancelClientOrder';
                $params = $this->omit($params, array( 'client-order-id', 'clientOrderId' ));
            }
        } else {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol for ' . $marketType . ' orders');
            }
            $market = $this->market($symbol);
            $request['contract_code'] = $market['id'];
            if ($market['linear']) {
                $defaultMargin = $market['future'] ? 'cross' : 'isolated';
                $marginMode = $this->safe_string_2($this->options, 'defaultMarginMode', 'marginMode', $defaultMargin);
                if ($marginMode === 'isolated') {
                    $method = 'contractPrivatePostLinearSwapApiV1SwapCancel';
                } elseif ($marginMode === 'cross') {
                    $method = 'contractPrivatePostLinearSwapApiV1SwapCrossCancel';
                }
            } elseif ($market['inverse']) {
                if ($market['future']) {
                    $method = 'contractPrivatePostApiV1ContractCancel';
                    $request['symbol'] = $market['settleId'];
                } elseif ($market['swap']) {
                    $method = 'contractPrivatePostSwapApiV1SwapCancel';
                }
            } else {
                throw new NotSupported($this->id . ' cancelOrder() does not support ' . $marketType . ' markets');
            }
            $clientOrderId = $this->safe_string_2($params, 'client_order_id', 'clientOrderId');
            if ($clientOrderId === null) {
                $request['order_id'] = $id;
            } else {
                $request['client_order_id'] = $clientOrderId;
                $params = $this->omit($params, array( 'client_order_id', 'clientOrderId' ));
            }
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot
        //
        //     {
        //         'status' => 'ok',
        //         'data' => '10138899000',
        //     }
        //
        // linear swap cross margin
        //
        //     {
        //         "status":"ok",
        //         "data":array(
        //             "errors":array(),
        //             "successes":"924660854912552960"
        //         ),
        //         "ts":1640504486089
        //     }
        //
        return array_merge($this->parse_order($response, $market), array(
            'id' => $id,
            'status' => 'canceled',
        ));
    }

    public function cancel_orders($ids, $symbol = null, $params = array ()) {
        yield $this->load_markets();
        $marketType = null;
        list($marketType, $params) = $this->handle_market_type_and_params('cancelOrders', null, $params);
        $request = array(
            // spot -----------------------------------------------------------
            // 'order-ids' => $ids->jsoin (','), // max 50
            // 'client-order-ids' => implode(',', $ids), // max 50
            // contracts ------------------------------------------------------
            // 'order_id' => id, // comma separated, max 10
            // 'client_order_id' => clientOrderId, // comma separated, max 10
            // 'contract_code' => $market['id'],
            // 'symbol' => $market['settleId'],
        );
        $method = null;
        if ($marketType === 'spot') {
            $clientOrderIds = $this->safe_value_2($params, 'client-order-id', 'clientOrderId');
            $clientOrderIds = $this->safe_value_2($params, 'client-order-ids', 'clientOrderIds', $clientOrderIds);
            if ($clientOrderIds === null) {
                if (gettype($clientOrderIds) === 'string') {
                    $request['order-ids'] = $ids;
                } else {
                    $request['order-ids'] = implode(',', $ids);
                }
            } else {
                if (gettype($clientOrderIds) === 'string') {
                    $request['client-order-ids'] = $clientOrderIds;
                } else {
                    $request['client-order-ids'] = implode(',', $clientOrderIds);
                }
                $params = $this->omit($params, array( 'client-order-id', 'client-order-ids', 'clientOrderId', 'clientOrderIds' ));
            }
            $method = 'spotPrivatePostV1OrderOrdersBatchcancel';
        } else {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' cancelOrders() requires a $symbol for ' . $marketType . ' orders');
            }
            $market = $this->market($symbol);
            $request['contract_code'] = $market['id'];
            if ($market['linear']) {
                $defaultMargin = $market['future'] ? 'cross' : 'isolated';
                $marginMode = $this->safe_string_2($this->options, 'defaultMarginMode', 'marginMode', $defaultMargin);
                if ($marginMode === 'isolated') {
                    $method = 'contractPrivatePostLinearSwapApiV1SwapCancel';
                } elseif ($marginMode === 'cross') {
                    $method = 'contractPrivatePostLinearSwapApiV1SwapCrossCancel';
                }
            } elseif ($market['inverse']) {
                if ($market['future']) {
                    $method = 'contractPrivatePostApiV1ContractCancel';
                    $request['symbol'] = $market['settleId'];
                } elseif ($market['swap']) {
                    $method = 'contractPrivatePostSwapApiV1SwapCancel';
                } else {
                    throw new NotSupported($this->id . ' cancelOrders() does not support ' . $marketType . ' markets');
                }
            }
            $clientOrderIds = $this->safe_string_2($params, 'client_order_id', 'clientOrderId');
            $clientOrderIds = $this->safe_string_2($params, 'client_order_ids', 'clientOrderIds', $clientOrderIds);
            if ($clientOrderIds === null) {
                $request['order_id'] = implode(',', $ids);
            } else {
                $request['client_order_id'] = $clientOrderIds;
                $params = $this->omit($params, array( 'client_order_id', 'client_order_ids', 'clientOrderId', 'clientOrderIds' ));
            }
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot
        //
        //     {
        //         "status" => "ok",
        //         "data" => {
        //             "success" => array(
        //                 "5983466"
        //             ),
        //             "failed" => array(
        //                 array(
        //                     "err-msg" => "Incorrect order state",
        //                     "order-state" => 7,
        //                     "order-id" => "",
        //                     "err-code" => "order-orderstate-error",
        //                     "client-order-id" => "first"
        //                 ),
        //                 array(
        //                     "err-msg" => "Incorrect order state",
        //                     "order-state" => 7,
        //                     "order-id" => "",
        //                     "err-code" => "order-orderstate-error",
        //                     "client-order-id" => "second"
        //                 ),
        //                 {
        //                     "err-msg" => "The record is not found.",
        //                     "order-id" => "",
        //                     "err-code" => "base-not-found",
        //                     "client-order-id" => "third"
        //                 }
        //             )
        //         }
        //     }
        //
        // contracts
        //
        //     {
        //         "status" => "ok",
        //         "data" => {
        //             "errors" => array(
        //                 array(
        //                     "order_id" => "769206471845261312",
        //                     "err_code" => 1061,
        //                     "err_msg" => "This order doesnt exist."
        //                 }
        //             ),
        //             "successes" => "773120304138219520"
        //         ),
        //         "ts" => 1604367997451
        //     }
        //
        return $response;
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        yield $this->load_markets();
        $marketType = null;
        list($marketType, $params) = $this->handle_market_type_and_params('cancelAllOrders', null, $params);
        $request = array(
            // spot -----------------------------------------------------------
            // 'account-id' => account['id'],
            // 'symbol' => $market['id'], // a list of comma-separated symbols, all symbols by default
            // 'types' 'string', buy-$market, sell-$market, buy-limit, sell-limit, buy-ioc, sell-ioc, buy-stop-limit, sell-stop-limit, buy-limit-fok, sell-limit-fok, buy-stop-limit-fok, sell-stop-limit-fok
            // 'side' => 'buy', // or 'sell'
            // 'size' => 100, // the number of orders to cancel 1-100
            // contract -------------------------------------------------------
            // 'symbol' => $market['settleId'], // required
            // 'contract_code' => $market['id'],
            // 'contract_type' => 'this_week', // swap, this_week, next_week, quarter, next_ quarter
            // 'direction' => 'buy' => // buy, sell
            // 'offset' => 'open', // open, close
        );
        $market = null;
        $method = null;
        if ($marketType === 'spot') {
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            $method = 'spotPrivatePostV1OrderOrdersBatchCancelOpenOrders';
        } else {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' cancelAllOrders() requires a $symbol for ' . $marketType . ' orders');
            }
            $market = $this->market($symbol);
            $request['contract_code'] = $market['id'];
            if ($market['linear']) {
                $defaultMargin = $market['future'] ? 'cross' : 'isolated';
                $marginMode = $this->safe_string_2($this->options, 'defaultMarginMode', 'marginMode', $defaultMargin);
                if ($marginMode === 'isolated') {
                    $method = 'contractPrivatePostLinearSwapApiV1SwapCancelallall';
                } elseif ($marginMode === 'cross') {
                    $method = 'contractPrivatePostLinearSwapApiV1SwapCrossCancelall';
                }
            } elseif ($market['inverse']) {
                if ($marketType === 'future') {
                    $method = 'contractPrivatePostApiV1ContractCancelall';
                    $request['symbol'] = $market['settleId'];
                } elseif ($marketType === 'swap') {
                    $method = 'contractPrivatePostSwapApiV1SwapCancelall';
                } else {
                    throw new NotSupported($this->id . ' cancelAllOrders() does not support ' . $marketType . ' markets');
                }
            }
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        //     {
        //         code => 200,
        //         data => {
        //             "success-count" => 2,
        //             "failed-count" => 0,
        //             "next-id" => 5454600
        //         }
        //     }
        //
        return $response;
    }

    public function currency_to_precision($code, $fee, $networkCode = null) {
        return $this->decimal_to_precision($fee, 0, $this->currencies[$code]['precision']);
    }

    public function safe_network($networkId) {
        $lastCharacterIndex = strlen($networkId) - 1;
        $lastCharacter = $networkId[$lastCharacterIndex];
        if ($lastCharacter === '1') {
            $networkId = mb_substr($networkId, 0, $lastCharacterIndex - 0);
        }
        $networksById = array();
        return $this->safe_string($networksById, $networkId, $networkId);
    }

    public function parse_deposit_address($depositAddress, $currency = null) {
        //
        //     {
        //         $currency => "usdt",
        //         $address => "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
        //         addressTag => "",
        //         chain => "usdterc20", // trc20usdt, hrc20usdt, usdt, algousdt
        //     }
        //
        $address = $this->safe_string($depositAddress, 'address');
        $tag = $this->safe_string($depositAddress, 'addressTag');
        $currencyId = $this->safe_string($depositAddress, 'currency');
        $currency = $this->safe_currency($currencyId, $currency);
        $code = $this->safe_currency_code($currencyId, $currency);
        $networkId = $this->safe_string($depositAddress, 'chain');
        $networks = $this->safe_value($currency, 'networks', array());
        $networksById = $this->index_by($networks, 'id');
        $networkValue = $this->safe_value($networksById, $networkId, $networkId);
        $network = $this->safe_string($networkValue, 'network');
        $note = $this->safe_string($depositAddress, 'note');
        $this->check_address($address);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => $tag,
            'network' => $network,
            'note' => $note,
            'info' => $depositAddress,
        );
    }

    public function fetch_deposit_addresses_by_network($code, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'currency' => $currency['id'],
        );
        $response = yield $this->spotPrivateGetV2AccountDepositAddress (array_merge($request, $params));
        //
        //     {
        //         $code => 200,
        //         $data => array(
        //             {
        //                 $currency => "eth",
        //                 address => "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
        //                 addressTag => "",
        //                 chain => "eth"
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $parsed = $this->parse_deposit_addresses($data, array( $code ), false);
        return $this->index_by($parsed, 'network');
    }

    public function fetch_deposit_address($code, $params = array ()) {
        $rawNetwork = $this->safe_string_upper($params, 'network');
        $networks = $this->safe_value($this->options, 'networks', array());
        $network = $this->safe_string_upper($networks, $rawNetwork, $rawNetwork);
        $params = $this->omit($params, 'network');
        $response = yield $this->fetch_deposit_addresses_by_network($code, $params);
        $result = null;
        if ($network === null) {
            $result = $this->safe_value($response, $code);
            if ($result === null) {
                $alias = $this->safe_string($networks, $code, $code);
                $result = $this->safe_value($response, $alias);
                if ($result === null) {
                    $defaultNetwork = $this->safe_string($this->options, 'defaultNetwork', 'ERC20');
                    $result = $this->safe_value($response, $defaultNetwork);
                    if ($result === null) {
                        $values = is_array($response) ? array_values($response) : array();
                        $result = $this->safe_value($values, 0);
                        if ($result === null) {
                            throw new InvalidAddress($this->id . ' fetchDepositAddress() cannot find deposit address for ' . $code);
                        }
                    }
                }
            }
            return $result;
        }
        $result = $this->safe_value($response, $network);
        if ($result === null) {
            throw new InvalidAddress($this->id . ' fetchDepositAddress() cannot find ' . $network . ' deposit address for ' . $code);
        }
        return $result;
    }

    public function fetch_withdraw_addresses_by_network($code, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'currency' => $currency['id'],
        );
        $response = yield $this->spotPrivateGetV2AccountWithdrawAddress (array_merge($request, $params));
        //
        //     {
        //         $code => 200,
        //         $data => array(
        //             {
        //                 $currency => "eth",
        //                 chain => "eth"
        //                 note => "Binance - TRC20",
        //                 addressTag => "",
        //                 address => "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $parsed = $this->parse_deposit_addresses($data, array( $code ), false);
        return $this->index_by($parsed, 'network');
    }

    public function fetch_withdraw_address($code, $params = array ()) {
        $rawNetwork = $this->safe_string_upper($params, 'network');
        $networks = $this->safe_value($this->options, 'networks', array());
        $network = $this->safe_string_upper($networks, $rawNetwork, $rawNetwork);
        $params = $this->omit($params, 'network');
        $response = yield $this->fetch_withdraw_addresses_by_network($code, $params);
        $result = null;
        if ($network === null) {
            $result = $this->safe_value($response, $code);
            if ($result === null) {
                $alias = $this->safe_string($networks, $code, $code);
                $result = $this->safe_value($response, $alias);
                if ($result === null) {
                    $defaultNetwork = $this->safe_string($this->options, 'defaultNetwork', 'ERC20');
                    $result = $this->safe_value($response, $defaultNetwork);
                    if ($result === null) {
                        $values = is_array($response) ? array_values($response) : array();
                        $result = $this->safe_value($values, 0);
                        if ($result === null) {
                            throw new InvalidAddress($this->id . ' fetchWithdrawAddress() cannot find withdraw address for ' . $code);
                        }
                    }
                }
            }
            return $result;
        }
        $result = $this->safe_value($response, $network);
        if ($result === null) {
            throw new InvalidAddress($this->id . ' fetchWithdrawAddress() cannot find ' . $network . ' withdraw address for ' . $code);
        }
        return $result;
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        if ($limit === null || $limit > 100) {
            $limit = 100;
        }
        yield $this->load_markets();
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
        }
        $request = array(
            'type' => 'deposit',
            'from' => 0, // From 'id' ... if you want to get results after a particular transaction id, pass the id in $params->from
        );
        if ($currency !== null) {
            $request['currency'] = $currency['id'];
        }
        if ($limit !== null) {
            $request['size'] = $limit; // max 100
        }
        $response = yield $this->spotPrivateGetV1QueryDepositWithdraw (array_merge($request, $params));
        // return $response
        return $this->parse_transactions($response['data'], $currency, $since, $limit);
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        if ($limit === null || $limit > 100) {
            $limit = 100;
        }
        yield $this->load_markets();
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
        }
        $request = array(
            'type' => 'withdraw',
            'from' => 0, // From 'id' ... if you want to get results after a particular transaction id, pass the id in $params->from
        );
        if ($currency !== null) {
            $request['currency'] = $currency['id'];
        }
        if ($limit !== null) {
            $request['size'] = $limit; // max 100
        }
        $response = yield $this->spotPrivateGetV1QueryDepositWithdraw (array_merge($request, $params));
        // return $response
        return $this->parse_transactions($response['data'], $currency, $since, $limit);
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // fetchDeposits
        //
        //     {
        //         'id' => 8211029,
        //         'type' => 'deposit',
        //         'currency' => 'eth',
        //         'chain' => 'eth',
        //         'tx-hash' => 'bd315....',
        //         'amount' => 0.81162421,
        //         'address' => '4b8b....',
        //         'address-tag' => '',
        //         'fee' => 0,
        //         'state' => 'safe',
        //         'created-at' => 1542180380965,
        //         'updated-at' => 1542180788077
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         'id' => 6908275,
        //         'type' => 'withdraw',
        //         'currency' => 'btc',
        //         'chain' => 'btc',
        //         'tx-hash' => 'c1a1a....',
        //         'amount' => 0.80257005,
        //         'address' => '1QR....',
        //         'address-tag' => '',
        //         'fee' => 0.0005,
        //         'state' => 'confirmed',
        //         'created-at' => 1552107295685,
        //         'updated-at' => 1552108032859
        //     }
        //
        // withdraw
        //
        //     {
        //         "status" => "ok",
        //         "data" => "99562054"
        //     }
        //
        $timestamp = $this->safe_integer($transaction, 'created-at');
        $updated = $this->safe_integer($transaction, 'updated-at');
        $code = $this->safe_currency_code($this->safe_string($transaction, 'currency'));
        $type = $this->safe_string($transaction, 'type');
        if ($type === 'withdraw') {
            $type = 'withdrawal';
        }
        $status = $this->parse_transaction_status($this->safe_string($transaction, 'state'));
        $tag = $this->safe_string($transaction, 'address-tag');
        $feeCost = $this->safe_number($transaction, 'fee');
        if ($feeCost !== null) {
            $feeCost = abs($feeCost);
        }
        $address = $this->safe_string($transaction, 'address');
        $network = $this->safe_string_upper($transaction, 'chain');
        return array(
            'info' => $transaction,
            'id' => $this->safe_string_2($transaction, 'id', 'data'),
            'txid' => $this->safe_string($transaction, 'tx-hash'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => $network,
            'address' => $address,
            'addressTo' => null,
            'addressFrom' => null,
            'tag' => $tag,
            'tagTo' => null,
            'tagFrom' => null,
            'type' => $type,
            'amount' => $this->safe_number($transaction, 'amount'),
            'currency' => $code,
            'status' => $status,
            'updated' => $updated,
            'fee' => array(
                'currency' => $code,
                'cost' => $feeCost,
                'rate' => null,
            ),
        );
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            // deposit $statuses
            'unknown' => 'failed',
            'confirming' => 'pending',
            'confirmed' => 'ok',
            'safe' => 'ok',
            'orphan' => 'failed',
            // withdrawal $statuses
            'submitted' => 'pending',
            'canceled' => 'canceled',
            'reexamine' => 'pending',
            'reject' => 'failed',
            'pass' => 'pending',
            'wallet-reject' => 'failed',
            // 'confirmed' => 'ok', // present in deposit $statuses
            'confirm-error' => 'failed',
            'repealed' => 'failed',
            'wallet-transfer' => 'pending',
            'pre-transfer' => 'pending',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
        yield $this->load_markets();
        $this->check_address($address);
        $currency = $this->currency($code);
        $request = array(
            'address' => $address, // only supports existing addresses in your withdraw $address list
            'amount' => $amount,
            'currency' => strtolower($currency['id']),
        );
        if ($tag !== null) {
            $request['addr-tag'] = $tag; // only for XRP?
        }
        $networks = $this->safe_value($this->options, 'networks', array());
        $network = $this->safe_string_upper($params, 'network'); // this line allows the user to specify either ERC20 or ETH
        $network = $this->safe_string_lower($networks, $network, $network); // handle ETH>ERC20 alias
        if ($network !== null) {
            // possible chains - usdterc20, trc20usdt, hrc20usdt, usdt, algousdt
            if ($network === 'erc20') {
                $request['chain'] = $currency['id'] . $network;
            } else {
                $request['chain'] = $network . $currency['id'];
            }
            $params = $this->omit($params, 'network');
        }
        $response = yield $this->spotPrivatePostV1DwWithdrawApiCreate (array_merge($request, $params));
        //
        //     {
        //         "status" => "ok",
        //         "data" => "99562054"
        //     }
        //
        return $this->parse_transaction($response, $currency);
    }

    public function parse_transfer($transfer, $currency = null) {
        //
        // $transfer
        //
        //     {
        //         "data" => 12345,
        //         "status" => "ok"
        //     }
        //
        $id = $this->safe_string($transfer, 'data');
        $code = $this->safe_currency_code(null, $currency);
        return array(
            'info' => $transfer,
            'id' => $id,
            'timestamp' => null,
            'datetime' => null,
            'currency' => $code,
            'amount' => null,
            'fromAccount' => null,
            'toAccount' => null,
            'status' => null,
        );
    }

    public function transfer($code, $amount, $fromAccount, $toAccount, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $type = $this->safe_string($params, 'type');
        if ($type === null) {
            $accountsByType = $this->safe_value($this->options, 'accountsByType', array());
            $fromAccount = strtolower($fromAccount); // pro, futures
            $toAccount = strtolower($toAccount); // pro, futures
            $fromId = $this->safe_string($accountsByType, $fromAccount, $fromAccount);
            $toId = $this->safe_string($accountsByType, $toAccount, $toAccount);
            $type = $fromId . '-to-' . $toId;
        }
        $request = array(
            'currency' => $currency['id'],
            'amount' => floatval($this->currency_to_precision($code, $amount)),
            'type' => $type,
        );
        $response = yield $this->spotPrivatePostFuturesTransfer (array_merge($request, $params));
        //
        //     {
        //         "data" => 12345,
        //         "status" => "ok"
        //     }
        //
        $transfer = $this->parse_transfer($response, $currency);
        return array_merge($transfer, array(
            'amount' => $amount,
            'currency' => $code,
            'fromAccount' => $fromAccount,
            'toAccount' => $toAccount,
        ));
    }

    public function fetch_borrow_rates_per_symbol($params = array ()) {
        yield $this->load_markets();
        $response = yield $this->spotPrivateGetV1MarginLoanInfo ($params);
        // {
        //     "status" => "ok",
        //     "data" => array(
        //         {
        //             "symbol" => "1inchusdt",
        //             "currencies" => array(
        //                 array(
        //                     "currency" => "1inch",
        //                     "interest-$rate" => "0.00098",
        //                     "min-loan-amt" => "90.000000000000000000",
        //                     "max-loan-amt" => "1000.000000000000000000",
        //                     "loanable-amt" => "0.0",
        //                     "actual-$rate" => "0.00098"
        //                 ),
        //                 array(
        //                     "currency" => "usdt",
        //                     "interest-$rate" => "0.00098",
        //                     "min-loan-amt" => "100.000000000000000000",
        //                     "max-loan-amt" => "1000.000000000000000000",
        //                     "loanable-amt" => "0.0",
        //                     "actual-$rate" => "0.00098"
        //                 }
        //             )
        //         ),
        //         ...
        //     )
        // }
        $timestamp = $this->milliseconds();
        $data = $this->safe_value($response, 'data', array());
        $rates = array(
            'info' => $response,
        );
        for ($i = 0; $i < count($data); $i++) {
            $rate = $data[$i];
            $currencies = $this->safe_value($rate, 'currencies', array());
            $symbolRates = array();
            for ($j = 0; $j < count($currencies); $j++) {
                $currency = $currencies[$j];
                $currencyId = $this->safe_string($currency, 'currency');
                $code = $this->safe_currency_code($currencyId, 'currency');
                $symbolRates[$code] = array(
                    'currency' => $code,
                    'rate' => $this->safe_number($currency, 'actual-rate'),
                    'span' => 86400000,
                    'timestamp' => $timestamp,
                    'datetime' => $this->iso8601($timestamp),
                );
            }
            $market = $this->markets_by_id[$this->safe_string($rate, 'symbol')];
            $symbol = $market['symbol'];
            $rates[$symbol] = $symbolRates;
        }
        return $rates;
    }

    public function fetch_borrow_rates($params = array ()) {
        yield $this->load_markets();
        $response = yield $this->spotPrivateGetV1MarginLoanInfo ($params);
        // {
        //     "status" => "ok",
        //     "data" => array(
        //         {
        //             "symbol" => "1inchusdt",
        //             "currencies" => array(
        //                 array(
        //                     "currency" => "1inch",
        //                     "interest-rate" => "0.00098",
        //                     "min-loan-amt" => "90.000000000000000000",
        //                     "max-loan-amt" => "1000.000000000000000000",
        //                     "loanable-amt" => "0.0",
        //                     "actual-rate" => "0.00098"
        //                 ),
        //                 array(
        //                     "currency" => "usdt",
        //                     "interest-rate" => "0.00098",
        //                     "min-loan-amt" => "100.000000000000000000",
        //                     "max-loan-amt" => "1000.000000000000000000",
        //                     "loanable-amt" => "0.0",
        //                     "actual-rate" => "0.00098"
        //                 }
        //             )
        //         ),
        //         ...
        //     )
        // }
        $timestamp = $this->milliseconds();
        $data = $this->safe_value($response, 'data', array());
        $rates = array();
        for ($i = 0; $i < count($data); $i++) {
            $market = $data[$i];
            $currencies = $this->safe_value($market, 'currencies', array());
            for ($j = 0; $j < count($currencies); $j++) {
                $currency = $currencies[$j];
                $currencyId = $this->safe_string($currency, 'currency');
                $code = $this->safe_currency_code($currencyId, 'currency');
                $rates[$code] = array(
                    'currency' => $code,
                    'rate' => $this->safe_number($currency, 'actual-rate'),
                    'span' => 86400000,
                    'timestamp' => $timestamp,
                    'datetime' => $this->iso8601($timestamp),
                    'info' => null,
                );
            }
        }
        return $rates;
    }

    public function fetch_funding_rate_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        /**
         * fetches historical funding rate prices
         * @param {str|null} $symbol unified $symbol of the $market to fetch the funding rate history for
         * @param {int|null} $since not used by huobi, but filtered internally by ccxt
         * @param {int|null} $limit not used by huobi, but filtered internally by ccxt
         * @param {dict} $params extra parameters specific to the huobi api endpoint
         * @return {[dict]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure funding rate structures~
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchFundingRateHistory() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'contract_code' => $market['id'],
        );
        $method = null;
        if ($market['inverse']) {
            $method = 'contractPublicGetSwapApiV1SwapHistoricalFundingRate';
        } elseif ($market['linear']) {
            $method = 'contractPublicGetLinearSwapApiV1SwapHistoricalFundingRate';
        } else {
            throw new NotSupported($this->id . ' fetchFundingRateHistory() supports inverse and linear swaps only');
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // {
        //     "status" => "ok",
        //     "data" => array(
        //         "total_page" => 62,
        //         "current_page" => 1,
        //         "total_size" => 1237,
        //         "data" => array(
        //             array(
        //                 "avg_premium_index" => "-0.000208064395065541",
        //                 "funding_rate" => "0.000100000000000000",
        //                 "realized_rate" => "0.000100000000000000",
        //                 "funding_time" => "1638921600000",
        //                 "contract_code" => "BTC-USDT",
        //                 "symbol" => "BTC",
        //                 "fee_asset" => "USDT"
        //             ),
        //         )
        //     ),
        //     "ts" => 1638939294277
        // }
        //
        $data = $this->safe_value($response, 'data');
        $result = $this->safe_value($data, 'data', array());
        $rates = array();
        for ($i = 0; $i < count($result); $i++) {
            $entry = $result[$i];
            $marketId = $this->safe_string($entry, 'contract_code');
            $symbol = $this->safe_symbol($marketId);
            $timestamp = $this->safe_string($entry, 'funding_time');
            $rates[] = array(
                'info' => $entry,
                'symbol' => $symbol,
                'fundingRate' => $this->safe_number($entry, 'funding_rate'),
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
            );
        }
        $sorted = $this->sort_by($rates, 'timestamp');
        return $this->filter_by_symbol_since_limit($sorted, $market['symbol'], $since, $limit);
    }

    public function parse_funding_rate($fundingRate, $market = null) {
        //
        // {
        //      "status" => "ok",
        //      "data" => array(
        //         "estimated_rate" => "0.000100000000000000",
        //         "funding_rate" => "0.000100000000000000",
        //         "contract_code" => "BCH-USD",
        //         "symbol" => "BCH",
        //         "fee_asset" => "BCH",
        //         "funding_time" => "1639094400000",
        //         "next_funding_time" => "1639123200000"
        //     ),
        //     "ts" => 1639085854775
        // }
        //
        $nextFundingRate = $this->safe_number($fundingRate, 'estimated_rate');
        $fundingTimestamp = $this->safe_integer($fundingRate, 'funding_time');
        $nextFundingTimestamp = $this->safe_integer($fundingRate, 'next_funding_time');
        $marketId = $this->safe_string($fundingRate, 'contract_code');
        $symbol = $this->safe_symbol($marketId, $market);
        return array(
            'info' => $fundingRate,
            'symbol' => $symbol,
            'markPrice' => null,
            'indexPrice' => null,
            'interestRate' => null,
            'estimatedSettlePrice' => null,
            'timestamp' => null,
            'datetime' => null,
            'fundingRate' => $this->safe_number($fundingRate, 'funding_rate'),
            'fundingTimestamp' => $fundingTimestamp,
            'fundingDatetime' => $this->iso8601($fundingTimestamp),
            'nextFundingRate' => $nextFundingRate,
            'nextFundingTimestamp' => $nextFundingTimestamp,
            'nextFundingDatetime' => $this->iso8601($nextFundingTimestamp),
            'previousFundingRate' => null,
            'previousFundingTimestamp' => null,
            'previousFundingDatetime' => null,
        );
    }

    public function fetch_funding_rate($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $method = null;
        if ($market['inverse']) {
            $method = 'contractPublicGetSwapApiV1SwapFundingRate';
        } elseif ($market['linear']) {
            $method = 'contractPublicGetLinearSwapApiV1SwapFundingRate';
        } else {
            throw new NotSupported($this->id . ' fetchFundingRate() supports inverse and linear swaps only');
        }
        $request = array(
            'contract_code' => $market['id'],
        );
        $response = yield $this->$method (array_merge($request, $params));
        //
        // {
        //     "status" => "ok",
        //     "data" => array(
        //         "estimated_rate" => "0.000100000000000000",
        //         "funding_rate" => "0.000100000000000000",
        //         "contract_code" => "BTC-USDT",
        //         "symbol" => "BTC",
        //         "fee_asset" => "USDT",
        //         "funding_time" => "1603699200000",
        //         "next_funding_time" => "1603728000000"
        //     ),
        //     "ts" => 1603696494714
        // }
        //
        $result = $this->safe_value($response, 'data', array());
        return $this->parse_funding_rate($result, $market);
    }

    public function fetch_funding_rates($symbols, $params = array ()) {
        yield $this->load_markets();
        $options = $this->safe_value($this->options, 'fetchFundingRates', array());
        $defaultSubType = $this->safe_string($this->options, 'defaultSubType', 'inverse');
        $subType = $this->safe_string($options, 'subType', $defaultSubType);
        $subType = $this->safe_string($params, 'subType', $subType);
        $request = array(
            // 'contract_code' => market['id'],
        );
        $method = $this->get_supported_mapping($subType, array(
            'linear' => 'contractPublicGetLinearSwapApiV1SwapBatchFundingRate',
            'inverse' => 'contractPublicGetSwapApiV1SwapBatchFundingRate',
        ));
        $params = $this->omit($params, 'subType');
        $response = yield $this->$method (array_merge($request, $params));
        //
        //     {
        //         "status" => "ok",
        //         "data" => array(
        //             array(
        //                 "estimated_rate" => "0.000100000000000000",
        //                 "funding_rate" => "0.000100000000000000",
        //                 "contract_code" => "MANA-USDT",
        //                 "symbol" => "MANA",
        //                 "fee_asset" => "USDT",
        //                 "funding_time" => "1643356800000",
        //                 "next_funding_time" => "1643385600000",
        //                 "trade_partition":"USDT"
        //             ),
        //         ),
        //         "ts" => 1643346173103
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $result = $this->parse_funding_rates($data);
        return $this->filter_by_array($result, 'symbol', $symbols);
    }

    public function fetch_borrow_interest($code = null, $symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $defaultMargin = $this->safe_string($params, 'marginMode', 'cross'); // cross or isolated
        $marginMode = $this->safe_string_2($this->options, 'defaultMarginMode', 'marginMode', $defaultMargin);
        $request = array();
        if ($since !== null) {
            $request['start-date'] = $this->yyyymmdd($since);
        }
        if ($limit !== null) {
            $request['size'] = $limit;
        }
        $market = null;
        $method = null;
        if ($marginMode === 'isolated') {
            $method = 'privateGetMarginLoanOrders';
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
        } else {  // Cross
            $method = 'privateGetCrossMarginLoanOrders';
            if ($code !== null) {
                $currency = $this->currency($code);
                $request['currency'] = $currency['id'];
            }
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        //    {
        //        "status":"ok",
        //        "data":array(
        //            {
        //                "loan-balance":"0.100000000000000000",
        //                "interest-balance":"0.000200000000000000",
        //                "loan-amount":"0.100000000000000000",
        //                "accrued-at":1511169724531,
        //                "interest-amount":"0.000200000000000000",
        //                "filled-points":"0.2",
        //                "filled-ht":"0.2",
        //                "currency":"btc",
        //                "id":394,
        //                "state":"accrual",
        //                "account-id":17747,
        //                "user-id":119913,
        //                "created-at":1511169724531
        //            }
        //        )
        //    }
        //
        $data = $this->safe_value($response, 'data');
        $interest = $this->parse_borrow_interests($data, $market);
        return $this->filter_by_currency_since_limit($interest, $code, $since, $limit);
    }

    public function parse_borrow_interest($info, $market = null) {
        // isolated
        //    {
        //        "interest-rate":"0.000040830000000000",
        //        "user-id":35930539,
        //        "account-id":48916071,
        //        "updated-at":1649320794195,
        //        "deduct-rate":"1",
        //        "day-interest-rate":"0.000980000000000000",
        //        "hour-interest-rate":"0.000040830000000000",
        //        "loan-balance":"100.790000000000000000",
        //        "interest-balance":"0.004115260000000000",
        //        "loan-amount":"100.790000000000000000",
        //        "paid-coin":"0.000000000000000000",
        //        "accrued-at":1649320794148,
        //        "created-at":1649320794148,
        //        "interest-amount":"0.004115260000000000",
        //        "deduct-amount":"0",
        //        "deduct-currency":"",
        //        "paid-point":"0.000000000000000000",
        //        "currency":"usdt",
        //        "symbol":"ltcusdt",
        //        "id":20242721,
        //    }
        //
        // cross
        //   {
        //       "id":3416576,
        //       "user-id":35930539,
        //       "account-id":48956839,
        //       "currency":"usdt",
        //       "loan-amount":"102",
        //       "loan-balance":"102",
        //       "interest-amount":"0.00416466",
        //       "interest-balance":"0.00416466",
        //       "created-at":1649322735333,
        //       "accrued-at":1649322735382,
        //       "state":"accrual",
        //       "filled-points":"0",
        //       "filled-ht":"0"
        //   }
        //
        $marketId = $this->safe_string($info, 'symbol');
        $marginMode = ($marketId === null) ? 'cross' : 'isolated';
        $market = $this->safe_market($marketId);
        $symbol = $this->safe_string($market, 'symbol');
        $timestamp = $this->safe_number($info, 'accrued-at');
        return array(
            'account' => ($marginMode === 'isolated') ? $symbol : 'cross',  // deprecated
            'symbol' => $symbol,
            'marginMode' => $marginMode,
            'marginType' => $marginMode, // deprecated
            'currency' => $this->safe_currency_code($this->safe_string($info, 'currency')),
            'interest' => $this->safe_number($info, 'interest-amount'),
            'interestRate' => $this->safe_number($info, 'interest-rate'),
            'amountBorrowed' => $this->safe_number($info, 'loan-amount'),
            'timestamp' => $timestamp,  // Interest accrued time
            'datetime' => $this->iso8601($timestamp),
            'info' => $info,
        );
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $url = '/';
        $query = $this->omit($params, $this->extract_params($path));
        if (gettype($api) === 'string') {
            // signing implementation for the old endpoints
            if ($api === 'market') {
                $url .= $api;
            } elseif (($api === 'public') || ($api === 'private')) {
                $url .= $this->version;
            } elseif (($api === 'v2Public') || ($api === 'v2Private')) {
                $url .= 'v2';
            }
            $url .= '/' . $this->implode_params($path, $params);
            if ($api === 'private' || $api === 'v2Private') {
                $this->check_required_credentials();
                $timestamp = $this->ymdhms($this->milliseconds(), 'T');
                $request = array(
                    'SignatureMethod' => 'HmacSHA256',
                    'SignatureVersion' => '2',
                    'AccessKeyId' => $this->apiKey,
                    'Timestamp' => $timestamp,
                );
                if ($method !== 'POST') {
                    $request = array_merge($request, $query);
                }
                $request = $this->keysort($request);
                $auth = $this->urlencode($request);
                // unfortunately, PHP demands double quotes for the escaped newline symbol
                $payload = implode("\n", array($method, $this->hostname, $url, $auth)); // eslint-disable-line quotes
                $signature = $this->hmac($this->encode($payload), $this->encode($this->secret), 'sha256', 'base64');
                $auth .= '&' . $this->urlencode(array( 'Signature' => $signature ));
                $url .= '?' . $auth;
                if ($method === 'POST') {
                    $body = $this->json($query);
                    $headers = array(
                        'Content-Type' => 'application/json',
                    );
                } else {
                    $headers = array(
                        'Content-Type' => 'application/x-www-form-urlencoded',
                    );
                }
            } else {
                if ($query) {
                    $url .= '?' . $this->urlencode($query);
                }
            }
            $url = $this->implode_params($this->urls['api'][$api], array(
                'hostname' => $this->hostname,
            )) . $url;
        } else {
            // signing implementation for the new endpoints
            // list($type, $access) = $api;
            $type = $this->safe_string($api, 0);
            $access = $this->safe_string($api, 1);
            $levelOneNestedPath = $this->safe_string($api, 2);
            $levelTwoNestedPath = $this->safe_string($api, 3);
            $hostname = null;
            $hostnames = $this->safe_value($this->urls['hostnames'], $type);
            if (gettype($hostnames) !== 'string') {
                $hostnames = $this->safe_value($hostnames, $levelOneNestedPath);
                if ((gettype($hostname) !== 'string') && ($levelTwoNestedPath !== null)) {
                    $hostnames = $this->safe_value($hostnames, $levelTwoNestedPath);
                }
            }
            $hostname = $hostnames;
            $url .= $this->implode_params($path, $params);
            if ($access === 'public') {
                if ($query) {
                    $url .= '?' . $this->urlencode($query);
                }
            } elseif ($access === 'private') {
                $this->check_required_credentials();
                $timestamp = $this->ymdhms($this->milliseconds(), 'T');
                $request = array(
                    'SignatureMethod' => 'HmacSHA256',
                    'SignatureVersion' => '2',
                    'AccessKeyId' => $this->apiKey,
                    'Timestamp' => $timestamp,
                );
                if ($method !== 'POST') {
                    $request = array_merge($request, $query);
                }
                $request = $this->keysort($request);
                $auth = $this->urlencode($request);
                // unfortunately, PHP demands double quotes for the escaped newline symbol
                $payload = implode("\n", array($method, $hostname, $url, $auth)); // eslint-disable-line quotes
                $signature = $this->hmac($this->encode($payload), $this->encode($this->secret), 'sha256', 'base64');
                $auth .= '&' . $this->urlencode(array( 'Signature' => $signature ));
                $url .= '?' . $auth;
                if ($method === 'POST') {
                    $body = $this->json($query);
                    $headers = array(
                        'Content-Type' => 'application/json',
                    );
                } else {
                    $headers = array(
                        'Content-Type' => 'application/x-www-form-urlencoded',
                    );
                }
            }
            $url = $this->implode_params($this->urls['api'][$type], array(
                'hostname' => $hostname,
            )) . $url;
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function calculate_rate_limiter_cost($api, $method, $path, $params, $config = array (), $context = array ()) {
        return $this->safe_integer($config, 'cost', 1);
    }

    public function handle_errors($httpCode, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return; // fallback to default error handler
        }
        if (is_array($response) && array_key_exists('status', $response)) {
            //
            //     array("status":"error","err-$code":"order-limitorder-amount-min-error","err-msg":"limit order amount error, min => `0.001`","data":null)
            //
            $status = $this->safe_string($response, 'status');
            if ($status === 'error') {
                $code = $this->safe_string_2($response, 'err-code', 'err_code');
                $feedback = $this->id . ' ' . $body;
                $this->throw_broadly_matched_exception($this->exceptions['broad'], $body, $feedback);
                $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $feedback);
                $message = $this->safe_string_2($response, 'err-msg', 'err_msg');
                $this->throw_exactly_matched_exception($this->exceptions['exact'], $message, $feedback);
                throw new ExchangeError($feedback);
            }
        }
    }

    public function fetch_funding_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        list($marketType, $query) = $this->handle_market_type_and_params('fetchFundingHistory', $market, $params);
        $method = null;
        $request = array(
            'type' => '30,31',
        );
        if ($market['linear']) {
            $method = 'contractPrivatePostLinearSwapApiV1SwapFinancialRecordExact';
            //
            // {
            //   status => 'ok',
            //   $data => array(
            //     financial_record => array(
            //       array(
            //         id => '1320088022',
            //         type => '30',
            //         amount => '0.004732510000000000',
            //         ts => '1641168019321',
            //         contract_code => 'BTC-USDT',
            //         asset => 'USDT',
            //         margin_account => 'BTC-USDT',
            //         face_margin_account => ''
            //       ),
            //     ),
            //     remain_size => '0',
            //     next_id => null
            //   ),
            //   ts => '1641189898425'
            // }
            $defaultMargin = $market['future'] ? 'cross' : 'isolated';
            $marginMode = $this->safe_string_2($this->options, 'defaultMarginMode', 'marginMode', $defaultMargin);
            if ($marginMode === 'isolated') {
                $request['margin_account'] = $market['id'];
            } else {
                $request['margin_account'] = $market['quoteId'];
            }
        } else {
            if ($marketType === 'swap') {
                $method = 'contractPrivatePostSwapApiV1SwapFinancialRecordExact';
                $request['contract_code'] = $market['id'];
            } else {
                throw new ExchangeError($this->id . ' fetchFundingHistory() only makes sense for swap contracts');
            }
            //
            // swap
            //     {
            //       status => 'ok',
            //       $data => array(
            //         financial_record => array(
            //           array(
            //             id => '1667436164',
            //             $symbol => 'BTC',
            //             type => '30',
            //             amount => '3.9755491985E-8',
            //             ts => '1641168097323',
            //             contract_code => 'BTC-USD'
            //           ),
            //         ),
            //         remain_size => '0',
            //         next_id => null
            //       ),
            //       ts => '1641190296379'
            //     }
            //
        }
        $response = yield $this->$method (array_merge($request, $query));
        $data = $this->safe_value($response, 'data', array());
        $financialRecord = $this->safe_value($data, 'financial_record', array());
        return $this->parse_incomes($financialRecord, $market, $since, $limit);
    }

    public function set_leverage($leverage, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' setLeverage() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        list($marketType, $query) = $this->handle_market_type_and_params('setLeverage', $market, $params);
        $method = null;
        if ($market['linear']) {
            $defaultMargin = $market['future'] ? 'cross' : 'isolated';
            $marginMode = $this->safe_string_2($this->options, 'defaultMarginMode', 'marginMode', $defaultMargin);
            $method = $this->get_supported_mapping($marginMode, array(
                'isolated' => 'contractPrivatePostLinearSwapApiV1SwapSwitchLeverRate',
                'cross' => 'contractPrivatePostLinearSwapApiV1SwapCrossSwitchLeverRate',
            ));
            //
            //     {
            //       status => 'ok',
            //       data => array(
            //         contract_code => 'BTC-USDT',
            //         lever_rate => '100',
            //         margin_mode => 'isolated'
            //       ),
            //       ts => '1641184710649'
            //     }
            //
        } else {
            $method = $this->get_supported_mapping($marketType, array(
                'future' => 'contractPrivatePostApiV1ContractSwitchLeverRate',
                'swap' => 'contractPrivatePostSwapApiV1SwapSwitchLeverRate',
            ));
            //
            // future
            //     {
            //       status => 'ok',
            //       data => array( $symbol => 'BTC', lever_rate => 5 ),
            //       ts => 1641184578678
            //     }
            //
            // swap
            //
            //     {
            //       status => 'ok',
            //       data => array( contract_code => 'BTC-USD', lever_rate => '5' ),
            //       ts => '1641184652979'
            //     }
            //
        }
        $request = array(
            'lever_rate' => $leverage,
        );
        if ($marketType === 'future' && $market['inverse']) {
            $request['symbol'] = $market['settleId'];
        } else {
            $request['contract_code'] = $market['id'];
        }
        $response = yield $this->$method (array_merge($request, $query));
        return $response;
    }

    public function parse_income($income, $market = null) {
        //
        //     {
        //       $id => '1667161118',
        //       $symbol => 'BTC',
        //       type => '31',
        //       $amount => '-2.11306593188E-7',
        //       ts => '1641139308983',
        //       contract_code => 'BTC-USD'
        //     }
        //
        $marketId = $this->safe_string($income, 'contract_code');
        $symbol = $this->safe_symbol($marketId, $market);
        $amount = $this->safe_number($income, 'amount');
        $timestamp = $this->safe_integer($income, 'ts');
        $id = $this->safe_string($income, 'id');
        $currencyId = $this->safe_string_2($income, 'symbol', 'asset');
        $code = $this->safe_currency_code($currencyId);
        return array(
            'info' => $income,
            'symbol' => $symbol,
            'code' => $code,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'id' => $id,
            'amount' => $amount,
        );
    }

    public function parse_incomes($incomes, $market = null, $since = null, $limit = null) {
        $result = array();
        for ($i = 0; $i < count($incomes); $i++) {
            $entry = $incomes[$i];
            $parsed = $this->parse_income($entry, $market);
            $result[] = $parsed;
        }
        $sorted = $this->sort_by($result, 'timestamp');
        return $this->filter_by_since_limit($sorted, $since, $limit, 'timestamp');
    }

    public function parse_position($position, $market = null) {
        //
        //     {
        //       $symbol => 'BTC',
        //       contract_code => 'BTC-USDT',
        //       volume => '1.000000000000000000',
        //       available => '1.000000000000000000',
        //       frozen => '0E-18',
        //       cost_open => '47162.000000000000000000',
        //       cost_hold => '47151.300000000000000000',
        //       profit_unreal => '0.007300000000000000',
        //       profit_rate => '-0.000144183876850008',
        //       lever_rate => '2',
        //       position_margin => '23.579300000000000000',
        //       direction => 'buy',
        //       profit => '-0.003400000000000000',
        //       last_price => '47158.6',
        //       margin_asset => 'USDT',
        //       margin_mode => 'isolated',
        //       margin_account => 'BTC-USDT',
        //       margin_balance => '24.973020070000000000',
        //       margin_position => '23.579300000000000000',
        //       margin_frozen => '0',
        //       margin_available => '1.393720070000000000',
        //       profit_real => '0E-18',
        //       risk_rate => '1.044107779705080303',
        //       withdraw_available => '1.386420070000000000000000000000000000',
        //       liquidation_price => '22353.229148614609571788',
        //       adjust_factor => '0.015000000000000000',
        //       margin_static => '24.965720070000000000'
        //     }
        //
        $market = $this->safe_market($this->safe_string($position, 'contract_code'));
        $symbol = $market['symbol'];
        $contracts = $this->safe_string($position, 'volume');
        $contractSize = $this->safe_value($market, 'contractSize');
        $contractSizeString = $this->number_to_string($contractSize);
        $entryPrice = $this->safe_number($position, 'cost_open');
        $initialMargin = $this->safe_string($position, 'position_margin');
        $rawSide = $this->safe_string($position, 'direction');
        $side = ($rawSide === 'buy') ? 'long' : 'short';
        $unrealizedProfit = $this->safe_number($position, 'profit_unreal');
        $marginMode = $this->safe_string($position, 'margin_mode');
        $leverage = $this->safe_string($position, 'lever_rate');
        $percentage = Precise::string_mul($this->safe_string($position, 'profit_rate'), '100');
        $lastPrice = $this->safe_string($position, 'last_price');
        $faceValue = Precise::string_mul($contracts, $contractSizeString);
        $notional = null;
        if ($market['linear']) {
            $notional = Precise::string_mul($faceValue, $lastPrice);
        } else {
            $notional = Precise::string_div($faceValue, $lastPrice);
            $marginMode = 'cross';
        }
        $intialMarginPercentage = Precise::string_div($initialMargin, $notional);
        $collateral = $this->safe_string($position, 'margin_balance');
        $liquidationPrice = $this->safe_number($position, 'liquidation_price');
        $adjustmentFactor = $this->safe_string($position, 'adjust_factor');
        $maintenanceMarginPercentage = Precise::string_div($adjustmentFactor, $leverage);
        $maintenanceMargin = Precise::string_mul($maintenanceMarginPercentage, $notional);
        $marginRatio = Precise::string_div($maintenanceMargin, $collateral);
        return array(
            'info' => $position,
            'symbol' => $symbol,
            'contracts' => $this->parse_number($contracts),
            'contractSize' => $contractSize,
            'entryPrice' => $entryPrice,
            'collateral' => $this->parse_number($collateral),
            'side' => $side,
            'unrealizedProfit' => $unrealizedProfit,
            'leverage' => $this->parse_number($leverage),
            'percentage' => $this->parse_number($percentage),
            'marginMode' => $marginMode,
            'marginType' => $marginMode, // deprecated
            'notional' => $this->parse_number($notional),
            'markPrice' => null,
            'liquidationPrice' => $liquidationPrice,
            'initialMargin' => $this->parse_number($initialMargin),
            'initialMarginPercentage' => $this->parse_number($intialMarginPercentage),
            'maintenanceMargin' => $this->parse_number($maintenanceMargin),
            'maintenanceMarginPercentage' => $this->parse_number($maintenanceMarginPercentage),
            'marginRatio' => $this->parse_number($marginRatio),
            'timestamp' => null,
            'datetime' => null,
        );
    }

    public function fetch_positions($symbols = null, $params = array ()) {
        yield $this->load_markets();
        $marginMode = $this->safe_string_2($this->options, 'defaultMarginMode', 'marginMode', 'isolated');
        $defaultSubType = $this->safe_string($this->options, 'defaultSubType', 'inverse');
        $marketType = null;
        list($marketType, $params) = $this->handle_market_type_and_params('fetchPositions', null, $params);
        if ($marketType === 'spot') {
            $marketType = 'future';
        }
        $method = null;
        if ($defaultSubType === 'linear') {
            $method = $this->get_supported_mapping($marginMode, array(
                'isolated' => 'contractPrivatePostLinearSwapApiV1SwapPositionInfo',
                'cross' => 'contractPrivatePostLinearSwapApiV1SwapCrossPositionInfo',
            ));
            //
            //     {
            //       status => 'ok',
            //       $data => array(
            //         {
            //           symbol => 'BTC',
            //           contract_code => 'BTC-USDT',
            //           volume => '1.000000000000000000',
            //           available => '1.000000000000000000',
            //           frozen => '0E-18',
            //           cost_open => '47162.000000000000000000',
            //           cost_hold => '47162.000000000000000000',
            //           profit_unreal => '0.047300000000000000',
            //           profit_rate => '0.002005852169119206',
            //           lever_rate => '2',
            //           position_margin => '23.604650000000000000',
            //           direction => 'buy',
            //           profit => '0.047300000000000000',
            //           last_price => '47209.3',
            //           margin_asset => 'USDT',
            //           margin_mode => 'isolated',
            //           margin_account => 'BTC-USDT'
            //         }
            //       ),
            //       ts => '1641108676768'
            //     }
            //
        } else {
            $method = $this->get_supported_mapping($marketType, array(
                'future' => 'contractPrivatePostApiV1ContractPositionInfo',
                'swap' => 'contractPrivatePostSwapApiV1SwapPositionInfo',
            ));
            //
            // future
            //     {
            //       status => 'ok',
            //       $data => array(
            //         {
            //           symbol => 'BTC',
            //           contract_code => 'BTC220624',
            //           contract_type => 'next_quarter',
            //           volume => '1.000000000000000000',
            //           available => '1.000000000000000000',
            //           frozen => '0E-18',
            //           cost_open => '49018.880000000009853343',
            //           cost_hold => '49018.880000000009853343',
            //           profit_unreal => '-8.62360608500000000000000000000000000000000000000E-7',
            //           profit_rate => '-0.000845439023678622',
            //           lever_rate => '2',
            //           position_margin => '0.001019583964880634',
            //           direction => 'sell',
            //           profit => '-8.62360608500000000000000000000000000000000000000E-7',
            //           last_price => '49039.61'
            //         }
            //       ),
            //       ts => '1641109895199'
            //     }
            //
            // swap
            //     {
            //       status => 'ok',
            //       $data => array(
            //         {
            //           symbol => 'BTC',
            //           contract_code => 'BTC-USD',
            //           volume => '1.000000000000000000',
            //           available => '1.000000000000000000',
            //           frozen => '0E-18',
            //           cost_open => '47150.000000000012353300',
            //           cost_hold => '47150.000000000012353300',
            //           profit_unreal => '0E-54',
            //           profit_rate => '-7.86E-16',
            //           lever_rate => '3',
            //           position_margin => '0.000706963591375044',
            //           direction => 'buy',
            //           profit => '0E-54',
            //           last_price => '47150'
            //         }
            //       ),
            //       ts => '1641109636572'
            //     }
            //
        }
        $response = yield $this->$method ($params);
        $data = $this->safe_value($response, 'data', array());
        $timestamp = $this->safe_integer($response, 'ts');
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $position = $data[$i];
            $parsed = $this->parse_position($position);
            $result[] = array_merge($parsed, array(
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
            ));
        }
        return $this->filter_by_array($result, 'symbol', $symbols, false);
    }

    public function fetch_position($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $marginMode = $this->safe_string_2($this->options, 'defaultMarginMode', 'marginMode', 'isolated');
        $marginMode = $this->safe_string_2($params, 'marginMode', 'defaultMarginMode', $marginMode);
        $params = $this->omit($params, array( 'defaultMarginMode', 'marginMode' ));
        list($marketType, $query) = $this->handle_market_type_and_params('fetchPosition', $market, $params);
        $method = null;
        if ($market['linear']) {
            $method = $this->get_supported_mapping($marginMode, array(
                'isolated' => 'contractPrivatePostLinearSwapApiV1SwapAccountPositionInfo',
                'cross' => 'contractPrivatePostLinearSwapApiV1SwapCrossAccountPositionInfo',
            ));
            //
            // isolated
            //
            //     {
            //         "status" => "ok",
            //         "data" => array(
            //             array(
            //                 "positions" => array(),
            //                 "symbol" => "BTC",
            //                 "margin_balance" => 1.949728350000000000,
            //                 "margin_position" => 0,
            //                 "margin_frozen" => 0E-18,
            //                 "margin_available" => 1.949728350000000000,
            //                 "profit_real" => -0.050271650000000000,
            //                 "profit_unreal" => 0,
            //                 "risk_rate" => null,
            //                 "withdraw_available" => 1.949728350000000000,
            //                 "liquidation_price" => null,
            //                 "lever_rate" => 20,
            //                 "adjust_factor" => 0.150000000000000000,
            //                 "margin_static" => 1.949728350000000000,
            //                 "contract_code" => "BTC-USDT",
            //                 "margin_asset" => "USDT",
            //                 "margin_mode" => "isolated",
            //                 "margin_account" => "BTC-USDT",
            //                 "trade_partition" => "USDT",
            //                 "position_mode" => "dual_side"
            //             ),
            //             ... opposite side $position can be present here too (if hedge)
            //         ),
            //         "ts" => 1653605008286
            //     }
            //
            // cross
            //
            //     {
            //         "status" => "ok",
            //         "data" => array(
            //             "positions" => array(
            //                 array(
            //                     "symbol" => "BTC",
            //                     "contract_code" => "BTC-USDT",
            //                     "volume" => "1.000000000000000000",
            //                     "available" => "1.000000000000000000",
            //                     "frozen" => "0E-18",
            //                     "cost_open" => "29530.000000000000000000",
            //                     "cost_hold" => "29530.000000000000000000",
            //                     "profit_unreal" => "-0.010000000000000000",
            //                     "profit_rate" => "-0.016931933626820200",
            //                     "lever_rate" => "50",
            //                     "position_margin" => "0.590400000000000000",
            //                     "direction" => "buy",
            //                     "profit" => "-0.010000000000000000",
            //                     "last_price" => "29520",
            //                     "margin_asset" => "USDT",
            //                     "margin_mode" => "cross",
            //                     "margin_account" => "USDT",
            //                     "contract_type" => "swap",
            //                     "pair" => "BTC-USDT",
            //                     "business_type" => "swap",
            //                     "trade_partition" => "USDT",
            //                     "position_mode" => "dual_side"
            //                 ),
            //                 ... opposite side $position can be present here too (if hedge)
            //             ),
            //             "futures_contract_detail" => array(
            //                 array(
            //                     "symbol" => "BTC",
            //                     "contract_code" => "BTC-USDT-220624",
            //                     "margin_position" => "0",
            //                     "margin_frozen" => "0E-18",
            //                     "margin_available" => "1.497799766913531118",
            //                     "profit_unreal" => "0",
            //                     "liquidation_price" => null,
            //                     "lever_rate" => "30",
            //                     "adjust_factor" => "0.250000000000000000",
            //                     "contract_type" => "quarter",
            //                     "pair" => "BTC-USDT",
            //                     "business_type" => "futures",
            //                     "trade_partition" => "USDT"
            //                 ),
            //                 ... other items listed with different expiration (contract_code)
            //             ),
            //             "margin_mode" => "cross",
            //             "margin_account" => "USDT",
            //             "margin_asset" => "USDT",
            //             "margin_balance" => "2.088199766913531118",
            //             "margin_static" => "2.098199766913531118",
            //             "margin_position" => "0.590400000000000000",
            //             "margin_frozen" => "0E-18",
            //             "profit_real" => "-0.016972710000000000",
            //             "profit_unreal" => "-0.010000000000000000",
            //             "withdraw_available" => "1.497799766913531118",
            //             "risk_rate" => "9.105496355562965147",
            //             "contract_detail" => array(
            //                array(
            //                     "symbol" => "BTC",
            //                     "contract_code" => "BTC-USDT",
            //                     "margin_position" => "0.590400000000000000",
            //                     "margin_frozen" => "0E-18",
            //                     "margin_available" => "1.497799766913531118",
            //                     "profit_unreal" => "-0.010000000000000000",
            //                     "liquidation_price" => "27625.176468365024050352",
            //                     "lever_rate" => "50",
            //                     "adjust_factor" => "0.350000000000000000",
            //                     "contract_type" => "swap",
            //                     "pair" => "BTC-USDT",
            //                     "business_type" => "swap",
            //                     "trade_partition" => "USDT"
            //                 ),
            //                 ... all symbols listed
            //             ),
            //             "position_mode" => "dual_side"
            //         ),
            //         "ts" => "1653604697466"
            //     }
            //
        } else {
            $method = $this->get_supported_mapping($marketType, array(
                'future' => 'contractPrivatePostApiV1ContractAccountPositionInfo',
                'swap' => 'contractPrivatePostSwapApiV1SwapAccountPositionInfo',
            ));
            //
            // future, swap
            //
            //     {
            //       "status" => "ok",
            //       "data" => array(
            //         {
            //             "symbol" => "XRP",
            //             "contract_code" => "XRP-USD", // only present in swap
            //             "margin_balance" => 12.186361450698276582,
            //             "margin_position" => 5.036261079774375503,
            //             "margin_frozen" => 0E-18,
            //             "margin_available" => 7.150100370923901079,
            //             "profit_real" => -0.012672343876723438,
            //             "profit_unreal" => 0.163382354575000020,
            //             "risk_rate" => 2.344723929650649798,
            //             "withdraw_available" => 6.986718016348901059,
            //             "liquidation_price" => 0.271625200493799547,
            //             "lever_rate" => 5,
            //             "adjust_factor" => 0.075000000000000000,
            //             "margin_static" => 12.022979096123276562,
            //             "positions" => array(
            //                 array(
            //                     "symbol" => "XRP",
            //                     "contract_code" => "XRP-USD",
            //                     // "contract_type" => "this_week", // only present in future
            //                     "volume" => 1.0,
            //                     "available" => 1.0,
            //                     "frozen" => 0E-18,
            //                     "cost_open" => 0.394560000000000000,
            //                     "cost_hold" => 0.394560000000000000,
            //                     "profit_unreal" => 0.163382354575000020,
            //                     "profit_rate" => 0.032232070910556005,
            //                     "lever_rate" => 5,
            //                     "position_margin" => 5.036261079774375503,
            //                     "direction" => "buy",
            //                     "profit" => 0.163382354575000020,
            //                     "last_price" => 0.39712
            //                 ),
            //                 ... opposite side $position can be present here too (if hedge)
            //             )
            //         }
            //       ),
            //       "ts" => 1653600470199
            //     }
            //
            // cross usdt swap
            //
            //     {
            //         "status":"ok",
            //         "data":array(
            //             "positions":array(),
            //             "futures_contract_detail":array()
            //             "margin_mode":"cross",
            //             "margin_account":"USDT",
            //             "margin_asset":"USDT",
            //             "margin_balance":"1.000000000000000000",
            //             "margin_static":"1.000000000000000000",
            //             "margin_position":"0",
            //             "margin_frozen":"1.000000000000000000",
            //             "profit_real":"0E-18",
            //             "profit_unreal":"0",
            //             "withdraw_available":"0",
            //             "risk_rate":"15.666666666666666666",
            //             "contract_detail":array()
            //         ),
            //         "ts":"1645521118946"
            //     }
            //
        }
        $request = array();
        if ($market['future'] && $market['inverse']) {
            $request['symbol'] = $market['settleId'];
        } else {
            if ($marginMode === 'cross') {
                $request['margin_account'] = 'USDT'; // only allowed value
            }
            $request['contract_code'] = $market['id'];
        }
        $response = yield $this->$method (array_merge($request, $query));
        $data = $this->safe_value($response, 'data');
        $account = null;
        if ($marginMode === 'cross') {
            $account = $data;
        } else {
            $account = $this->safe_value($data, 0);
        }
        $omitted = $this->omit($account, array( 'positions' ));
        $positions = $this->safe_value($account, 'positions');
        $position = null;
        if ($market['future'] && $market['inverse']) {
            for ($i = 0; $i < count($positions); $i++) {
                $entry = $positions[$i];
                if ($entry['contract_code'] === $market['id']) {
                    $position = $entry;
                    break;
                }
            }
        } else {
            $position = $this->safe_value($positions, 0);
        }
        $timestamp = $this->safe_integer($response, 'ts');
        $parsed = $this->parse_position(array_merge($position, $omitted));
        return array_merge($parsed, array(
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
        ));
    }

    public function parse_ledger_entry_type($type) {
        $types = array(
            'trade' => 'trade',
            'etf' => 'trade',
            'transact-fee' => 'fee',
            'fee-deduction' => 'fee',
            'transfer' => 'transfer',
            'credit' => 'credit',
            'liquidation' => 'trade',
            'interest' => 'credit',
            'deposit' => 'deposit',
            'withdraw' => 'withdrawal',
            'withdraw-fee' => 'fee',
            'exchange' => 'exchange',
            'other-types' => 'transfer',
            'rebate' => 'rebate',
        );
        return $this->safe_string($types, $type, $type);
    }

    public function parse_ledger_entry($item, $currency = null) {
        //
        //     {
        //         "accountId" => 10000001,
        //         "currency" => "usdt",
        //         "transactAmt" => 10.000000000000000000,
        //         "transactType" => "transfer",
        //         "transferType" => "margin-transfer-out",
        //         "transactId" => 0,
        //         "transactTime" => 1629882331066,
        //         "transferer" => 28483123,
        //         "transferee" => 13496526
        //     }
        //
        $id = $this->safe_string($item, 'transactId');
        $currencyId = $this->safe_string($item, 'currency');
        $code = $this->safe_currency_code($currencyId, $currency);
        $amount = $this->safe_number($item, 'transactAmt');
        $transferType = $this->safe_string($item, 'transferType');
        $type = $this->parse_ledger_entry_type($transferType);
        $direction = $this->safe_string($item, 'direction');
        $timestamp = $this->safe_integer($item, 'transactTime');
        $datetime = $this->iso8601($timestamp);
        $account = $this->safe_string($item, 'accountId');
        return array(
            'id' => $id,
            'direction' => $direction,
            'account' => $account,
            'referenceId' => $id,
            'referenceAccount' => $account,
            'type' => $type,
            'currency' => $code,
            'amount' => $amount,
            'timestamp' => $timestamp,
            'datetime' => $datetime,
            'before' => null,
            'after' => null,
            'status' => null,
            'fee' => null,
            'info' => $item,
        );
    }

    public function fetch_ledger($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $accountId = yield $this->fetch_account_id_by_type('spot', $params);
        $request = array(
            'accountId' => $accountId,
            // 'currency' => $code,
            // 'transactTypes' => 'all', // default all
            // 'startTime' => 1546272000000,
            // 'endTime' => 1546272000000,
            // 'sort' => asc, // asc, desc
            // 'limit' => 100, // range 1-500
            // 'fromId' => 323 // first record ID in this query for pagination
        );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'];
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit; // max 500
        }
        $response = yield $this->spotPrivateGetV2AccountLedger (array_merge($request, $params));
        //
        //     {
        //         "code" => 200,
        //         "message" => "success",
        //         "data" => array(
        //             array(
        //                 "accountId" => 10000001,
        //                 "currency" => "usdt",
        //                 "transactAmt" => 10.000000000000000000,
        //                 "transactType" => "transfer",
        //                 "transferType" => "margin-transfer-out",
        //                 "transactId" => 0,
        //                 "transactTime" => 1629882331066,
        //                 "transferer" => 28483123,
        //                 "transferee" => 13496526
        //             ),
        //             {
        //                 "accountId" => 10000001,
        //                 "currency" => "usdt",
        //                 "transactAmt" => -10.000000000000000000,
        //                 "transactType" => "transfer",
        //                 "transferType" => "margin-transfer-in",
        //                 "transactId" => 0,
        //                 "transactTime" => 1629882096562,
        //                 "transferer" => 13496526,
        //                 "transferee" => 28483123
        //             }
        //         ),
        //         "nextId" => 1624316679,
        //         "ok" => true
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_ledger($data, $currency, $since, $limit);
    }

    public function fetch_leverage_tiers($symbols = null, $params = array ()) {
        yield $this->load_markets();
        $response = yield $this->contractPublicGetLinearSwapApiV1SwapAdjustfactor ($params);
        //
        //    {
        //        "status" => "ok",
        //        "data" => array(
        //            {
        //                "symbol" => "MANA",
        //                "contract_code" => "MANA-USDT",
        //                "margin_mode" => "isolated",
        //                "trade_partition" => "USDT",
        //                "list" => array(
        //                    array(
        //                        "lever_rate" => 75,
        //                        "ladders" => array(
        //                            array(
        //                                "ladder" => 0,
        //                                "min_size" => 0,
        //                                "max_size" => 999,
        //                                "adjust_factor" => 0.7
        //                            ),
        //                            ...
        //                        )
        //                    }
        //                    ...
        //                )
        //            ),
        //            ...
        //        )
        //    }
        //
        $data = $this->safe_value($response, 'data');
        return $this->parse_leverage_tiers($data, $symbols, 'contract_code');
    }

    public function fetch_market_leverage_tiers($symbol, $params = array ()) {
        yield $this->load_markets();
        $request = array();
        if ($symbol !== null) {
            $market = $this->market($symbol);
            if (!$market['contract']) {
                throw new BadRequest($this->id . ' fetchMarketLeverageTiers() $symbol supports contract markets only');
            }
            $request['contract_code'] = $market['id'];
        }
        $response = yield $this->contractPublicGetLinearSwapApiV1SwapAdjustfactor (array_merge($request, $params));
        //
        //    {
        //        "status" => "ok",
        //        "data" => array(
        //            {
        //                "symbol" => "MANA",
        //                "contract_code" => "MANA-USDT",
        //                "margin_mode" => "isolated",
        //                "trade_partition" => "USDT",
        //                "list" => array(
        //                    array(
        //                        "lever_rate" => 75,
        //                        "ladders" => array(
        //                            array(
        //                                "ladder" => 0,
        //                                "min_size" => 0,
        //                                "max_size" => 999,
        //                                "adjust_factor" => 0.7
        //                            ),
        //                            ...
        //                        )
        //                    }
        //                    ...
        //                )
        //            ),
        //            ...
        //        )
        //    }
        //
        $data = $this->safe_value($response, 'data');
        $tiers = $this->parse_leverage_tiers($data, array( $symbol ), 'contract_code');
        return $this->safe_value($tiers, $symbol);
    }

    public function parse_leverage_tiers($response, $symbols, $marketIdKey) {
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $item = $response[$i];
            $list = $this->safe_value($item, 'list', array());
            $tiers = array();
            $currency = $this->safe_string($item, 'trade_partition');
            $id = $this->safe_string($item, $marketIdKey);
            $symbol = $this->safe_symbol($id);
            if ($this->in_array($symbols, $symbol)) {
                for ($j = 0; $j < count($list); $j++) {
                    $obj = $list[$j];
                    $leverage = $this->safe_string($obj, 'lever_rate');
                    $ladders = $this->safe_value($obj, 'ladders', array());
                    for ($k = 0; $k < count($ladders); $k++) {
                        $bracket = $ladders[$k];
                        $adjustFactor = $this->safe_string($bracket, 'adjust_factor');
                        $tiers[] = array(
                            'tier' => $this->safe_integer($bracket, 'ladder'),
                            'currency' => $this->safe_currency_code($currency),
                            'minNotional' => $this->safe_number($bracket, 'min_size'),
                            'maxNotional' => $this->safe_number($bracket, 'max_size'),
                            'maintenanceMarginRate' => $this->parse_number(Precise::string_div($adjustFactor, $leverage)),
                            'maxLeverage' => $this->parse_number($leverage),
                            'info' => $bracket,
                        );
                    }
                }
                $result[$symbol] = $tiers;
            }
        }
        return $result;
    }

    public function fetch_open_interest_history($symbol, $timeframe = '1h', $since = null, $limit = null, $params = array ()) {
        /**
         * Retrieves the open intestest history of a currency
         * @param {str} $symbol Unified CCXT $market $symbol
         * @param {str} $timeframe '1h', '4h', '12h', or '1d'
         * @param {int|null} $since Not used by huobi api, but $response parsed by CCXT
         * @param {int|null} $limit Default：48，Data Range [1,200]
         * @param {dict} $params Exchange specific parameters
         * @param {int} $params->amount_type *required* Open interest unit. 1-cont，2-cryptocurrenty
         * @param {int|null} $params->pair eg BTC-USDT *Only for USDT-M*
         * @return {dict} an array of {@link https://docs.ccxt.com/en/latest/manual.html#open-interest-structure open interest structures}
         */
        if ($timeframe !== '1h' && $timeframe !== '4h' && $timeframe !== '12h' && $timeframe !== '1d') {
            throw new BadRequest($this->id . ' fetchOpenInterestHistory cannot only use the 1h, 4h, 12h and 1d timeframe');
        }
        yield $this->load_markets();
        $timeframes = array(
            '1h' => '60min',
            '4h' => '4hour',
            '12h' => '12hour',
            '1d' => '1day',
        );
        $market = $this->market($symbol);
        $amountType = $this->safe_number_2($params, 'amount_type', 'amountType');
        if ($amountType === null) {
            throw new ArgumentsRequired($this->id . ' fetchOpenInterestHistory requires parameter $params->amountType to be either 1 (cont), or 2 (cryptocurrenty)');
        }
        $request = array(
            'period' => $timeframes[$timeframe],
            'amount_type' => $amountType,
        );
        $method = null;
        if ($market['future']) {
            $request['contract_type'] = $this->safe_string($market['info'], 'contract_type');
            $request['symbol'] = $market['baseId'];  // currency code on coin-m futures
            $method = 'contractPublicGetApiV1ContractHisOpenInterest'; // coin-m futures
        } elseif ($market['linear']) {
            $request['contract_type'] = 'swap';
            $request['contract_code'] = $market['id'];
            $request['contract_code'] = $market['id'];
            $method = 'contractPublicGetLinearSwapApiV1SwapHisOpenInterest'; // USDT-M
        } else {
            $request['contract_code'] = $market['id'];
            $method = 'contractPublicGetSwapApiV1SwapHisOpenInterest'; // coin-m swaps
        }
        if ($limit !== null) {
            $request['size'] = $limit;
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        //  contractPublicGetlinearSwapApiV1SwapHisOpenInterest
        //    {
        //        status => 'ok',
        //        $data => array(
        //            $symbol => 'BTC',
        //            $tick => array(
        //                array(
        //                    volume => '4385.4350000000000000',
        //                    amount_type => '2',
        //                    ts => '1648220400000',
        //                    value => '194059884.1850000000000000'
        //                ),
        //                ...
        //            ),
        //            contract_code => 'BTC-USDT',
        //            business_type => 'swap',
        //            pair => 'BTC-USDT',
        //            contract_type => 'swap',
        //            trade_partition => 'USDT'
        //        ),
        //        ts => '1648223733007'
        //    }
        //
        //  contractPublicGetSwapApiV1SwapHisOpenInterest
        //    {
        //        "status" => "ok",
        //        "data" => array(
        //            "symbol" => "CRV",
        //            "tick" => array(
        //                array(
        //                    "volume" => 19174.0000000000000000,
        //                    "amount_type" => 1,
        //                    "ts" => 1648224000000
        //                ),
        //                ...
        //            ),
        //            "contract_code" => "CRV-USD"
        //        ),
        //        "ts" => 1648226554260
        //    }
        //
        //  contractPublicGetApiV1ContractHisOpenInterest
        //    {
        //         "status" => "ok",
        //         "data" => array(
        //             "symbol" => "BTC",
        //             "contract_type" => "this_week",
        //             "tick" => array(
        //                array(
        //                     "volume" => "48419.0000000000000000",
        //                     "amount_type" => 1,
        //                     "ts" => 1648224000000
        //                ),
        //                ...
        //            )
        //        ),
        //        "ts" => 1648227062944
        //    }
        //
        $data = $this->safe_value($response, 'data');
        $tick = $this->safe_value($data, 'tick');
        return $this->parse_open_interests($tick, null, $since, $limit);
    }

    public function parse_open_interest($interest, $market = null) {
        //
        //    {
        //        volume => '4385.4350000000000000',
        //        amount_type => '2',
        //        ts => '1648220400000',
        //        value => '194059884.1850000000000000'
        //    }
        //
        $timestamp = $this->safe_number($interest, 'ts');
        return array(
            'symbol' => $this->safe_string($market, 'symbol'),
            'baseVolume' => $this->safe_number($interest, 'volume'),
            'quoteVolume' => $this->safe_value($interest, 'value'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'info' => $interest,
        );
    }
}
