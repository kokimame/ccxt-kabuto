<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\ArgumentsRequired;
use \ccxt\BadRequest;
use \ccxt\InvalidAddress;
use \ccxt\InvalidOrder;
use \ccxt\NotSupported;

class mexc3 extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'mexc3',
            'name' => 'MEXC Global',
            'countries' => array( 'SC' ), // Seychelles
            'rateLimit' => 50, // default rate limit is 20 times per second
            'version' => 'v3',
            'has' => array(
                'CORS' => null,
                'spot' => null,
                'margin' => null,
                'swap' => null,
                'future' => null,
                'option' => null,
                'addMargin' => true,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'cancelOrders' => null,
                'createDepositAddress' => null,
                'createLimitOrder' => null,
                'createMarketOrder' => null,
                'createOrder' => true,
                'deposit' => null,
                'editOrder' => null,
                'fetchAccounts' => true,
                'fetchBalance' => true,
                'fetchBidsAsks' => true,
                'fetchBorrowRate' => null,
                'fetchBorrowRateHistory' => null,
                'fetchBorrowRates' => null,
                'fetchBorrowRatesPerSymbol' => null,
                'fetchCanceledOrders' => true,
                'fetchClosedOrder' => null,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => true,
                'fetchDeposit' => null,
                'fetchDepositAddress' => true,
                'fetchDepositAddresses' => null,
                'fetchDepositAddressesByNetwork' => true,
                'fetchDeposits' => true,
                'fetchFundingHistory' => true,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => true,
                'fetchFundingRates' => null,
                'fetchIndexOHLCV' => true,
                'fetchL2OrderBook' => true,
                'fetchLedger' => null,
                'fetchLedgerEntry' => null,
                'fetchLeverageTiers' => true,
                'fetchMarketLeverageTiers' => null,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrder' => null,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrderBooks' => null,
                'fetchOrders' => true,
                'fetchOrderTrades' => true,
                'fetchPosition' => true,
                'fetchPositions' => true,
                'fetchPositionsRisk' => null,
                'fetchPremiumIndexOHLCV' => false,
                'fetchStatus' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => null,
                'fetchTradingFees' => true,
                'fetchTradingLimits' => null,
                'fetchTransactionFee' => null,
                'fetchTransactionFees' => null,
                'fetchTransactions' => null,
                'fetchTransfer' => true,
                'fetchTransfers' => true,
                'fetchWithdrawal' => null,
                'fetchWithdrawals' => true,
                'loadMarkets' => null,
                'privateAPI' => true,
                'publicAPI' => true,
                'reduceMargin' => true,
                'setLeverage' => true,
                'setMarginMode' => null,
                'setPositionMode' => null,
                'signIn' => null,
                'transfer' => null,
                'withdraw' => true,
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/137283979-8b2a818d-8633-461b-bfca-de89e8c446b2.jpg',
                'api' => array(
                    'spot' => array(
                        'public' => 'https://api.mexc.com',
                        'private' => 'https://api.mexc.com',
                    ),
                    'spot2' => array(
                        'public' => 'https://www.mexc.com/open/api/v2',
                        'private' => 'https://www.mexc.com/open/api/v2',
                    ),
                    'contract' => array(
                        'public' => 'https://contract.mexc.com/api/v1/contract',
                        'private' => 'https://contract.mexc.com/api/v1/private',
                    ),
                ),
                'www' => 'https://www.mexc.com/',
                'doc' => array(
                    'https://mxcdevelop.github.io/apidocs/spot_v3_en/',
                    'https://mxcdevelop.github.io/APIDoc/', // v1 & v2 : soon to be deprecated
                ),
                'fees' => array(
                    'https://www.mexc.com/fee',
                ),
                'referral' => 'https://m.mexc.com/auth/signup?inviteCode=1FQ1G',
            ),
            'api' => array(
                'spot' => array(
                    'public' => array(
                        'get' => array(
                            'ping' => 1,
                            'time' => 1,
                            'exchangeInfo' => 1,
                            'depth' => 1,
                            'trades' => 1,
                            'historicalTrades' => 1,
                            'aggTrades' => 1,
                            'klines' => 1,
                            'avgPrice' => 1,
                            'ticker/24hr' => 1,
                            'ticker/price' => 1,
                            'ticker/bookTicker' => 1,
                            'etf/info' => 1,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            'order' => 1,
                            'openOrders' => 1,
                            'allOrders' => 1,
                            'account' => 1,
                            'myTrades' => 1,
                            'sub-account/list' => 1,
                            'sub-account/apiKey' => 1,
                        ),
                        'post' => array(
                            'order' => 1,
                            'order/test' => 1,
                            'sub-account/virtualSubAccount' => 1,
                            'sub-account/apiKey' => 1,
                        ),
                        'delete' => array(
                            'order' => 1,
                            'openOrders' => 1,
                            'sub-account/apiKey' => 1,
                        ),
                    ),
                ),
                'contract' => array(
                    'public' => array(
                        'get' => array(
                            'ping' => 2,
                            'detail' => 2,
                            'support_currencies' => 2, // TODO => should we implement 'fetchCurrencies' solely for swap? because spot doesnt have it atm
                            'depth/{symbol}' => 2,
                            'depth_commits/{symbol}/{limit}' => 2,
                            'index_price/{symbol}' => 2,
                            'fair_price/{symbol}' => 2,
                            'funding_rate/{symbol}' => 2,
                            'kline/{symbol}' => 2,
                            'kline/index_price/{symbol}' => 2,
                            'kline/fair_price/{symbol}' => 2,
                            'deals/{symbol}' => 2,
                            'ticker' => 2,
                            'risk_reverse' => 2,
                            'risk_reverse/history' => 2,
                            'funding_rate/history' => 2,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            'account/assets' => 2,
                            'account/asset/{currency}' => 2,
                            'account/transfer_record' => 2,
                            'position/list/history_positions' => 2,
                            'position/open_positions' => 2,
                            'position/funding_records' => 2,
                            'order/list/open_orders/{symbol}' => 2,
                            'order/list/history_orders' => 2,
                            'order/external/{symbol}/{external_oid}' => 2,
                            'order/get/{order_id}' => 2,
                            'order/batch_query' => 8,
                            'order/deal_details/{order_id}' => 2,
                            'order/list/order_deals' => 2,
                            'planorder/list/orders' => 2,
                            'stoporder/list/orders' => 2,
                            'stoporder/order_details/{stop_order_id}' => 2,
                            'account/risk_limit' => 2, // TO_DO => gets max/min position size, allowed sides, leverage, maintenance margin, initial margin, etc...
                            'account/tiered_fee_rate' => 2, // TO_DO => taker/maker fees for account
                        ),
                        'post' => array(
                            'position/change_margin' => 2,
                            'position/change_leverage' => 2,
                            'order/submit' => 2,
                            'order/submit_batch' => 40,
                            'order/cancel' => 2,
                            'order/cancel_with_external' => 2,
                            'order/cancel_all' => 2,
                            'account/change_risk_level' => 2,
                            'planorder/place' => 2,
                            'planorder/cancel' => 2,
                            'planorder/cancel_all' => 2,
                            'stoporder/cancel' => 2,
                            'stoporder/cancel_all' => 2,
                            'stoporder/change_price' => 2,
                            'stoporder/change_plan_price' => 2,
                        ),
                    ),
                ),
                'spot2' => array(
                    'public' => array(
                        'get' => array(
                            'market/symbols' => 1,
                            'market/coin/list' => 2,
                            'common/timestamp' => 1,
                            'common/ping' => 1,
                            'market/ticker' => 1,
                            'market/depth' => 1,
                            'market/deals' => 1,
                            'market/kline' => 1,
                            'market/api_default_symbols' => 2,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            'account/info' => 1,
                            'order/open_orders' => 1,
                            'order/list' => 1,
                            'order/query' => 1,
                            'order/deals' => 1,
                            'order/deal_detail' => 1,
                            'asset/deposit/address/list' => 2,
                            'asset/deposit/list' => 2,
                            'asset/address/list' => 2,
                            'asset/withdraw/list' => 2,
                            'asset/internal/transfer/record' => 10,
                            'account/balance' => 10,
                            'asset/internal/transfer/info' => 10,
                            'market/api_symbols' => 2,
                        ),
                        'post' => array(
                            'order/place' => 1,
                            'order/place_batch' => 1,
                            'asset/withdraw' => 2,
                            'asset/internal/transfer' => 10,
                        ),
                        'delete' => array(
                            'order/cancel' => 1,
                            'order/cancel_by_symbol' => 1,
                            'asset/withdraw' => 2,
                        ),
                    ),
                ),
            ),
            'timeframes' => array(
                '1m' => '1m', // spot, swap
                '3m' => '3m', // spot
                '5m' => '5m', // spot, swap
                '15m' => '15m', // spot, swap
                '30m' => '30m', // spot, swap
                '1h' => '1h', // spot, swap
                '2h' => '2h', // spot
                '4h' => '4h', // spot, swap
                '6h' => '6h', // spot
                '8h' => '8h', // spot, swap
                '12h' => '12h', // spot
                '1d' => '1d', // spot, swap
                '3d' => '3d', // spot
                '1w' => '1w', // spot, swap
                '1M' => '1M', // spot, swap
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => false,
                    'percentage' => true,
                    'maker' => 0.2 / 100, // maker / taker
                    'taker' => 0.2 / 100,
                ),
            ),
            'options' => array(
                'createMarketBuyOrderRequiresPrice' => true,
                'unavailableContracts' => array(
                    'BTC/USDT:USDT' => true,
                    'LTC/USDT:USDT' => true,
                    'ETH/USDT:USDT' => true,
                ),
                'fetchMarkets' => array(
                    'types' => array(
                        'spot' => true,
                        'future' => array(
                            'linear' => false,
                            'inverse' => false,
                        ),
                        'swap' => array(
                            'linear' => true,
                            'inverse' => false,
                        ),
                    ),
                ),
                'timeframes' => array(
                    'spot' => array(
                        '1m' => '1m',
                        '3m' => '3m',
                        '5m' => '5m',
                        '15m' => '15m',
                        '30m' => '30m',
                        '1h' => '1h',
                        '2h' => '2h',
                        '4h' => '4h',
                        '6h' => '6h',
                        '8h' => '8h',
                        '12h' => '12h',
                        '1d' => '1d',
                        '3d' => '3d',
                        '1w' => '1w',
                        '1M' => '1M',
                    ),
                    'swap' => array(
                        '1m' => 'Min1',
                        '5m' => 'Min5',
                        '15m' => 'Min15',
                        '30m' => 'Min30',
                        '1h' => 'Min60',
                        '4h' => 'Hour4',
                        '8h' => 'Hour8',
                        '1d' => 'Day1',
                        '1w' => 'Week1',
                        '1M' => 'Month1',
                    ),
                ),
                'defaultType' => 'spot', // spot, swap
                'networks' => array(
                    'TRX' => 'TRC-20',
                    'TRC20' => 'TRC-20',
                    'ETH' => 'ERC-20',
                    'ERC20' => 'ERC-20',
                    'BEP20' => 'BEP20(BSC)',
                    'BSC' => 'BEP20(BSC)',
                ),
                'networkAliases' => array(
                    'BSC(BEP20)' => 'BSC',
                ),
                'recvWindow' => 5 * 1000, // 5 sec, default
                'maxTimeTillEnd' => 90 * 86400 * 1000 - 1, // 90 days
            ),
            'commonCurrencies' => array(
                'BEYONDPROTOCOL' => 'BEYOND',
                'BIFI' => 'BIFIF',
                'BYN' => 'BeyondFi',
                'COFI' => 'COFIX', // conflict with CoinFi
                'DFI' => 'DfiStarter',
                'DFT' => 'dFuture',
                'DRK' => 'DRK',
                'EGC' => 'Egoras Credit',
                'FLUX1' => 'FLUX', // switched places
                'FLUX' => 'FLUX1', // switched places
                'FREE' => 'FreeRossDAO', // conflict with FREE Coin
                'HERO' => 'Step Hero', // conflict with Metahero
                'MIMO' => 'Mimosa',
                'PROS' => 'Pros.Finance', // conflict with Prosper
                'SIN' => 'Sin City Token',
            ),
            'exceptions' => array(
                'exact' => array(
                    // until mexc migrates fully to v3, it might be worth to note the version & market aside errors, not easily remove obsolete version's exceptions in future
                    '-1128' => '\\ccxt\\BadRequest',
                    '-2011' => '\\ccxt\\BadRequest',
                    '-1121' => '\\ccxt\\BadSymbol',
                    '2011' => '\\ccxt\\BadRequest',
                    '30004' => '\\ccxt\\InsufficientFunds',
                    '1002' => '\\ccxt\\InvalidOrder',
                    '30019' => '\\ccxt\\BadRequest',
                    '30005' => '\\ccxt\\InvalidOrder',
                    '2003' => '\\ccxt\\InvalidOrder',
                    '2005' => '\\ccxt\\InsufficientFunds',
                    '600' => '\\ccxt\\BadRequest',
                ),
                'broad' => array(
                    'Order quantity error, please try to modify.' => '\\ccxt\\BadRequest', // code:2011
                    'Combination of optional parameters invalid' => '\\ccxt\\BadRequest', // code:-2011
                    'api market order is disabled' => '\\ccxt\\BadRequest', //
                    'Contract not allow place order!' => '\\ccxt\\InvalidOrder', // code:1002
                    'Oversold' => '\\ccxt\\InvalidOrder', // code:30005
                    'Insufficient position' => '\\ccxt\\InsufficientFunds', // code:30004
                    'Insufficient balance!' => '\\ccxt\\InsufficientFunds', // code:2005
                    'Bid price is great than max allow price' => '\\ccxt\\InvalidOrder', // code:2003
                    'Invalid symbol.' => '\\ccxt\\BadSymbol', // code:-1121
                    'Param error!' => '\\ccxt\\BadRequest', // code:600
                ),
            ),
        ));
    }

    public function fetch_status($params = array ()) {
        /**
         * the latest known information on the availability of the exchange API
         * @param {dict} $params extra parameters specific to the mexc3 api endpoint
         * @return {dict} a {@link https://docs.ccxt.com/en/latest/manual.html#exchange-$status-structure $status structure}
         */
        list($marketType, $query) = $this->handle_market_type_and_params('fetchStatus', null, $params);
        $response = null;
        $status = null;
        $updated = null;
        if ($marketType === 'spot') {
            $response = $this->spotPublicGetPing ($query);
            //
            //     array()
            //
            $status = $response ? $this->json($response) : 'ok';
        } elseif ($marketType === 'swap') {
            $response = $this->contractPublicGetPing ($query);
            //
            //     array("success":true,"code":"0","data":"1648124374985")
            //
            $status = $this->safe_value($response, 'success') ? 'ok' : $this->json($response);
            $updated = $this->safe_integer($response, 'data');
        }
        return array(
            'status' => $status,
            'updated' => $updated,
            'url' => null,
            'eta' => null,
            'info' => $response,
        );
    }

    public function fetch_time($params = array ()) {
        /**
         * fetches the current integer timestamp in milliseconds from the exchange server
         * @param {dict} $params extra parameters specific to the mexc3 api endpoint
         * @return {int} the current integer timestamp in milliseconds from the exchange server
         */
        list($marketType, $query) = $this->handle_market_type_and_params('fetchTime', null, $params);
        $response = null;
        if ($marketType === 'spot') {
            $response = $this->spotPublicGetTime ($query);
            //
            //     array("serverTime" => "1647519277579")
            //
            return $this->safe_integer($response, 'serverTime');
        } elseif ($marketType === 'swap') {
            $response = $this->contractPublicGetPing ($query);
            //
            //     array("success":true,"code":"0","data":"1648124374985")
            //
            return $this->safe_integer($response, 'data');
        }
    }

    public function fetch_currencies($params = array ()) {
        /**
         * fetches all available currencies on an exchange
         * @param {dict} $params extra parameters specific to the mexc3 api endpoint
         * @return {dict} an associative dictionary of currencies
         */
        $response = $this->spot2PublicGetMarketCoinList ($params);
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             {
        //                 "currency":"AGLD",
        //                 "coins":array(
        //                     array(
        //                         "chain":"ERC20",
        //                         "precision":18,
        //                         "fee":8.09,
        //                         "is_withdraw_enabled":true,
        //                         "is_deposit_enabled":true,
        //                         "deposit_min_confirm":16,
        //                         "withdraw_limit_max":500000.0,
        //                         "withdraw_limit_min":14.0
        //                     }
        //                 ),
        //                 "full_name":"Adventure Gold"
        //             ),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $currency = $data[$i];
            $id = $this->safe_string($currency, 'currency');
            $code = $this->safe_currency_code($id);
            $name = $this->safe_string($currency, 'full_name');
            $currencyActive = false;
            $currencyPrecision = null;
            $currencyFee = null;
            $currencyWithdrawMin = null;
            $currencyWithdrawMax = null;
            $networks = array();
            $chains = $this->safe_value($currency, 'coins', array());
            $depositEnabled = false;
            $withdrawEnabled = false;
            for ($j = 0; $j < count($chains); $j++) {
                $chain = $chains[$j];
                $networkId = $this->safe_string($chain, 'chain');
                $network = $this->safe_network($networkId);
                $isDepositEnabled = $this->safe_value($chain, 'is_deposit_enabled', false);
                $isWithdrawEnabled = $this->safe_value($chain, 'is_withdraw_enabled', false);
                $active = ($isDepositEnabled && $isWithdrawEnabled);
                $currencyActive = $active || $currencyActive;
                $precisionDigits = $this->safe_integer($chain, 'precision');
                $precision = 1 / pow(10, $precisionDigits);
                $withdrawMin = $this->safe_string($chain, 'withdraw_limit_min');
                $withdrawMax = $this->safe_string($chain, 'withdraw_limit_max');
                $currencyWithdrawMin = ($currencyWithdrawMin === null) ? $withdrawMin : $currencyWithdrawMin;
                $currencyWithdrawMax = ($currencyWithdrawMax === null) ? $withdrawMax : $currencyWithdrawMax;
                if (Precise::string_gt($currencyWithdrawMin, $withdrawMin)) {
                    $currencyWithdrawMin = $withdrawMin;
                }
                if (Precise::string_lt($currencyWithdrawMax, $withdrawMax)) {
                    $currencyWithdrawMax = $withdrawMax;
                }
                if ($isDepositEnabled) {
                    $depositEnabled = true;
                }
                if ($isWithdrawEnabled) {
                    $withdrawEnabled = true;
                }
                $networks[$network] = array(
                    'info' => $chain,
                    'id' => $networkId,
                    'network' => $network,
                    'active' => $active,
                    'deposit' => $isDepositEnabled,
                    'withdraw' => $isWithdrawEnabled,
                    'fee' => $this->safe_number($chain, 'fee'),
                    'precision' => $precision,
                    'limits' => array(
                        'withdraw' => array(
                            'min' => $withdrawMin,
                            'max' => $withdrawMax,
                        ),
                    ),
                );
            }
            $networkKeys = is_array($networks) ? array_keys($networks) : array();
            $networkKeysLength = is_array($networkKeys) ? count($networkKeys) : 0;
            if (($networkKeysLength === 1) || (is_array($networks) && array_key_exists('NONE', $networks))) {
                $defaultNetwork = $this->safe_value_2($networks, 'NONE', $networkKeysLength - 1);
                if ($defaultNetwork !== null) {
                    $currencyFee = $defaultNetwork['fee'];
                    $currencyPrecision = $defaultNetwork['precision'];
                }
            }
            $result[$code] = array(
                'id' => $id,
                'code' => $code,
                'info' => $currency,
                'name' => $name,
                'active' => $currencyActive,
                'deposit' => $depositEnabled,
                'withdraw' => $withdrawEnabled,
                'fee' => $currencyFee,
                'precision' => $currencyPrecision,
                'limits' => array(
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'withdraw' => array(
                        'min' => $currencyWithdrawMin,
                        'max' => $currencyWithdrawMax,
                    ),
                ),
                'networks' => $networks,
            );
        }
        return $result;
    }

    public function safe_network($networkId) {
        if (mb_strpos($networkId, 'BSC') !== false) {
            return 'BEP20';
        }
        $parts = explode(' ', $networkId);
        $networkId = implode('', $parts);
        $networkId = str_replace('-20', '20', $networkId);
        $networksById = array(
            'ETH' => 'ETH',
            'ERC20' => 'ERC20',
            'BEP20(BSC)' => 'BEP20',
            'TRX' => 'TRC20',
        );
        return $this->safe_string($networksById, $networkId, $networkId);
    }

    public function fetch_markets($params = array ()) {
        /**
         * retrieves data on all markets for mexc3
         * @param {dict} $params extra parameters specific to the exchange api endpoint
         * @return {[dict]} an array of objects representing market data
         */
        $spotMarket = $this->fetch_spot_markets($params);
        $swapMarket = $this->fetch_swap_markets($params);
        return $this->array_concat($spotMarket, $swapMarket);
    }

    public function fetch_spot_markets($params = array ()) {
        $response = $this->spotPublicGetExchangeInfo ($params);
        //
        //     {
        //         "timezone" => "CST",
        //         "serverTime" => 1647521860402,
        //         "rateLimits" => array(),
        //         "exchangeFilters" => array(),
        //         "symbols" => array(
        //           array(
        //             "symbol" => "BTCUSDT",
        //             "status" => "ENABLED",
        //             "baseAsset" => "BTC",
        //             "baseAssetPrecision" => 6,
        //             "quoteAsset" => "USDT",
        //             "quotePrecision" => 2,
        //             "quoteAssetPrecision" => 2,
        //             "baseCommissionPrecision" => 6,
        //             "quoteCommissionPrecision" => 2,
        //             "orderTypes" => array(
        //               "LIMIT",
        //               "LIMIT_MAKER"
        //             ),
        //             "icebergAllowed" => false,
        //             "ocoAllowed" => false,
        //             "quoteOrderQtyMarketAllowed" => false,
        //             "isSpotTradingAllowed" => true,
        //             "isMarginTradingAllowed" => false,
        //             "permissions" => array(
        //               "SPOT"
        //             ),
        //             "filters" => array()
        //           ),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'symbols', array());
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $market = $data[$i];
            $id = $this->safe_string($market, 'symbol');
            $baseId = $this->safe_string($market, 'baseAsset');
            $quoteId = $this->safe_string($market, 'quoteAsset');
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $status = $this->safe_string($market, 'status');
            $result[] = array(
                'id' => $id,
                'symbol' => $base . '/' . $quote,
                'base' => $base,
                'quote' => $quote,
                'settle' => null,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'settleId' => null,
                'type' => 'spot',
                'spot' => true,
                'margin' => false,
                'swap' => false,
                'future' => false,
                'option' => false,
                'active' => ($status === 'ENABLED'),
                'contract' => false,
                'linear' => null,
                'inverse' => null,
                'taker' => null,
                'maker' => null,
                'contractSize' => null,
                'expiry' => null,
                'expiryDatetime' => null,
                'strike' => null,
                'optionType' => null,
                'precision' => array(
                    'amount' => $this->safe_integer($market, 'baseAssetPrecision'),
                    'price' => $this->safe_integer($market, 'quotePrecision'),
                    'base' => $this->safe_integer($market, 'baseAssetPrecision'),
                    'quote' => $this->safe_integer($market, 'quoteAssetPrecision'),
                ),
                'limits' => array(
                    'leverage' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'price' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
                'info' => $market,
            );
        }
        return $result;
    }

    public function fetch_swap_markets($params = array ()) {
        $response = $this->contractPublicGetDetail ($params);
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":[
        //             array(
        //                 "symbol":"BTC_USDT",
        //                 "displayName":"BTC_USDT永续",
        //                 "displayNameEn":"BTC_USDT SWAP",
        //                 "positionOpenType":3,
        //                 "baseCoin":"BTC",
        //                 "quoteCoin":"USDT",
        //                 "settleCoin":"USDT",
        //                 "contractSize":0.0001,
        //                 "minLeverage":1,
        //                 "maxLeverage":125,
        //                 "priceScale":2,
        //                 "volScale":0,
        //                 "amountScale":4,
        //                 "priceUnit":0.5,
        //                 "volUnit":1,
        //                 "minVol":1,
        //                 "maxVol":1000000,
        //                 "bidLimitPriceRate":0.1,
        //                 "askLimitPriceRate":0.1,
        //                 "takerFeeRate":0.0006,
        //                 "makerFeeRate":0.0002,
        //                 "maintenanceMarginRate":0.004,
        //                 "initialMarginRate":0.008,
        //                 "riskBaseVol":10000,
        //                 "riskIncrVol":200000,
        //                 "riskIncrMmr":0.004,
        //                 "riskIncrImr":0.004,
        //                 "riskLevelLimit":5,
        //                 "priceCoefficientVariation":0.1,
        //                 "indexOrigin":["BINANCE","GATEIO","HUOBI","MXC"],
        //                 "state":0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
        //                 "isNew":false,
        //                 "isHot":true,
        //                 "isHidden":false
        //             ),
        //         ]
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $market = $data[$i];
            $id = $this->safe_string($market, 'symbol');
            $baseId = $this->safe_string($market, 'baseCoin');
            $quoteId = $this->safe_string($market, 'quoteCoin');
            $settleId = $this->safe_string($market, 'settleCoin');
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $settle = $this->safe_currency_code($settleId);
            $state = $this->safe_string($market, 'state');
            $result[] = array(
                'id' => $id,
                'symbol' => $base . '/' . $quote . ':' . $settle,
                'base' => $base,
                'quote' => $quote,
                'settle' => $settle,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'settleId' => $settleId,
                'type' => 'swap',
                'spot' => false,
                'margin' => false,
                'swap' => true,
                'future' => false,
                'option' => false,
                'active' => ($state === '0'),
                'contract' => true,
                'linear' => true,
                'inverse' => false,
                'taker' => $this->safe_number($market, 'takerFeeRate'),
                'maker' => $this->safe_number($market, 'makerFeeRate'),
                'contractSize' => $this->safe_number($market, 'contractSize'),
                'expiry' => null,
                'expiryDatetime' => null,
                'strike' => null,
                'optionType' => null,
                'precision' => array(
                    'amount' => $this->safe_number($market, 'volUnit'),
                    'price' => $this->safe_number($market, 'priceUnit'),
                ),
                'limits' => array(
                    'leverage' => array(
                        'min' => $this->safe_number($market, 'minLeverage'),
                        'max' => $this->safe_number($market, 'maxLeverage'),
                    ),
                    'amount' => array(
                        'min' => $this->safe_number($market, 'minVol'),
                        'max' => $this->safe_number($market, 'maxVol'),
                    ),
                    'price' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
                'info' => $market,
            );
        }
        return $result;
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        /**
         * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other $data
         * @param {str} $symbol unified $symbol of the $market to fetch the order book for
         * @param {int|null} $limit the maximum amount of order book entries to return
         * @param {dict} $params extra parameters specific to the mexc3 api endpoint
         * @return {dict} A dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure order book structures} indexed by $market symbols
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $orderbook = null;
        if ($market['spot']) {
            $response = $this->spotPublicGetDepth (array_merge($request, $params));
            //
            //     {
            //         "lastUpdateId" => "744267132",
            //         "bids" => [
            //             ["40838.50","0.387864"],
            //             ["40837.95","0.008400"],
            //         ],
            //         "asks" => [
            //             ["40838.61","6.544908"],
            //             ["40838.88","0.498000"],
            //         ]
            //     }
            //
            $orderbook = $this->parse_order_book($response, $symbol);
            $orderbook['nonce'] = $this->safe_integer($response, 'lastUpdateId');
        } elseif ($market['swap']) {
            $response = $this->contractPublicGetDepthSymbol (array_merge($request, $params));
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":{
            //             "asks":[
            //                 [3445.72,48379,1],
            //                 [3445.75,34994,1],
            //             ],
            //             "bids":[
            //                 [3445.55,44081,1],
            //                 [3445.51,24857,1],
            //             ],
            //             "version":2827730444,
            //             "timestamp":1634117846232
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data');
            $timestamp = $this->safe_integer($data, 'timestamp');
            $orderbook = $this->parse_order_book($data, $symbol, $timestamp);
            $orderbook['nonce'] = $this->safe_integer($data, 'version');
        }
        return $orderbook;
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        /**
         * get the list of most recent $trades for a particular $symbol
         * @param {str} $symbol unified $symbol of the $market to fetch $trades for
         * @param {int|null} $since timestamp in ms of the earliest trade to fetch
         * @param {int|null} $limit the maximum amount of $trades to fetch
         * @param {dict} $params extra parameters specific to the mexc3 api endpoint
         * @return {[dict]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades trade structures~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        // if ($since !== null) {
        //     $request['startTime'] = $since; bug in api, waiting for fix
        // }
        $trades = null;
        if ($market['spot']) {
            $method = $this->safe_string($this->options, 'fetchTradesMethod', 'spotPublicGetAggTrades');
            $method = $this->safe_string($params, 'method', $method); // AggTrades, HistoricalTrades, Trades
            $trades = $this->$method (array_merge($request, $params));
            //
            //     /trades, /historicalTrades
            //
            //     array(
            //         array(
            //             "id" => null,
            //             "price" => "40798.94",
            //             "qty" => "0.000508",
            //             "quoteQty" => "20.72586152",
            //             "time" => "1647546934374",
            //             "isBuyerMaker" => true,
            //             "isBestMatch" => true
            //         ),
            //     )
            //
            //     /aggrTrades
            //
            //     array(
            //         array(
            //           "a" => null,
            //           "f" => null,
            //           "l" => null,
            //           "p" => "40679",
            //           "q" => "0.001309",
            //           "T" => 1647551328000,
            //           "m" => true,
            //           "M" => true
            //         ),
            //     )
            //
        } elseif ($market['swap']) {
            $response = $this->contractPublicGetDealsSymbol (array_merge($request, $params));
            //
            //     {
            //         "success" => true,
            //         "code" => 0,
            //         "data" => array(
            //             array(
            //                 "p" => 31199,
            //                 "v" => 18,
            //                 "T" => 1,
            //                 "O" => 3,
            //                 "M" => 2,
            //                 "t" => 1609831235985
            //             ),
            //         )
            //     }
            //
            $trades = $this->safe_value($response, 'data');
        }
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function parse_trade($trade, $market = null) {
        $id = null;
        $timestamp = null;
        $orderId = null;
        $symbol = null;
        $fee = null;
        $type = null;
        $side = null;
        $takerOrMaker = null;
        $priceString = null;
        $amountString = null;
        $costString = null;
        // if swap
        if (is_array($trade) && array_key_exists('v', $trade)) {
            //
            // swap => fetchTrades
            //
            //     {
            //         "p" => 31199,
            //         "v" => 18,
            //         "T" => 1,
            //         "O" => 3,
            //         "M" => 2,
            //         "t" => 1609831235985
            //     }
            //
            $timestamp = $this->safe_integer($trade, 't');
            $market = $this->safe_market(null, $market);
            $symbol = $market['symbol'];
            $priceString = $this->safe_string($trade, 'p');
            $amountString = $this->safe_string($trade, 'v');
            $side = $this->parse_order_side($this->safe_string($trade, 'T'));
            $takerOrMaker = 'taker';
        } else {
            //
            // spot => fetchTrades (for aggTrades)
            //
            //         {
            //             "a" => null,
            //             "f" => null,
            //             "l" => null,
            //             "p" => "40679",
            //             "q" => "0.001309",
            //             "T" => 1647551328000,
            //             "m" => true,
            //             "M" => true
            //         }
            //
            // spot => fetchMyTrades, fetchOrderTrades
            //
            //         {
            //             "symbol" => "BTCUSDT",
            //             "id" => "133948532984922113",
            //             "orderId" => "133948532531949568",
            //             "orderListId" => "-1",
            //             "price" => "41995.51",
            //             "qty" => "0.0002",
            //             "quoteQty" => "8.399102",
            //             "commission" => "0.016798204",
            //             "commissionAsset" => "USDT",
            //             "time" => "1647718055000",
            //             "isBuyer" => true,
            //             "isMaker" => false,
            //             "isBestMatch" => true
            //         }
            //
            // swap => fetchMyTrades, fetchOrderTrades
            //
            //         {
            //             "id" => "299444585",
            //             "symbol" => "STEPN_USDT",
            //             "side" => "1",
            //             "vol" => "1",
            //             "price" => "2.45455",
            //             "feeCurrency" => "USDT",
            //             "fee" => "0.00147273",
            //             "timestamp" => "1648924557000",
            //             "profit" => "0",
            //             "category" => "1",
            //             "orderId" => "265307163526610432",
            //             "positionMode" => "1",
            //             "taker" => true
            //         }
            //
            $marketId = $this->safe_string($trade, 'symbol');
            $market = $this->safe_market($marketId, $market);
            $symbol = $market['symbol'];
            $id = $this->safe_string_2($trade, 'id', 'a');
            $priceString = $this->safe_string_2($trade, 'price', 'p');
            $orderId = $this->safe_string($trade, 'orderId');
            // if swap
            if (is_array($trade) && array_key_exists('positionMode', $trade)) {
                $timestamp = $this->safe_integer($trade, 'timestamp');
                $amountString = $this->safe_string($trade, 'vol');
                $side = $this->parse_order_side($this->safe_string($trade, 'side'));
                $fee = array(
                    'cost' => $this->safe_number($trade, 'fee'),
                    'currency' => $this->safe_currency_code($this->safe_string($trade, 'feeCurrency')),
                );
                $takerOrMaker = $this->safe_value($trade, 'taker') ? 'taker' : 'maker';
            } else {
                $timestamp = $this->safe_integer_2($trade, 'time', 'T');
                $amountString = $this->safe_string_2($trade, 'qty', 'q');
                $costString = $this->safe_string($trade, 'quoteQty');
                $isBuyer = $this->safe_value($trade, 'isBuyer');
                $isMaker = $this->safe_value($trade, 'isMaker');
                $buyerMaker = $this->safe_string_2($trade, 'isBuyerMaker', 'm');
                if ($isMaker !== null) {
                    $takerOrMaker = $isMaker ? 'maker' : 'taker';
                }
                if ($isBuyer !== null) {
                    $side = $isBuyer ? 'buy' : 'sell';
                }
                if ($buyerMaker !== null) {
                    $side = $buyerMaker ? 'sell' : 'buy';
                    $takerOrMaker = 'taker';
                }
                $feeAsset = $this->safe_string($trade, 'commissionAsset');
                if ($feeAsset !== null) {
                    $fee = array(
                        'cost' => $this->safe_number($trade, 'commission'),
                        'currency' => $this->safe_currency_code($feeAsset),
                    );
                }
            }
        }
        if ($id === null) {
            $id = $this->synthetic_trade_id($market, $timestamp, $side, $amountString, $priceString, $type, $takerOrMaker);
        }
        return $this->safe_trade(array(
            'id' => $id,
            'order' => $orderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'type' => $type,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => $costString,
            'fee' => $fee,
            'info' => $trade,
        ), $market);
    }

    public function synthetic_trade_id($market = null, $timestamp = null, $side = null, $amount = null, $price = null, $orderType = null, $takerOrMaker = null) {
        // TODO => can be unified method? this approach is being used by multiple exchanges (mexc, woo-coinsbit, dydx, ...)
        $id = '';
        if ($timestamp !== null) {
            $id = $this->number_to_string($timestamp) . '-' . $this->safe_string($market, 'id', '_');
            if ($side !== null) {
                $id .= '-' . $side;
            }
            if ($amount !== null) {
                $id .= '-' . $this->number_to_string($amount);
            }
            if ($price !== null) {
                $id .= '-' . $this->number_to_string($price);
            }
            if ($takerOrMaker !== null) {
                $id .= '-' . $takerOrMaker;
            }
            if ($orderType !== null) {
                $id .= '-' . $orderType;
            }
        }
        return $id;
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        /**
         * fetches historical candlestick $data containing the open, high, low, and close price, and the volume of a $market
         * @param {str} $symbol unified $symbol of the $market to fetch OHLCV $data for
         * @param {str} $timeframe the length of time each candle represents
         * @param {int|null} $since timestamp in ms of the earliest candle to fetch
         * @param {int|null} $limit the maximum amount of $candles to fetch
         * @param {dict} $params extra parameters specific to the mexc3 api endpoint
         * @return {[[int]]} A list of $candles ordered as timestamp, open, high, low, close, volume
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $options = $this->safe_value($this->options, 'timeframes', array());
        $timeframes = $this->safe_value($options, $market['type'], array());
        $timeframeValue = $this->safe_string($timeframes, $timeframe);
        $request = array(
            'symbol' => $market['id'],
            'interval' => $timeframeValue,
        );
        $candles = null;
        if ($market['spot']) {
            if ($since !== null) {
                $request['startTime'] = $since;
            }
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = $this->spotPublicGetKlines (array_merge($request, $params));
            //
            //     array(
            //       array(
            //         1640804880000,
            //         "47482.36",
            //         "47482.36",
            //         "47416.57",
            //         "47436.1",
            //         "3.550717",
            //         1640804940000,
            //         "168387.3"
            //       ),
            //     )
            //
            $candles = $response;
        } elseif ($market['swap']) {
            if ($since !== null) {
                $request['start'] = intval($since / 1000);
            }
            $priceType = $this->safe_string($params, 'price', 'default');
            $params = $this->omit($params, 'price');
            $method = $this->get_supported_mapping($priceType, array(
                'default' => 'contractPublicGetKlineSymbol',
                'index' => 'contractPublicGetKlineIndexPriceSymbol',
                'mark' => 'contractPublicGetKlineFairPriceSymbol',
            ));
            $response = $this->$method (array_merge($request, $params));
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":{
            //             "time":[1634052300,1634052360,1634052420],
            //             "open":[3492.2,3491.3,3495.65],
            //             "close":[3491.3,3495.65,3495.2],
            //             "high":[3495.85,3496.55,3499.4],
            //             "low":[3491.15,3490.9,3494.2],
            //             "vol":[1740.0,351.0,314.0],
            //             "amount":[60793.623,12260.4885,10983.1375],
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data');
            $candles = $this->convert_trading_view_to_ohlcv($data, 'time', 'open', 'high', 'low', 'close', 'vol');
        }
        return $this->parse_ohlcvs($candles, $market, $timeframe, $since, $limit);
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        return array(
            $this->safe_integer($ohlcv, 0),
            $this->safe_number($ohlcv, 1),
            $this->safe_number($ohlcv, 2),
            $this->safe_number($ohlcv, 3),
            $this->safe_number($ohlcv, 4),
            $this->safe_number($ohlcv, 5),
        );
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        /**
         * fetches price $tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each $market
         * @param {[str]|null} $symbols unified $symbols of the markets to fetch the ticker for, all $market $tickers are returned if not assigned
         * @param {dict} $params extra parameters specific to the mexc3 api endpoint
         * @return {dict} an array of {@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structures}
         */
        $this->load_markets();
        $request = array();
        $market = null;
        $isSingularMarket = false;
        if ($symbols !== null) {
            $length = is_array($symbols) ? count($symbols) : 0;
            $isSingularMarket = $length === 1;
            $firstSymbol = $this->safe_string($symbols, 0);
            $market = $this->market($firstSymbol);
        }
        list($marketType, $query) = $this->handle_market_type_and_params('fetchTickers', $market, $params);
        $tickers = null;
        if ($isSingularMarket) {
            $request['symbol'] = $market['id'];
        }
        if ($marketType === 'spot') {
            $tickers = $this->spotPublicGetTicker24hr (array_merge($request, $query));
            //
            //     array(
            //         {
            //             "symbol" => "BTCUSDT",
            //             "priceChange" => "184.34",
            //             "priceChangePercent" => "0.00400048",
            //             "prevClosePrice" => "46079.37",
            //             "lastPrice" => "46263.71",
            //             "lastQty" => "",
            //             "bidPrice" => "46260.38",
            //             "bidQty" => "",
            //             "askPrice" => "46260.41",
            //             "askQty" => "",
            //             "openPrice" => "46079.37",
            //             "highPrice" => "47550.01",
            //             "lowPrice" => "45555.5",
            //             "volume" => "1732.461487",
            //             "quoteVolume" => null,
            //             "openTime" => 1641349500000,
            //             "closeTime" => 1641349582808,
            //             "count" => null
            //         }
            //     )
            //
        } elseif ($marketType === 'swap') {
            $response = $this->contractPublicGetTicker (array_merge($request, $query));
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":array(
            //             array(
            //                 "symbol":"ETH_USDT",
            //                 "lastPrice":3581.3,
            //                 "bid1":3581.25,
            //                 "ask1":3581.5,
            //                 "volume24":4045530,
            //                 "amount24":141331823.5755,
            //                 "holdVol":5832946,
            //                 "lower24Price":3413.4,
            //                 "high24Price":3588.7,
            //                 "riseFallRate":0.0275,
            //                 "riseFallValue":95.95,
            //                 "indexPrice":3580.7852,
            //                 "fairPrice":3581.08,
            //                 "fundingRate":0.000063,
            //                 "maxBidPrice":3938.85,
            //                 "minAskPrice":3222.7,
            //                 "timestamp":1634162885016
            //             ),
            //         )
            //     }
            //
            $tickers = $this->safe_value($response, 'data', array());
        }
        // when it's single symbol $request, the returned structure is different (singular object) for both spot & swap, thus we need to wrap inside array
        if ($isSingularMarket) {
            $tickers = array( $tickers );
        }
        return $this->parse_tickers($tickers, $symbols);
    }

    public function fetch_ticker($symbol, $params = array ()) {
        /**
         * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
         * @param {str} $symbol unified $symbol of the $market to fetch the $ticker for
         * @param {dict} $params extra parameters specific to the mexc3 api endpoint
         * @return {dict} a {@link https://docs.ccxt.com/en/latest/manual.html#$ticker-structure $ticker structure}
         */
        $this->load_markets();
        $market = $this->market($symbol);
        list($marketType, $query) = $this->handle_market_type_and_params('fetchTicker', $market, $params);
        $ticker = null;
        $request = array(
            'symbol' => $market['id'],
        );
        if ($marketType === 'spot') {
            $ticker = $this->spotPublicGetTicker24hr (array_merge($request, $query));
            //
            //     {
            //         "symbol" => "BTCUSDT",
            //         "priceChange" => "184.34",
            //         "priceChangePercent" => "0.00400048",
            //         "prevClosePrice" => "46079.37",
            //         "lastPrice" => "46263.71",
            //         "lastQty" => "",
            //         "bidPrice" => "46260.38",
            //         "bidQty" => "",
            //         "askPrice" => "46260.41",
            //         "askQty" => "",
            //         "openPrice" => "46079.37",
            //         "highPrice" => "47550.01",
            //         "lowPrice" => "45555.5",
            //         "volume" => "1732.461487",
            //         "quoteVolume" => null,
            //         "openTime" => 1641349500000,
            //         "closeTime" => 1641349582808,
            //         "count" => null
            //     }
            //
        } elseif ($marketType === 'swap') {
            $response = $this->contractPublicGetTicker (array_merge($request, $query));
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":{
            //             "symbol":"ETH_USDT",
            //             "lastPrice":3581.3,
            //             "bid1":3581.25,
            //             "ask1":3581.5,
            //             "volume24":4045530,
            //             "amount24":141331823.5755,
            //             "holdVol":5832946,
            //             "lower24Price":3413.4,
            //             "high24Price":3588.7,
            //             "riseFallRate":0.0275,
            //             "riseFallValue":95.95,
            //             "indexPrice":3580.7852,
            //             "fairPrice":3581.08,
            //             "fundingRate":0.000063,
            //             "maxBidPrice":3938.85,
            //             "minAskPrice":3222.7,
            //             "timestamp":1634162885016
            //         }
            //     }
            //
            $ticker = $this->safe_value($response, 'data', array());
        }
        // when it's single $symbol $request, the returned structure is different (singular object) for both spot & swap, thus we need to wrap inside array
        return $this->parse_ticker($ticker, $symbol);
    }

    public function parse_ticker($ticker, $market = null) {
        $marketId = $this->safe_string($ticker, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $timestamp = null;
        $bid = null;
        $ask = null;
        $bidVolume = null;
        $askVolume = null;
        $baseVolume = null;
        $quoteVolume = null;
        $open = null;
        $high = null;
        $low = null;
        $changePcnt = null;
        $changeValue = null;
        $prevClose = null;
        $isSwap = $this->safe_value($market, 'swap');
        // if swap
        if ($isSwap || (is_array($ticker) && array_key_exists('timestamp', $ticker))) {
            //
            //     {
            //         "symbol":"ETH_USDT",
            //         "lastPrice":3581.3,
            //         "bid1":3581.25,
            //         "ask1":3581.5,
            //         "volume24":4045530,
            //         "amount24":141331823.5755,
            //         "holdVol":5832946,
            //         "lower24Price":3413.4,
            //         "high24Price":3588.7,
            //         "riseFallRate":0.0275,
            //         "riseFallValue":95.95,
            //         "indexPrice":3580.7852,
            //         "fairPrice":3581.08,
            //         "fundingRate":0.000063,
            //         "maxBidPrice":3938.85,
            //         "minAskPrice":3222.7,
            //         "timestamp":1634162885016
            //     }
            //
            $timestamp = $this->safe_integer($ticker, 'timestamp');
            $bid = $this->safe_number($ticker, 'bid1');
            $ask = $this->safe_number($ticker, 'ask1');
            $baseVolume = $this->safe_string($ticker, 'volume24');
            $quoteVolume = $this->safe_string($ticker, 'amount24');
            $high = $this->safe_number($ticker, 'high24Price');
            $low = $this->safe_number($ticker, 'lower24Price');
            $changeValue = $this->safe_string($ticker, 'riseFallValue');
            $changePcnt = $this->safe_string($ticker, 'riseFallRate');
            $changePcnt = $this->parse_number(Precise::string_mul($changePcnt, '100'));
        } else {
            //
            //     {
            //         "symbol" => "BTCUSDT",
            //         "priceChange" => "184.34",
            //         "priceChangePercent" => "0.00400048",
            //         "prevClosePrice" => "46079.37",
            //         "lastPrice" => "46263.71",
            //         "lastQty" => "",
            //         "bidPrice" => "46260.38",
            //         "bidQty" => "",
            //         "askPrice" => "46260.41",
            //         "askQty" => "",
            //         "openPrice" => "46079.37",
            //         "highPrice" => "47550.01",
            //         "lowPrice" => "45555.5",
            //         "volume" => "1732.461487",
            //         "quoteVolume" => null,
            //         "openTime" => 1641349500000,
            //         "closeTime" => 1641349582808,
            //         "count" => null
            //     }
            //
            $timestamp = $this->safe_integer($ticker, 'closeTime');
            $bid = $this->safe_number($ticker, 'bidPrice');
            $ask = $this->safe_number($ticker, 'askPrice');
            $bidVolume = $this->safe_number($ticker, 'bidQty');
            $askVolume = $this->safe_number($ticker, 'askQty');
            if ($bidVolume === 0) {
                $bidVolume = null;
            }
            if ($askVolume === 0) {
                $askVolume = null;
            }
            $baseVolume = $this->safe_string($ticker, 'volume');
            $quoteVolume = $this->safe_string($ticker, 'quoteVolume');
            $open = $this->safe_string($ticker, 'openPrice');
            $high = $this->safe_number($ticker, 'highPrice');
            $low = $this->safe_number($ticker, 'lowPrice');
            $prevClose = $this->safe_string($ticker, 'prevClosePrice');
            $changeValue = $this->safe_string($ticker, 'priceChange');
            $changePcnt = $this->safe_string($ticker, 'priceChangePercent');
            $changePcnt = $this->parse_number(Precise::string_mul($changePcnt, '100'));
        }
        return $this->safe_ticker(array(
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'open' => $open,
            'high' => $high,
            'low' => $low,
            'close' => $this->safe_string($ticker, 'lastPrice'),
            'bid' => $bid,
            'bidVolume' => $bidVolume,
            'ask' => $ask,
            'askVolume' => $askVolume,
            'vwap' => null,
            'previousClose' => $prevClose,
            'change' => $changeValue,
            'percentage' => $changePcnt,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_bids_asks($symbols = null, $params = array ()) {
        /**
         * fetches the bid and ask price and volume for multiple markets
         * @param {[str]|null} $symbols unified $symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
         * @param {dict} $params extra parameters specific to the mexc3 api endpoint
         * @return {dict} an array of {@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structures}
         */
        $this->load_markets();
        $market = null;
        $isSingularMarket = false;
        if ($symbols !== null) {
            $length = is_array($symbols) ? count($symbols) : 0;
            $isSingularMarket = $length === 1;
            $market = $this->market($symbols[0]);
        }
        list($marketType, $query) = $this->handle_market_type_and_params('fetchBidsAsks', $market, $params);
        $tickers = null;
        if ($marketType === 'spot') {
            $tickers = $this->spotPublicGetTickerBookTicker ($query);
            //
            //     array(
            //       array(
            //         "symbol" => "AEUSDT",
            //         "bidPrice" => "0.11001",
            //         "bidQty" => "115.59",
            //         "askPrice" => "0.11127",
            //         "askQty" => "215.48"
            //       ),
            //     )
            //
        } elseif ($marketType === 'swap') {
            throw new NotSupported($this->id . ' fetchBidsAsks() is not available for ' . $marketType . ' markets');
        }
        // when it's single symbol request, the returned structure is different (singular object) for both spot & swap, thus we need to wrap inside array
        if ($isSingularMarket) {
            $tickers = array( $tickers );
        }
        return $this->parse_tickers($tickers, $symbols);
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        if ($market['spot']) {
            return $this->create_spot_order($market, $type, $side, $amount, $price, $params);
        } elseif ($market['swap']) {
            return $this->create_swap_order($market, $type, $side, $amount, $price, $params);
        }
    }

    public function create_spot_order($market, $type, $side, $amount, $price = null, $params = array ()) {
        $symbol = $market['symbol'];
        $orderSide = ($side === 'buy') ? 'BUY' : 'SELL';
        $request = array(
            'symbol' => $market['id'],
            'side' => $orderSide,
            'type' => strtoupper($type),
        );
        if ($orderSide === 'BUY' && $type === 'market') {
            $quoteOrderQty = $this->safe_number($params, 'quoteOrderQty');
            if ($quoteOrderQty !== null) {
                $amount = $quoteOrderQty;
            } elseif ($this->options['createMarketBuyOrderRequiresPrice']) {
                if ($price === null) {
                    throw new InvalidOrder($this->id . " createOrder() requires the $price argument with $market buy orders to calculate total order cost ($amount to spend), where cost = $amount * $price-> Supply a $price argument to createOrder() call if you want the cost to be calculated for you from $price and $amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the $amount argument (the exchange-specific behaviour)");
                } else {
                    $amount = $amount * $price;
                }
            }
            $request['quoteOrderQty'] = $amount;
        } else {
            $request['quantity'] = $this->amount_to_precision($symbol, $amount);
        }
        if ($price !== null) {
            $request['price'] = $this->price_to_precision($symbol, $price);
        }
        $clientOrderId = $this->safe_string($params, 'clientOrderId');
        if ($clientOrderId !== null) {
            $request['newClientOrderId'] = $clientOrderId;
            $params = $this->omit($params, array( 'type', 'clientOrderId' ));
        }
        $response = $this->spotPrivatePostOrder (array_merge($request, $params));
        //
        // spot
        //
        //     {
        //         "symbol" => "BTCUSDT",
        //         "orderId" => "123738410679123456",
        //         "orderListId" => -1
        //     }
        //
        return array_merge($this->parse_order($response, $market), array(
            'side' => $side,
            'type' => $type,
            'price' => $price,
            'amount' => $amount,
        ));
    }

    public function create_swap_order($market, $type, $side, $amount, $price = null, $params = array ()) {
        $this->load_markets();
        $symbol = $market['symbol'];
        $unavailableContracts = $this->safe_value($this->options, 'unavailableContracts', array());
        $isContractUnavaiable = $this->safe_value($unavailableContracts, $symbol, false);
        if ($isContractUnavaiable) {
            throw new NotSupported($this->id . ' createSwapOrder() does not support yet this $symbol:' . $symbol);
        }
        $openType = null;
        $marginType = $this->safe_string_lower($params, 'margin');
        if ($marginType !== null) {
            if ($marginType === 'cross') {
                $openType = 2;
            } elseif ($marginType === 'isolated') {
                $openType = 1;
            } else {
                throw new ArgumentsRequired($this->id . ' createSwapOrder() margin parameter should be either "cross" or "isolated"');
            }
        } else {
            $openType = $this->safe_integer($params, 'openType', 2); // defaulting to cross margin
        }
        if (($type !== 'limit') && ($type !== 'market') && ($type !== 1) && ($type !== 2) && ($type !== 3) && ($type !== 4) && ($type !== 5) && ($type !== 6)) {
            throw new InvalidOrder($this->id . ' createSwapOrder() order $type must either limit, $market, or 1 for limit orders, 2 for post-only orders, 3 for IOC orders, 4 for FOK orders, 5 for $market orders or 6 to convert $market $price to current price');
        }
        $postOnly = $this->safe_value($params, 'postOnly', false);
        if ($postOnly) {
            $type = 2;
        } elseif ($type === 'limit') {
            $type = 1;
        } elseif ($type === 'market') {
            $type = 6;
        }
        // TODO => $side not unified
        if (($side !== 1) && ($side !== 2) && ($side !== 3) && ($side !== 4)) {
            throw new InvalidOrder($this->id . ' createSwapOrder() order $side must be 1 open long, 2 close short, 3 open short or 4 close long');
        }
        $request = array(
            'symbol' => $market['id'],
            // 'price' => floatval($this->price_to_precision($symbol, $price)),
            'vol' => floatval($this->amount_to_precision($symbol, $amount)),
            // 'leverage' => int, // required for isolated margin
            'side' => $side, // 1 open long, 2 close short, 3 open short, 4 close long
            //
            // supported order types
            //
            //     1 limit
            //     2 post only maker (PO)
            //     3 transact or cancel instantly (IOC)
            //     4 transact completely or cancel completely (FOK)
            //     5 $market orders
            //     6 convert $market $price to current $price
            //
            'type' => $type,
            'openType' => $openType, // 1 isolated, 2 cross
            // 'positionId' => 1394650, // long, filling in this parameter when closing a position is recommended
            // 'externalOid' => $clientOrderId,
            // 'triggerPrice' => 10.0, // Required for trigger order
            // 'triggerType' => 1, // Required for trigger order 1 => more than or equal, 2 => less than or equal
            // 'executeCycle' => 1, // Required for trigger order 1 => 24 hours,2 => 7 days
            // 'trend' => 1, // Required for trigger order 1 => latest $price, 2 => fair $price, 3 => index $price
            // 'orderType' => 1, // Required for trigger order 1 => limit order,2:Post Only Maker,3 => close or cancel instantly ,4 => close or cancel completely,5 => Market order
        );
        $method = 'contractPrivatePostOrderSubmit';
        $stopPrice = $this->safe_number_2($params, 'triggerPrice', 'stopPrice');
        $params = $this->omit($params, array( 'stopPrice', 'triggerPrice' ));
        if ($stopPrice) {
            $method = 'contractPrivatePostPlanorderPlace';
            $request['triggerPrice'] = $this->price_to_precision($symbol, $stopPrice);
            $request['triggerType'] = $this->safe_integer($params, 'triggerType', 1);
            $request['executeCycle'] = $this->safe_integer($params, 'executeCycle', 1);
            $request['trend'] = $this->safe_integer($params, 'trend', 1);
            $request['orderType'] = $this->safe_integer($params, 'orderType', 1);
        }
        if (($type !== 5) && ($type !== 6) && ($type !== 'market')) {
            $request['price'] = floatval($this->price_to_precision($symbol, $price));
        }
        if ($openType === 1) {
            $leverage = $this->safe_integer($params, 'leverage');
            if ($leverage === null) {
                throw new ArgumentsRequired($this->id . ' createSwapOrder() requires a $leverage parameter for isolated margin orders');
            }
        }
        $clientOrderId = $this->safe_string_2($params, 'clientOrderId', 'externalOid');
        if ($clientOrderId !== null) {
            $request['externalOid'] = $clientOrderId;
        }
        $params = $this->omit($params, array( 'clientOrderId', 'externalOid', 'postOnly' ));
        $response = $this->$method (array_merge($request, $params));
        //
        // Swap
        //     array("code":200,"data":"2ff3163e8617443cb9c6fc19d42b1ca4")
        //
        // Trigger
        //     array("success":true,"code":0,"data":259208506303929856)
        //
        $data = $this->safe_string($response, 'data');
        return $this->parse_order($data, $market);
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrder() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $data = null;
        if ($market['spot']) {
            $clientOrderId = $this->safe_string($params, 'clientOrderId');
            if ($clientOrderId !== null) {
                $params = $this->omit($params, 'clientOrderId');
                $request['origClientOrderId'] = $clientOrderId;
            } else {
                $request['orderId'] = $id;
            }
            $data = $this->spotPrivateGetOrder (array_merge($request, $params));
            //
            //     {
            //         "symbol" => "BTCUSDT",
            //         "orderId" => "133734823834147272",
            //         "orderListId" => "-1",
            //         "clientOrderId" => null,
            //         "price" => "30000",
            //         "origQty" => "0.0002",
            //         "executedQty" => "0",
            //         "cummulativeQuoteQty" => "0",
            //         "status" => "CANCELED",
            //         "timeInForce" => null,
            //         "type" => "LIMIT",
            //         "side" => "BUY",
            //         "stopPrice" => null,
            //         "icebergQty" => null,
            //         "time" => "1647667102000",
            //         "updateTime" => "1647708567000",
            //         "isWorking" => true,
            //         "origQuoteOrderQty" => "6"
            //     }
            //
        } elseif ($market['swap']) {
            $request['order_id'] = $id;
            $response = $this->contractPrivateGetOrderGetOrderId (array_merge($request, $params));
            //
            //     {
            //         "success" => true,
            //         "code" => "0",
            //         "data" => {
            //             "orderId" => "264995729269765120",
            //             "symbol" => "STEPN_USDT",
            //             "positionId" => "0",
            //             "price" => "2.2",
            //             "vol" => "15",
            //             "leverage" => "20",
            //             "side" => "1",
            //             "category" => "1",
            //             "orderType" => "1",
            //             "dealAvgPrice" => "0",
            //             "dealVol" => "0",
            //             "orderMargin" => "2.2528",
            //             "takerFee" => "0",
            //             "makerFee" => "0",
            //             "profit" => "0",
            //             "feeCurrency" => "USDT",
            //             "openType" => "1",
            //             "state" => "2",
            //             "externalOid" => "_m_0e9520c256744d64b942985189026d20",
            //             "errorCode" => "0",
            //             "usedMargin" => "0",
            //             "createTime" => "1648850305236",
            //             "updateTime" => "1648850305245",
            //             "positionMode" => "1"
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data');
        }
        return $this->parse_order($data, $market);
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        list($marketType, $query) = $this->handle_market_type_and_params('fetchOrders', $market, $params);
        if ($marketType === 'spot') {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchOrder() requires a $symbol argument for spot market');
            }
            if ($since !== null) {
                $request['startTime'] = $since;
            }
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = $this->spotPrivateGetAllOrders (array_merge($request, $query));
            //
            //     array(
            //         array(
            //             "symbol" => "BTCUSDT",
            //             "orderId" => "133949373632483328",
            //             "orderListId" => "-1",
            //             "clientOrderId" => null,
            //             "price" => "45000",
            //             "origQty" => "0.0002",
            //             "executedQty" => "0",
            //             "cummulativeQuoteQty" => "0",
            //             "status" => "NEW",
            //             "timeInForce" => null,
            //             "type" => "LIMIT",
            //             "side" => "SELL",
            //             "stopPrice" => null,
            //             "icebergQty" => null,
            //             "time" => "1647718255000",
            //             "updateTime" => "1647718255000",
            //             "isWorking" => true,
            //             "origQuoteOrderQty" => "9"
            //         ),
            //     )
            //
            return $this->parse_orders($response, $market, $since, $limit);
        } else {
            if ($since !== null) {
                $request['start_time'] = $since;
                $end = $this->safe_integer($params, 'end_time');
                if ($end === null) {
                    $request['end_time'] = $this->sum($since, $this->options['maxTimeTillEnd']);
                }
            }
            if ($limit !== null) {
                $request['page_size'] = $limit;
            }
            $method = $this->safe_string($this->options, 'cancelOrder', 'contractPrivateGetOrderListHistoryOrders'); // contractPrivatePostOrderCancel, contractPrivatePostPlanorderCancel
            $method = $this->safe_string($query, 'method', $method);
            $ordersOfRegular = array();
            $ordersOfTrigger = array();
            if ($method === 'contractPrivateGetOrderListHistoryOrders') {
                $response = $this->contractPrivateGetOrderListHistoryOrders (array_merge($request, $query));
                //
                //     {
                //         "success" => true,
                //         "code" => "0",
                //         "data" => array(
                //             array(
                //                 "orderId" => "265230764677709315",
                //                 "symbol" => "STEPN_USDT",
                //                 "positionId" => "0",
                //                 "price" => "2.1",
                //                 "vol" => "102",
                //                 "leverage" => "20",
                //                 "side" => "1",
                //                 "category" => "1",
                //                 "orderType" => "1",
                //                 "dealAvgPrice" => "0",
                //                 "dealVol" => "0",
                //                 "orderMargin" => "10.96704",
                //                 "takerFee" => "0",
                //                 "makerFee" => "0",
                //                 "profit" => "0",
                //                 "feeCurrency" => "USDT",
                //                 "openType" => "1",
                //                 "state" => "2",
                //                 "externalOid" => "_m_7e42f8df6b324c869e4e200397e2b00f",
                //                 "errorCode" => "0",
                //                 "usedMargin" => "0",
                //                 "createTime" => "1648906342000",
                //                 "updateTime" => "1648906342000",
                //                 "positionMode" => "1"
                //             ),
                //          )
                //     }
                //
                $ordersOfRegular = $this->safe_value($response, 'data');
            } else {
                // the Planorder endpoints work not only for stop-$market orders, but also for stop-$limit orders that were supposed to have a separate endpoint
                $response = $this->contractPrivateGetPlanorderListOrders (array_merge($request, $query));
                //
                //     {
                //         "success" => true,
                //         "code" => "0",
                //         "data" => array(
                //             array(
                //                 "symbol" => "STEPN_USDT",
                //                 "leverage" => "20",
                //                 "side" => "1",
                //                 "vol" => "13",
                //                 "openType" => "1",
                //                 "state" => "1",
                //                 "orderType" => "1",
                //                 "errorCode" => "0",
                //                 "createTime" => "1648984276000",
                //                 "updateTime" => "1648984276000",
                //                 "id" => "265557643326564352",
                //                 "triggerType" => "1",
                //                 "triggerPrice" => "3",
                //                 "price" => "2.9", // not present in stop-$market, but in stop-$limit order
                //                 "executeCycle" => "87600",
                //                 "trend" => "1",
                //             ),
                //         )
                //     }
                //
                $ordersOfTrigger = $this->safe_value($response, 'data');
            }
            $merged = $this->array_concat($ordersOfTrigger, $ordersOfRegular);
            return $this->parse_orders($merged, $market, $since, $limit, $params);
        }
    }

    public function fetch_orders_by_ids($ids, $symbol = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        list($marketType, $query) = $this->handle_market_type_and_params('fetchOrdersByIds', $market, $params);
        if ($marketType === 'spot') {
            throw new BadRequest($this->id . ' fetchOrdersByIds() is not supported for ' . $marketType);
        } else {
            $request['order_ids'] = implode(',', $ids);
            $response = $this->contractPrivateGetOrderBatchQuery (array_merge($request, $query));
            //
            //     {
            //         "success" => true,
            //         "code" => "0",
            //         "data" => array(
            //             {
            //                 "orderId" => "265230764677709315",
            //                 "symbol" => "STEPN_USDT",
            //                 "positionId" => "0",
            //                 "price" => "2.1",
            //                 "vol" => "102",
            //                 "leverage" => "20",
            //                 "side" => "1",
            //                 "category" => "1",
            //                 "orderType" => "1",
            //                 "dealAvgPrice" => "0",
            //                 "dealVol" => "0",
            //                 "orderMargin" => "10.96704",
            //                 "takerFee" => "0",
            //                 "makerFee" => "0",
            //                 "profit" => "0",
            //                 "feeCurrency" => "USDT",
            //                 "openType" => "1",
            //                 "state" => "2",
            //                 "externalOid" => "_m_7e42f8df6b324c869e4e200397e2b00f",
            //                 "errorCode" => "0",
            //                 "usedMargin" => "0",
            //                 "createTime" => "1648906342000",
            //                 "updateTime" => "1648906342000",
            //                 "positionMode" => "1"
            //             }
            //         )
            //     }
            //
            $data = $this->safe_value($response, 'data');
            return $this->parse_orders($data, $market);
        }
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        list($marketType, $query) = $this->handle_market_type_and_params('fetchOpenOrders', $market, $params);
        if ($marketType === 'spot') {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchOrder() requires a $symbol argument for spot market');
            }
            $response = $this->spotPrivateGetOpenOrders (array_merge($request, $query));
            //
            // spot
            //
            //     array(
            //         {
            //             "symbol" => "BTCUSDT",
            //             "orderId" => "133949373632483328",
            //             "orderListId" => "-1",
            //             "clientOrderId" => "",
            //             "price" => "45000",
            //             "origQty" => "0.0002",
            //             "executedQty" => "0",
            //             "cummulativeQuoteQty" => "0",
            //             "status" => "NEW",
            //             "timeInForce" => null,
            //             "type" => "LIMIT",
            //             "side" => "SELL",
            //             "stopPrice" => null,
            //             "icebergQty" => null,
            //             "time" => "1647718255199",
            //             "updateTime" => null,
            //             "isWorking" => true,
            //             "origQuoteOrderQty" => "9"
            //         }
            //     )
            //
            return $this->parse_orders($response, $market, $since, $limit);
        } else {
            // TO_DO => another possible way is through => open_orders/{$symbol}, but as they have same ratelimits, and less granularity, i think historical orders are more convenient, as it supports more $params (however, theoretically, open-orders endpoint might be sligthly fast)
            return $this->fetch_orders_by_state(2, $symbol, $since, $limit, $params);
        }
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return $this->fetch_orders_by_state(3, $symbol, $since, $limit, $params);
    }

    public function fetch_canceled_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return $this->fetch_orders_by_state(4, $symbol, $since, $limit, $params);
    }

    public function fetch_orders_by_state($state, $symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        list($marketType) = $this->handle_market_type_and_params('fetchOrdersByState', $market, $params);
        if ($marketType === 'spot') {
            throw new BadRequest($this->id . ' fetchOrdersByState() is not supported for ' . $marketType);
        } else {
            $params['states'] = $state;
            return $this->fetch_orders($symbol, $since, $limit, $params);
        }
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        list($marketType, $query) = $this->handle_market_type_and_params('cancelOrder', $market, $params);
        $data = null;
        if ($marketType === 'spot') {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument');
            }
            $request = array(
                'symbol' => $market['id'],
            );
            $clientOrderId = $this->safe_string($params, 'clientOrderId');
            if ($clientOrderId !== null) {
                $params = $this->omit($query, 'clientOrderId');
                $request['origClientOrderId'] = $clientOrderId;
            } else {
                $request['orderId'] = $id;
            }
            $data = $this->spotPrivateDeleteOrder (array_merge($request, $params));
            //
            //     {
            //         "symbol" => "BTCUSDT",
            //         "orderId" => "133734823834447872",
            //         "price" => "30000",
            //         "origQty" => "0.0002",
            //         "type" => "LIMIT",
            //         "side" => "BUY"
            //     }
            //
        } else {
            // TODO => PlanorderCancel endpoint has bug atm. waiting for fix.
            $method = $this->safe_string($this->options, 'cancelOrder', 'contractPrivatePostOrderCancel'); // contractPrivatePostOrderCancel, contractPrivatePostPlanorderCancel
            $method = $this->safe_string($query, 'method', $method);
            $response = $this->$method (array( $id )); // the $request cannot be changed or extended. This is the only way to send.
            //
            //     {
            //         "success" => true,
            //         "code" => "0",
            //         "data" => array(
            //             {
            //                 "orderId" => "264995729269765120",
            //                 "errorCode" => "0",         // if already canceled => "2041"; if doesn't exist => "2040"
            //                 "errorMsg" => "success",    // if already canceled => "order state cannot be cancelled"; if doesn't exist => "order not exist"
            //             }
            //         )
            //     }
            //
            $data = $this->safe_value($response, 'data');
            $order = $this->safe_value($data, 0);
            $errorMsg = $this->safe_value($order, 'errorMsg', '');
            if ($errorMsg !== 'success') {
                throw new InvalidOrder($this->id . ' cancelOrder() the $order with $id ' . $id . ' cannot be cancelled => ' . $errorMsg);
            }
        }
        return $this->parse_order($data, $market);
    }

    public function cancel_orders($ids, $symbol = null, $params = array ()) {
        $this->load_markets();
        $market = $symbol !== null ? $this->market($symbol) : null;
        list($marketType) = $this->handle_market_type_and_params('cancelOrders', $market, $params);
        if ($marketType === 'spot') {
            throw new BadRequest($this->id . ' cancelOrders() is not supported for ' . $marketType);
        } else {
            $response = $this->contractPrivatePostOrderCancel ($ids); // the request cannot be changed or extended. The only way to send.
            //
            //     {
            //         "success" => true,
            //         "code" => "0",
            //         "data" => array(
            //             array(
            //                 "orderId" => "264995729269765120",
            //                 "errorCode" => "0",         // if already canceled => "2041"
            //                 "errorMsg" => "success",    // if already canceled => "order state cannot be cancelled"
            //             ),
            //         )
            //     }
            //
            $data = $this->safe_value($response, 'data');
            return $this->parse_orders($data, $market);
        }
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        $this->load_markets();
        $market = $symbol !== null ? $this->market($symbol) : null;
        $request = array();
        list($marketType, $query) = $this->handle_market_type_and_params('cancelAllOrders', $market, $params);
        if ($marketType === 'spot') {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' cancelAllOrders() requires a $symbol argument on spot');
            }
            $request['symbol'] = $market['id'];
            $response = $this->spotPrivateDeleteOpenOrders (array_merge($request, $query));
            //
            //     array(
            //         array(
            //             "symbol" => "BTCUSDT",
            //             "orderId" => "133926492139692032",
            //             "price" => "30000",
            //             "origQty" => "0.0002",
            //             "type" => "LIMIT",
            //             "side" => "BUY"
            //         ),
            //     )
            //
            return $this->parse_orders($response, $market);
        } else {
            if ($symbol !== null) {
                $request['symbol'] = $market['id'];
            }
            // $method can be either => contractPrivatePostOrderCancelAll or contractPrivatePostPlanorderCancelAll
            // the Planorder endpoints work not only for stop-$market orders but also for stop-limit orders that are supposed to have separate endpoint
            $method = $this->safe_string($this->options, 'cancelAllOrders', 'contractPrivatePostOrderCancelAll');
            $method = $this->safe_string($query, 'method', $method);
            $response = $this->$method (array_merge($request, $query));
            //
            //     {
            //         "success" => true,
            //         "code" => "0"
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            return $this->parse_orders($data, $market);
        }
    }

    public function parse_order($order, $market = null) {
        //
        // spot => createOrder
        //
        //     array( "symbol" => "BTCUSDT", "orderId" => "123738410679123456", "orderListId" => -1 )
        //
        // spot => cancelOrder, cancelAllOrders
        //
        //     {
        //         "symbol" => "BTCUSDT",
        //         "orderId" => "133926441921286144",
        //         "price" => "30000",
        //         "origQty" => "0.0002",
        //         "type" => "LIMIT",
        //         "side" => "BUY"
        //     }
        //
        // spot => fetchOrder, fetchOpenOrders, fetchOrders
        //     {
        //         "symbol" => "BTCUSDT",
        //         "orderId" => "133734823834147272",
        //         "orderListId" => "-1",
        //         "clientOrderId" => null,
        //         "price" => "30000",
        //         "origQty" => "0.0002",
        //         "executedQty" => "0",
        //         "cummulativeQuoteQty" => "0",
        //         "status" => "CANCELED",
        //         "timeInForce" => null,
        //         "type" => "LIMIT",
        //         "side" => "BUY",
        //         "stopPrice" => null,
        //         "icebergQty" => null,
        //         "time" => "1647667102000",
        //         "updateTime" => "1647708567000",
        //         "isWorking" => true,
        //         "origQuoteOrderQty" => "6"
        //     }
        //
        // swap => createOrder
        //
        //     2ff3163e8617443cb9c6fc19d42b1ca4
        //
        // swap => fetchOrder, fetchOrders
        //
        //     regular
        //     {
        //         "orderId" => "264995729269765120",
        //         "symbol" => "STEPN_USDT",
        //         "positionId" => "0",
        //         "price" => "2.2",
        //         "vol" => "15",
        //         "leverage" => "20",
        //         "side" => "1", // TODO => not unified
        //         "category" => "1",
        //         "orderType" => "1", // TODO => not unified
        //         "dealAvgPrice" => "0",
        //         "dealVol" => "0",
        //         "orderMargin" => "2.2528",
        //         "takerFee" => "0",
        //         "makerFee" => "0",
        //         "profit" => "0",
        //         "feeCurrency" => "USDT",
        //         "openType" => "1",
        //         "state" => "2", // TODO
        //         "externalOid" => "_m_0e9520c256744d64b942985189026d20",
        //         "errorCode" => "0",
        //         "usedMargin" => "0",
        //         "createTime" => "1648850305236",
        //         "updateTime" => "1648850305245",
        //         "positionMode" => "1"
        //     }
        //
        //     stop
        //     {
        //         "id" => "265557643326564352",
        //         "triggerType" => "1",
        //         "triggerPrice" => "3",
        //         "price" => "2.9", // not present in stop-$market, but in stop-limit $order
        //         "executeCycle" => "87600",
        //         "trend" => "1",
        //          // below keys are same as in regular $order structure
        //         "symbol" => "STEPN_USDT",
        //         "leverage" => "20",
        //         "side" => "1",
        //         "vol" => "13",
        //         "openType" => "1",
        //         "state" => "1",
        //         "orderType" => "1",
        //         "errorCode" => "0",
        //         "createTime" => "1648984276000",
        //         "updateTime" => "1648984276000",
        //     }
        //
        $id = null;
        if (gettype($order) === 'string') {
            $id = $order;
        } else {
            $id = $this->safe_string_2($order, 'orderId', 'id');
        }
        $marketId = $this->safe_string($order, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $timestamp = $this->safe_integer_2($order, 'time', 'createTime');
        $fee = null;
        $feeCurrency = $this->safe_string($order, 'feeCurrency');
        if ($feeCurrency !== null) {
            $takerFee = $this->safe_string($order, 'takerFee');
            $makerFee = $this->safe_string($order, 'makerFee');
            $feeSum = Precise::string_add($takerFee, $makerFee);
            $fee = array(
                'currency' => $feeCurrency,
                'cost' => $this->parse_number($feeSum),
            );
        }
        return $this->safe_order(array(
            'id' => $id,
            'clientOrderId' => $this->safe_string($order, 'clientOrderId'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null, // TODO => this might be 'updateTime' if $order-status is filled, otherwise cancellation time. needs to be checked
            'status' => $this->parse_order_status($this->safe_string_2($order, 'status', 'state')),
            'symbol' => $market['symbol'],
            'type' => $this->parse_order_type($this->safe_string($order, 'type')),
            'timeInForce' => $this->parse_order_time_in_force($this->safe_string($order, 'timeInForce')),
            'side' => $this->parse_order_side($this->safe_string($order, 'side')),
            'price' => $this->safe_number($order, 'price'),
            'stopPrice' => $this->safe_number_2($order, 'stopPrice', 'triggerPrice'),
            'average' => $this->safe_number($order, 'dealAvgPrice'),
            'amount' => $this->safe_number_2($order, 'origQty', 'vol'),
            'cost' => $this->safe_number($order, 'cummulativeQuoteQty'),  // 'cummulativeQuoteQty' vs 'origQuoteOrderQty'
            'filled' => $this->safe_number_2($order, 'executedQty', 'dealVol'),
            'remaining' => null,
            'fee' => $fee,
            'trades' => null,
            'info' => $order,
        ), $market);
    }

    public function parse_order_side($status) {
        $statuses = array(
            'BUY' => 'buy',
            'SELL' => 'sell',
            // contracts v1 : TODO
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order_type($status) {
        $statuses = array(
            'MARKET' => 'market',
            'LIMIT' => 'limit',
            'LIMIT_MAKER' => 'limit',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order_status($status) {
        $statuses = array(
            'NEW' => 'open',
            'FILLED' => 'closed',
            'CANCELED' => 'canceled',
            'PARTIALLY_FILLED' => 'open',
            'PARTIALLY_CANCELED' => 'canceled',
            // contracts v1
            // '1' => 'uninformed', // TODO => wt?
            '2' => 'open',
            '3' => 'closed',
            '4' => 'canceled',
            // '5' => 'invalid', //  TODO => wt?
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order_time_in_force($status) {
        $statuses = array(
            'GTC' => 'GTC',
            'FOK' => 'FOK',
            'IOC' => 'IOC',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function fetch_account_helper($type, $params) {
        if ($type === 'spot') {
            return $this->spotPrivateGetAccount ($params);
            //
            //     {
            //         "makerCommission" => "20",
            //         "takerCommission" => "20",
            //         "buyerCommission" => "0",
            //         "sellerCommission" => "0",
            //         "canTrade" => true,
            //         "canWithdraw" => true,
            //         "canDeposit" => true,
            //         "updateTime" => null,
            //         "accountType" => "SPOT",
            //         "balances" => array(
            //             array(
            //                 "asset" => "BTC",
            //                 "free" => "0.002",
            //                 "locked" => "0"
            //             ),
            //             array(
            //                 "asset" => "USDT",
            //                 "free" => "88.120131350620957006",
            //                 "locked" => "0"
            //             ),
            //         ),
            //         "permissions" => array(
            //             "SPOT"
            //         )
            //     }
            //
        } elseif ($type === 'swap') {
            $response = $this->contractPrivateGetAccountAssets ($params);
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":array(
            //            array(
            //              "currency":"BSV",
            //              "positionMargin":0,
            //              "availableBalance":0,
            //              "cashBalance":0,
            //              "frozenBalance":0,
            //              "equity":0,
            //              "unrealized":0,
            //              "bonus":0
            //           ),
            //         )
            //     }
            //
            return $this->safe_value($response, 'data');
        }
    }

    public function fetch_accounts($params = array ()) {
        // TODO => is the below endpoints suitable for fetchAccounts?
        list($marketType, $query) = $this->handle_market_type_and_params('fetchAccounts', null, $params);
        $this->load_markets();
        $response = $this->fetch_account_helper($marketType, $query);
        $data = $this->safe_value($response, 'balances', array());
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $account = $data[$i];
            $currencyId = $this->safe_string_2($account, 'asset', 'currency');
            $code = $this->safe_currency_code($currencyId);
            $result[] = array(
                'id' => $this->safe_string($account, 'id'),
                'type' => $this->safe_string($account, 'type'),
                'code' => $code,
                'info' => $account,
            );
        }
        return $result;
    }

    public function fetch_trading_fees($params = array ()) {
        $this->load_markets();
        $response = $this->fetch_account_helper('spot', $params);
        $makerFee = $this->safe_string($response, 'makerCommission');
        $takerFee = $this->safe_string($response, 'takerCommission');
        $makerFee = Precise::string_div($makerFee, '1000');
        $takerFee = Precise::string_div($takerFee, '1000');
        $result = array();
        for ($i = 0; $i < count($this->symbols); $i++) {
            $symbol = $this->symbols[$i];
            $result[$symbol] = array(
                'symbol' => $symbol,
                'maker' => $this->parse_number($makerFee),
                'taker' => $this->parse_number($takerFee),
                'percentage' => true,
                'tierBased' => false,
                'info' => $response,
            );
        }
        return $result;
    }

    public function fetch_balance($params = array ()) {
        /**
         * $query for $balance and get the amount of funds available for trading or funds locked in orders
         * @param {dict} $params extra parameters specific to the mexc3 api endpoint
         * @return {dict} a ~@link https://docs.ccxt.com/en/latest/manual.html?#$balance-structure $balance structure~
         */
        $this->load_markets();
        list($marketType, $query) = $this->handle_market_type_and_params('fetchBalance', null, $params);
        $result = array();
        $response = null;
        if ($marketType === 'spot') {
            $response = $this->fetch_account_helper('spot', $query);
            $balances = $this->safe_value($response, 'balances', array());
            for ($i = 0; $i < count($balances); $i++) {
                $entry = $balances[$i];
                $currencyId = $this->safe_string($entry, 'asset');
                $code = $this->safe_currency_code($currencyId);
                $account = $this->account();
                $account['free'] = $this->safe_string($entry, 'free');
                $account['used'] = $this->safe_string($entry, 'locked');
                $result[$code] = $account;
            }
        } elseif ($marketType === 'swap') {
            $response = $this->contractPrivateGetAccountAssets ($query);
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":array(
            //             array("currency":"BSV","positionMargin":0,"availableBalance":0,"cashBalance":0,"frozenBalance":0,"equity":0,"unrealized":0,"bonus":0),
            //             array("currency":"BCH","positionMargin":0,"availableBalance":0,"cashBalance":0,"frozenBalance":0,"equity":0,"unrealized":0,"bonus":0),
            //             array("currency":"CRV","positionMargin":0,"availableBalance":0,"cashBalance":0,"frozenBalance":0,"equity":0,"unrealized":0,"bonus":0),
            //         )
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            for ($i = 0; $i < count($data); $i++) {
                $balance = $data[$i];
                $currencyId = $this->safe_string($balance, 'currency');
                $code = $this->safe_currency_code($currencyId);
                $account = $this->account();
                $account['free'] = $this->safe_string($balance, 'availableBalance');
                $account['used'] = $this->safe_string($balance, 'frozenBalance');
                $result[$code] = $account;
            }
        }
        $result['info'] = $response;
        return $this->safe_balance($result);
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchMyTrades() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        list($marketType, $query) = $this->handle_market_type_and_params('fetchMyTrades', $market, $params);
        $request = array(
            'symbol' => $market['id'],
        );
        $trades = null;
        if ($marketType === 'spot') {
            if ($since !== null) {
                $request['start_time'] = $since;
            }
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $trades = $this->spotPrivateGetMyTrades (array_merge($request, $query));
            //
            // spot
            //
            //     array(
            //         {
            //             "symbol" => "BTCUSDT",
            //             "id" => "133948532984922113",
            //             "orderId" => "133948532531949568",
            //             "orderListId" => "-1",
            //             "price" => "41995.51",
            //             "qty" => "0.0002",
            //             "quoteQty" => "8.399102",
            //             "commission" => "0.016798204",
            //             "commissionAsset" => "USDT",
            //             "time" => "1647718055000",
            //             "isBuyer" => true,
            //             "isMaker" => false,
            //             "isBestMatch" => true
            //         }
            //     )
            //
        } else {
            if ($since !== null) {
                $request['start_time'] = $since;
                $end = $this->safe_integer($params, 'end_time');
                if ($end === null) {
                    $request['end_time'] = $this->sum($since, $this->options['maxTimeTillEnd']);
                }
            }
            if ($limit !== null) {
                $request['page_size'] = $limit;
            }
            $response = $this->contractPrivateGetOrderListOrderDeals (array_merge($request, $query));
            //
            //     {
            //         "success" => true,
            //         "code" => "0",
            //         "data" => array(
            //             {
            //                 "id" => "299444585",
            //                 "symbol" => "STEPN_USDT",
            //                 "side" => "1",
            //                 "vol" => "1",
            //                 "price" => "2.45455",
            //                 "feeCurrency" => "USDT",
            //                 "fee" => "0.00147273",
            //                 "timestamp" => "1648924557000",
            //                 "profit" => "0",
            //                 "category" => "1",
            //                 "orderId" => "265307163526610432",
            //                 "positionMode" => "1",
            //                 "taker" => true
            //             }
            //         )
            //     }
            //
            $trades = $this->safe_value($response, 'data');
        }
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function fetch_order_trades($id, $symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
        }
        list($marketType, $query) = $this->handle_market_type_and_params('fetchOrderTrades', $market, $params);
        $trades = null;
        if ($marketType === 'spot') {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchOrderTrades() requires a $symbol argument');
            }
            $request['symbol'] = $market['id'];
            $request['orderId'] = $id;
            $trades = $this->spotPrivateGetMyTrades (array_merge($request, $query));
            //
            // spot
            //
            //     array(
            //         {
            //             "symbol" => "BTCUSDT",
            //             "id" => "133948532984922113",
            //             "orderId" => "133948532531949568",
            //             "orderListId" => "-1",
            //             "price" => "41995.51",
            //             "qty" => "0.0002",
            //             "quoteQty" => "8.399102",
            //             "commission" => "0.016798204",
            //             "commissionAsset" => "USDT",
            //             "time" => "1647718055000",
            //             "isBuyer" => true,
            //             "isMaker" => false,
            //             "isBestMatch" => true
            //         }
            //     )
            //
        } else {
            $request['order_id'] = $id;
            $response = $this->contractPrivateGetOrderDealDetailsOrderId (array_merge($request, $query));
            //
            //     {
            //         "success" => true,
            //         "code" => "0",
            //         "data" => array(
            //             {
            //                 "id" => "299444585",
            //                 "symbol" => "STEPN_USDT",
            //                 "side" => "1",
            //                 "vol" => "1",
            //                 "price" => "2.45455",
            //                 "feeCurrency" => "USDT",
            //                 "fee" => "0.00147273",
            //                 "timestamp" => "1648924557000",
            //                 "profit" => "0",
            //                 "category" => "1",
            //                 "orderId" => "265307163526610432",
            //                 "positionMode" => "1",
            //                 "taker" => true
            //             }
            //         )
            //     }
            //
            $trades = $this->safe_value($response, 'data');
        }
        return $this->parse_trades($trades, $market, $since, $limit, $query);
    }

    public function modify_margin_helper($symbol, $amount, $addOrReduce, $params = array ()) {
        $positionId = $this->safe_integer($params, 'positionId');
        if ($positionId === null) {
            throw new ArgumentsRequired($this->id . ' modifyMarginHelper() requires a $positionId parameter');
        }
        $this->load_markets();
        $request = array(
            'positionId' => $positionId,
            'amount' => $amount,
            'type' => $addOrReduce,
        );
        $response = $this->contractPrivatePostPositionChangeMargin (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "code" => 0
        //     }
        return $response;
    }

    public function reduce_margin($symbol, $amount, $params = array ()) {
        return $this->modify_margin_helper($symbol, $amount, 'SUB', $params);
    }

    public function add_margin($symbol, $amount, $params = array ()) {
        return $this->modify_margin_helper($symbol, $amount, 'ADD', $params);
    }

    public function set_leverage($leverage, $symbol = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            'leverage' => $leverage,
        );
        $positionId = $this->safe_integer($params, 'positionId');
        if ($positionId === null) {
            $openType = $this->safe_number($params, 'openType'); // 1 or 2
            $positionType = $this->safe_number($params, 'positionType'); // 1 or 2
            $market = ($symbol !== null) ? $this->market($symbol) : null;
            if (($openType === null) || ($positionType === null) || ($market === null)) {
                throw new ArgumentsRequired($this->id . ' setLeverage() requires a $positionId parameter or a $symbol argument with $openType and $positionType parameters, use $openType 1 or 2 for isolated or cross margin respectively, use $positionType 1 or 2 for long or short positions');
            } else {
                $request['openType'] = $openType;
                $request['symbol'] = $market['symbol'];
                $request['positionType'] = $positionType;
            }
        } else {
            $request['positionId'] = $positionId;
        }
        return $this->contractPrivatePostPositionChangeLeverage (array_merge($request, $params));
    }

    public function fetch_funding_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = null;
        $request = array(
            // 'symbol' => $market['id'],
            // 'position_id' => positionId,
            // 'page_num' => 1,
            // 'page_size' => $limit, // default 20, max 100
        );
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($limit !== null) {
            $request['page_size'] = $limit;
        }
        $response = $this->contractPrivateGetPositionFundingRecords (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "code" => 0,
        //         "data" => {
        //             "pageSize" => 20,
        //             "totalCount" => 2,
        //             "totalPage" => 1,
        //             "currentPage" => 1,
        //             "resultList" => array(
        //                 array(
        //                     "id" => 7423910,
        //                     "symbol" => "BTC_USDT",
        //                     "positionType" => 1,
        //                     "positionValue" => 29.30024,
        //                     "funding" => 0.00076180624,
        //                     "rate" => -0.000026,
        //                     "settleTime" => 1643299200000
        //                 ),
        //                 {
        //                     "id" => 7416473,
        //                     "symbol" => "BTC_USDT",
        //                     "positionType" => 1,
        //                     "positionValue" => 28.9188,
        //                     "funding" => 0.0014748588,
        //                     "rate" => -0.000051,
        //                     "settleTime" => 1643270400000
        //                 }
        //             )
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $resultList = $this->safe_value($data, 'resultList', array());
        $result = array();
        for ($i = 0; $i < count($resultList); $i++) {
            $entry = $resultList[$i];
            $timestamp = $this->safe_string($entry, 'settleTime');
            $result[] = array(
                'info' => $entry,
                'symbol' => $symbol,
                'code' => null,
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
                'id' => $this->safe_number($entry, 'id'),
                'amount' => $this->safe_number($entry, 'funding'),
            );
        }
        return $result;
    }

    public function parse_funding_rate($fundingRate, $market = null) {
        //
        //     {
        //         "symbol" => "BTC_USDT",
        //         "fundingRate" => 0.000014,
        //         "maxFundingRate" => 0.003,
        //         "minFundingRate" => -0.003,
        //         "collectCycle" => 8,
        //         "nextSettleTime" => 1643241600000,
        //         "timestamp" => 1643240373359
        //     }
        //
        $nextFundingRate = $this->safe_number($fundingRate, 'fundingRate');
        $nextFundingTimestamp = $this->safe_integer($fundingRate, 'nextSettleTime');
        $marketId = $this->safe_string($fundingRate, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market);
        $timestamp = $this->safe_integer($fundingRate, 'timestamp');
        $datetime = $this->iso8601($timestamp);
        return array(
            'info' => $fundingRate,
            'symbol' => $symbol,
            'markPrice' => null,
            'indexPrice' => null,
            'interestRate' => null,
            'estimatedSettlePrice' => null,
            'timestamp' => $timestamp,
            'datetime' => $datetime,
            'fundingRate' => null,
            'fundingTimestamp' => null,
            'fundingDatetime' => null,
            'nextFundingRate' => $nextFundingRate,
            'nextFundingTimestamp' => $nextFundingTimestamp,
            'nextFundingDatetime' => $this->iso8601($nextFundingTimestamp),
            'previousFundingRate' => null,
            'previousFundingTimestamp' => null,
            'previousFundingDatetime' => null,
        );
    }

    public function fetch_funding_rate($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = $this->contractPublicGetFundingRateSymbol (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "code" => 0,
        //         "data" => {
        //             "symbol" => "BTC_USDT",
        //             "fundingRate" => 0.000014,
        //             "maxFundingRate" => 0.003,
        //             "minFundingRate" => -0.003,
        //             "collectCycle" => 8,
        //             "nextSettleTime" => 1643241600000,
        //             "timestamp" => 1643240373359
        //         }
        //     }
        //
        $result = $this->safe_value($response, 'data', array());
        return $this->parse_funding_rate($result, $market);
    }

    public function fetch_funding_rate_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        /**
         * fetches historical funding rate prices
         * @param {str|null} $symbol unified $symbol of the $market to fetch the funding rate history for
         * @param {int|null} $since not used by mexc, but filtered internally by ccxt
         * @param {int|null} $limit mexc $limit is page_size default 20, maximum is 100
         * @param {dict} $params extra parameters specific to the mexc api endpoint
         * @return {[dict]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure funding rate structures~
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchFundingRateHistory() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            // 'page_size' => $limit, // optional
            // 'page_num' => 1, // optional, current page number, default is 1
        );
        if ($limit !== null) {
            $request['page_size'] = $limit;
        }
        $response = $this->contractPublicGetFundingRateHistory (array_merge($request, $params));
        //
        //    {
        //        "success" => true,
        //        "code" => 0,
        //        "data" => {
        //            "pageSize" => 2,
        //            "totalCount" => 21,
        //            "totalPage" => 11,
        //            "currentPage" => 1,
        //            "resultList" => array(
        //                array(
        //                    "symbol" => "BTC_USDT",
        //                    "fundingRate" => 0.000266,
        //                    "settleTime" => 1609804800000
        //                ),
        //                {
        //                    "symbol" => "BTC_USDT",
        //                    "fundingRate" => 0.00029,
        //                    "settleTime" => 1609776000000
        //                }
        //            )
        //        }
        //    }
        //
        $data = $this->safe_value($response, 'data');
        $result = $this->safe_value($data, 'resultList', array());
        $rates = array();
        for ($i = 0; $i < count($result); $i++) {
            $entry = $result[$i];
            $marketId = $this->safe_string($entry, 'symbol');
            $symbol = $this->safe_symbol($marketId);
            $timestamp = $this->safe_string($entry, 'settleTime');
            $rates[] = array(
                'info' => $entry,
                'symbol' => $symbol,
                'fundingRate' => $this->safe_number($entry, 'fundingRate'),
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
            );
        }
        $sorted = $this->sort_by($rates, 'timestamp');
        return $this->filter_by_symbol_since_limit($sorted, $market['symbol'], $since, $limit);
    }

    public function fetch_leverage_tiers($symbols = null, $params = array ()) {
        $this->load_markets();
        $response = $this->contractPublicGetDetail ($params);
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":[
        //             array(
        //                 "symbol" => "BTC_USDT",
        //                 "displayName" => "BTC_USDT永续",
        //                 "displayNameEn" => "BTC_USDT SWAP",
        //                 "positionOpenType" => 3,
        //                 "baseCoin" => "BTC",
        //                 "quoteCoin" => "USDT",
        //                 "settleCoin" => "USDT",
        //                 "contractSize" => 0.0001,
        //                 "minLeverage" => 1,
        //                 "maxLeverage" => 125,
        //                 "priceScale" => 2,
        //                 "volScale" => 0,
        //                 "amountScale" => 4,
        //                 "priceUnit" => 0.5,
        //                 "volUnit" => 1,
        //                 "minVol" => 1,
        //                 "maxVol" => 1000000,
        //                 "bidLimitPriceRate" => 0.1,
        //                 "askLimitPriceRate" => 0.1,
        //                 "takerFeeRate" => 0.0006,
        //                 "makerFeeRate" => 0.0002,
        //                 "maintenanceMarginRate" => 0.004,
        //                 "initialMarginRate" => 0.008,
        //                 "riskBaseVol" => 10000,
        //                 "riskIncrVol" => 200000,
        //                 "riskIncrMmr" => 0.004,
        //                 "riskIncrImr" => 0.004,
        //                 "riskLevelLimit" => 5,
        //                 "priceCoefficientVariation" => 0.1,
        //                 "indexOrigin" => ["BINANCE","GATEIO","HUOBI","MXC"],
        //                 "state" => 0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
        //                 "isNew" => false,
        //                 "isHot" => true,
        //                 "isHidden" => false
        //             ),
        //             ...
        //         ]
        //     }
        //
        $data = $this->safe_value($response, 'data');
        return $this->parse_leverage_tiers($data, $symbols, 'symbol');
    }

    public function parse_market_leverage_tiers($info, $market) {
        /**
            @param $info => Exchange response for 1 $market
            {
                "symbol" => "BTC_USDT",
                "displayName" => "BTC_USDT永续",
                "displayNameEn" => "BTC_USDT SWAP",
                "positionOpenType" => 3,
                "baseCoin" => "BTC",
                "quoteCoin" => "USDT",
                "settleCoin" => "USDT",
                "contractSize" => 0.0001,
                "minLeverage" => 1,
                "maxLeverage" => 125,
                "priceScale" => 2,
                "volScale" => 0,
                "amountScale" => 4,
                "priceUnit" => 0.5,
                "volUnit" => 1,
                "minVol" => 1,
                "maxVol" => 1000000,
                "bidLimitPriceRate" => 0.1,
                "askLimitPriceRate" => 0.1,
                "takerFeeRate" => 0.0006,
                "makerFeeRate" => 0.0002,
                "maintenanceMarginRate" => 0.004,
                "initialMarginRate" => 0.008,
                "riskBaseVol" => 10000,
                "riskIncrVol" => 200000,
                "riskIncrMmr" => 0.004,
                "riskIncrImr" => 0.004,
                "riskLevelLimit" => 5,
                "priceCoefficientVariation" => 0.1,
                "indexOrigin" => ["BINANCE","GATEIO","HUOBI","MXC"],
                "state" => 0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
                "isNew" => false,
                "isHot" => true,
                "isHidden" => false
            }
            @param $market => CCXT $market
         */
        $maintenanceMarginRate = $this->safe_string($info, 'maintenanceMarginRate');
        $initialMarginRate = $this->safe_string($info, 'initialMarginRate');
        $maxVol = $this->safe_string($info, 'maxVol');
        $riskIncrVol = $this->safe_string($info, 'riskIncrVol');
        $riskIncrMmr = $this->safe_string($info, 'riskIncrMmr');
        $riskIncrImr = $this->safe_string($info, 'riskIncrImr');
        $floor = '0';
        $tiers = array();
        $quoteId = $this->safe_string($info, 'quoteCoin');
        while (Precise::string_lt($floor, $maxVol)) {
            $cap = Precise::string_add($floor, $riskIncrVol);
            $tiers[] = array(
                'tier' => $this->parse_number(Precise::string_div($cap, $riskIncrVol)),
                'currency' => $this->safe_currency_code($quoteId),
                'notionalFloor' => $this->parse_number($floor),
                'notionalCap' => $this->parse_number($cap),
                'maintenanceMarginRate' => $this->parse_number($maintenanceMarginRate),
                'maxLeverage' => $this->parse_number(Precise::string_div('1', $initialMarginRate)),
                'info' => $info,
            );
            $initialMarginRate = Precise::string_add($initialMarginRate, $riskIncrImr);
            $maintenanceMarginRate = Precise::string_add($maintenanceMarginRate, $riskIncrMmr);
            $floor = $cap;
        }
        return $tiers;
    }

    public function parse_deposit_address($depositAddress, $currency = null) {
        //
        //     array("chain":"ERC-20","address":"0x55cbd73db24eafcca97369e3f2db74b2490586e6"),
        //     array("chain":"MATIC","address":"0x05aa3236f1970eae0f8feb17ec19435b39574d74"),
        //     array("chain":"TRC20","address":"TGaPfhW41EXD3sAfs1grLF6DKfugfqANNw"),
        //     array("chain":"SOL","address":"5FSpUKuh2gjw4mF89T2e7sEjzUA1SkRKjBChFqP43KhV"),
        //     array("chain":"ALGO","address":"B3XTZND2JJTSYR7R2TQVCUDT4QSSYVAIZYDPWVBX34DGAYATBU3AUV43VU")
        //
        //
        $address = $this->safe_string($depositAddress, 'address');
        $code = $this->safe_currency_code(null, $currency);
        $networkId = $this->safe_string($depositAddress, 'chain');
        $network = $this->safe_network($networkId);
        $this->check_address($address);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => null,
            'network' => $network,
            'info' => $depositAddress,
        );
    }

    public function fetch_deposit_addresses_by_network($code, $params = array ()) {
        $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'currency' => $currency['id'],
        );
        $response = $this->spot2PrivateGetAssetDepositAddressList (array_merge($request, $params));
        //
        //     {
        //         "code":200,
        //         "data":{
        //             "currency":"USDC",
        //             "chains":array(
        //                 array("chain":"ERC-20","address":"0x55cbd73db24eafcca97369e3f2db74b2490586e6"),
        //                 array("chain":"MATIC","address":"0x05aa3236f1970eae0f8feb17ec19435b39574d74"),
        //                 array("chain":"TRC20","address":"TGaPfhW41EXD3sAfs1grLF6DKfugfqANNw"),
        //                 array("chain":"SOL","address":"5FSpUKuh2gjw4mF89T2e7sEjzUA1SkRKjBChFqP43KhV"),
        //                 array("chain":"ALGO","address":"B3XTZND2JJTSYR7R2TQVCUDT4QSSYVAIZYDPWVBX34DGAYATBU3AUV43VU")
        //             )
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $chains = $this->safe_value($data, 'chains', array());
        $depositAddresses = array();
        for ($i = 0; $i < count($chains); $i++) {
            $depositAddress = $this->parse_deposit_address($chains[$i], $currency);
            $depositAddresses[] = $depositAddress;
        }
        return $this->index_by($depositAddresses, 'network');
    }

    public function fetch_deposit_address($code, $params = array ()) {
        $rawNetwork = $this->safe_string_upper($params, 'network');
        $params = $this->omit($params, 'network');
        $response = $this->fetch_deposit_addresses_by_network($code, $params);
        $networks = $this->safe_value($this->options, 'networks', array());
        $network = $this->safe_string($networks, $rawNetwork, $rawNetwork);
        $result = null;
        if ($network === null) {
            $result = $this->safe_value($response, $code);
            if ($result === null) {
                $alias = $this->safe_string($networks, $code, $code);
                $result = $this->safe_value($response, $alias);
                if ($result === null) {
                    $defaultNetwork = $this->safe_string($this->options, 'defaultNetwork', 'ERC20');
                    $result = $this->safe_value($response, $defaultNetwork);
                    if ($result === null) {
                        $values = is_array($response) ? array_values($response) : array();
                        $result = $this->safe_value($values, 0);
                        if ($result === null) {
                            throw new InvalidAddress($this->id . ' fetchDepositAddress() cannot find deposit address for ' . $code);
                        }
                    }
                }
            }
            return $result;
        }
        // TODO => add support for all aliases here
        $result = $this->safe_value($response, $rawNetwork);
        if ($result === null) {
            throw new InvalidAddress($this->id . ' fetchDepositAddress() cannot find ' . $network . ' deposit address for ' . $code);
        }
        return $result;
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            // 'currency' => $currency['id'] . network example => USDT-TRX,
            // 'state' => 'state',
            // 'start_time' => $since, // default 1 day
            // 'end_time' => $this->milliseconds(),
            // 'page_num' => 1,
            // 'page_size' => $limit, // default 20, maximum 50
        );
        $currency = null;
        if ($code !== null) {
            $rawNetwork = $this->safe_string($params, 'network');
            $params = $this->omit($params, 'network');
            if ($rawNetwork === null) {
                throw new ArgumentsRequired($this->id . ' fetchDeposits() requires a network parameter when the $currency is specified');
            }
            // currently mexc does not have network names unified so for certain things we might need TRX or TRC-20
            // due to that I'm applying the network parameter directly so the user can control it on its side
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'] . '-' . $rawNetwork;
        }
        if ($since !== null) {
            $request['start_time'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->spot2PrivateGetAssetDepositList (array_merge($request, $params));
        //
        //     {
        //         "code":200,
        //         "data":{
        //             "page_size":20,
        //             "total_page":1,
        //             "total_size":1,
        //             "page_num":1,
        //             "result_list":array(
        //                 {
        //                     "currency":"USDC",
        //                     "amount":150.0,
        //                     "fee":0.0,
        //                     "confirmations":19,
        //                     "address":"0x55cbd73db24eafcca97369e3f2db74b2490586e6",
        //                     "state":"SUCCESS",
        //                     "tx_id":"0xc65a9b09e1b71def81bf8bb3ec724c0c1b2b4c82200c8c142e4ea4c1469fd789:0",
        //                     "require_confirmations":12,
        //                     "create_time":"2021-10-11T18:58:25.000+00:00",
        //                     "update_time":"2021-10-11T19:01:06.000+00:00"
        //                 }
        //             )
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $resultList = $this->safe_value($data, 'result_list', array());
        return $this->parse_transactions($resultList, $code, $since, $limit);
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            // 'withdrawal_id' => '4b450616042a48c99dd45cacb4b092a7', // string
            // 'currency' => $currency['id'],
            // 'state' => 'state',
            // 'start_time' => $since, // default 1 day
            // 'end_time' => $this->milliseconds(),
            // 'page_num' => 1,
            // 'page_size' => $limit, // default 20, maximum 50
        );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'];
        }
        if ($since !== null) {
            $request['start_time'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->spot2PrivateGetAssetWithdrawList (array_merge($request, $params));
        //
        //     {
        //         "code":200,
        //         "data":{
        //             "page_size":20,
        //             "total_page":1,
        //             "total_size":1,
        //             "page_num":1,
        //             "result_list":array(
        //                 {
        //                     "id":"4b450616042a48c99dd45cacb4b092a7",
        //                     "currency":"USDT-TRX",
        //                     "address":"TRHKnx74Gb8UVcpDCMwzZVe4NqXfkdtPak",
        //                     "amount":30.0,
        //                     "fee":1.0,
        //                     "remark":"this is my first withdrawal remark",
        //                     "state":"WAIT",
        //                     "create_time":"2021-10-11T20:45:08.000+00:00"
        //                 }
        //             )
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $resultList = $this->safe_value($data, 'result_list', array());
        return $this->parse_transactions($resultList, $code, $since, $limit);
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // fetchDeposits
        //
        //     {
        //         "currency":"USDC",
        //         "amount":150.0,
        //         "fee":0.0,
        //         "confirmations":19,
        //         "address":"0x55cbd73db24eafcca97369e3f2db74b2490586e6",
        //         "state":"SUCCESS",
        //         "tx_id":"0xc65a9b09e1b71def81bf8bb3ec724c0c1b2b4c82200c8c142e4ea4c1469fd789:0",
        //         "require_confirmations":12,
        //         "create_time":"2021-10-11T18:58:25.000+00:00",
        //         "update_time":"2021-10-11T19:01:06.000+00:00"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "id":"4b450616042a48c99dd45cacb4b092a7",
        //         "currency":"USDT-TRX",
        //         "address":"TRHKnx74Gb8UVcpDCMwzZVe4NqXfkdtPak",
        //         "amount":30.0,
        //         "fee":1.0,
        //         "remark":"this is my first withdrawal remark",
        //         "state":"WAIT",
        //         "create_time":"2021-10-11T20:45:08.000+00:00"
        //     }
        //
        // withdraw
        //
        //     {
        //         "withdrawId":"25fb2831fb6d4fc7aa4094612a26c81d"
        //     }
        //
        $id = $this->safe_string_2($transaction, 'id', 'withdrawId');
        $type = ($id === null) ? 'deposit' : 'withdrawal';
        $timestamp = $this->parse8601($this->safe_string($transaction, 'create_time'));
        $updated = $this->parse8601($this->safe_string($transaction, 'update_time'));
        $currencyId = $this->safe_string($transaction, 'currency');
        $network = null;
        if (($currencyId !== null) && (mb_strpos($currencyId, '-') !== false)) {
            $parts = explode('-', $currencyId);
            $currencyId = $this->safe_string($parts, 0);
            $networkId = $this->safe_string($parts, 1);
            $network = $this->safe_network($networkId);
        }
        $code = $this->safe_currency_code($currencyId, $currency);
        $status = $this->parse_transaction_status($this->safe_string($transaction, 'state'));
        $amountString = $this->safe_string($transaction, 'amount');
        $address = $this->safe_string($transaction, 'address');
        $txid = $this->safe_string($transaction, 'tx_id');
        $fee = null;
        $feeCostString = $this->safe_string($transaction, 'fee');
        if ($feeCostString !== null) {
            $fee = array(
                'cost' => $this->parse_number($feeCostString),
                'currency' => $code,
            );
        }
        if ($type === 'withdrawal') {
            // mexc withdrawal amount includes the $fee
            $amountString = Precise::string_sub($amountString, $feeCostString);
        }
        return array(
            'info' => $transaction,
            'id' => $id,
            'txid' => $txid,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => $network,
            'address' => $address,
            'addressTo' => null,
            'addressFrom' => null,
            'tag' => null,
            'tagTo' => null,
            'tagFrom' => null,
            'type' => $type,
            'amount' => $this->parse_number($amountString),
            'currency' => $code,
            'status' => $status,
            'updated' => $updated,
            'fee' => $fee,
        );
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            'WAIT' => 'pending',
            'WAIT_PACKAGING' => 'pending',
            'SUCCESS' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function fetch_position($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = $this->fetch_positions(null, array_merge($request, $params));
        return $this->safe_value($response, 0);
    }

    public function fetch_positions($symbols = null, $params = array ()) {
        $this->load_markets();
        $response = $this->contractPrivateGetPositionOpenPositions ($params);
        //
        //     {
        //         "success" => true,
        //         "code" => 0,
        //         "data" => array(
        //             {
        //                 "positionId" => 1394650,
        //                 "symbol" => "ETH_USDT",
        //                 "positionType" => 1,
        //                 "openType" => 1,
        //                 "state" => 1,
        //                 "holdVol" => 1,
        //                 "frozenVol" => 0,
        //                 "closeVol" => 0,
        //                 "holdAvgPrice" => 1217.3,
        //                 "openAvgPrice" => 1217.3,
        //                 "closeAvgPrice" => 0,
        //                 "liquidatePrice" => 1211.2,
        //                 "oim" => 0.1290338,
        //                 "im" => 0.1290338,
        //                 "holdFee" => 0,
        //                 "realised" => -0.0073,
        //                 "leverage" => 100,
        //                 "createTime" => 1609991676000,
        //                 "updateTime" => 1609991676000,
        //                 "autoAddIm" => false
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_positions($data, $symbols);
    }

    public function parse_position($position, $market = null) {
        //
        //     {
        //         "positionId" => 1394650,
        //         "symbol" => "ETH_USDT",
        //         "positionType" => 1,
        //         "openType" => 1,
        //         "state" => 1,
        //         "holdVol" => 1,
        //         "frozenVol" => 0,
        //         "closeVol" => 0,
        //         "holdAvgPrice" => 1217.3,
        //         "openAvgPrice" => 1217.3,
        //         "closeAvgPrice" => 0,
        //         "liquidatePrice" => 1211.2,
        //         "oim" => 0.1290338,
        //         "im" => 0.1290338,
        //         "holdFee" => 0,
        //         "realised" => -0.0073,
        //         "leverage" => 100,
        //         "createTime" => 1609991676000,
        //         "updateTime" => 1609991676000,
        //         "autoAddIm" => false
        //     }
        //
        $market = $this->safe_market($this->safe_string($position, 'symbol'), $market);
        $symbol = $market['symbol'];
        $contracts = $this->safe_string($position, 'holdVol');
        $entryPrice = $this->safe_number($position, 'openAvgPrice');
        $initialMargin = $this->safe_string($position, 'im');
        $rawSide = $this->safe_string($position, 'positionType');
        $side = ($rawSide === '1') ? 'long' : 'short';
        $openType = $this->safe_string($position, 'margin_mode');
        $marginType = ($openType === '1') ? 'isolated' : 'cross';
        $leverage = $this->safe_number($position, 'leverage');
        $liquidationPrice = $this->safe_number($position, 'liquidatePrice');
        $timestamp = $this->safe_number($position, 'updateTime');
        return array(
            'info' => $position,
            'symbol' => $symbol,
            'contracts' => $this->parse_number($contracts),
            'contractSize' => null,
            'entryPrice' => $entryPrice,
            'collateral' => null,
            'side' => $side,
            'unrealizedProfit' => null,
            'leverage' => $this->parse_number($leverage),
            'percentage' => null,
            'marginType' => $marginType,
            'notional' => null,
            'markPrice' => null,
            'liquidationPrice' => $liquidationPrice,
            'initialMargin' => $this->parse_number($initialMargin),
            'initialMarginPercentage' => null,
            'maintenanceMargin' => null,
            'maintenanceMarginPercentage' => null,
            'marginRatio' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
        );
    }

    public function fetch_transfer($id, $since = null, $limit = null, $params = array ()) {
        list($marketType, $query) = $this->handle_market_type_and_params('fetchTransfer', null, $params);
        $this->load_markets();
        if ($marketType === 'spot') {
            $request = array(
                'transact_id' => $id,
            );
            $response = $this->spot2PrivateGetAssetInternalTransferInfo (array_merge($request, $query));
            //
            //     {
            //         code => '200',
            //         $data => {
            //             currency => 'USDT',
            //             amount => '1',
            //             transact_id => '954877a2ef54499db9b28a7cf9ebcf41',
            //             from => 'MAIN',
            //             to => 'CONTRACT',
            //             transact_state => 'SUCCESS'
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            return $this->parse_transfer($data);
        } elseif ($marketType === 'swap') {
            throw new BadRequest($this->id . ' fetchTransfer() is not supported for ' . $marketType);
        }
    }

    public function fetch_transfers($code = null, $since = null, $limit = null, $params = array ()) {
        list($marketType, $query) = $this->handle_market_type_and_params('fetchTransfers', null, $params);
        $this->load_markets();
        $request = array();
        $currency = null;
        $resultList = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'];
        }
        if ($marketType === 'spot') {
            if ($since !== null) {
                $request['start_time'] = $since;
            }
            if ($limit !== null) {
                if ($limit > 50) {
                    throw new ExchangeError('This exchange supports a maximum $limit of 50');
                }
                $request['page-size'] = $limit;
            }
            $response = $this->spot2PrivateGetAssetInternalTransferRecord (array_merge($request, $query));
            //
            //     {
            //         $code => '200',
            //         $data => {
            //             total_page => '1',
            //             total_size => '5',
            //             result_list => [array(
            //                     $currency => 'USDT',
            //                     amount => '1',
            //                     transact_id => '954877a2ef54499db9b28a7cf9ebcf41',
            //                     from => 'MAIN',
            //                     to => 'CONTRACT',
            //                     transact_state => 'SUCCESS'
            //                 ),
            //                 ...
            //             ]
            //         }
            //     }
            //
            $data = $this->safe_value($response, 'data', array());
            $resultList = $this->safe_value($data, 'result_list', array());
        } elseif ($marketType === 'swap') {
            if ($limit !== null) {
                $request['page_size'] = $limit;
            }
            $response = $this->contractPrivateGetAccountTransferRecord (array_merge($request, $query));
            $data = $this->safe_value($response, 'data');
            $resultList = $this->safe_value($data, 'resultList');
            //
            //     {
            //         "success" => true,
            //         "code" => "0",
            //         "data" => {
            //             "pageSize" => "20",
            //             "totalCount" => "10",
            //             "totalPage" => "1",
            //             "currentPage" => "1",
            //             "resultList" => array(
            //                 array(
            //                     "id" => "2980812",
            //                     "txid" => "fa8a1e7bf05940a3b7025856dc48d025",
            //                     "currency" => "USDT",
            //                     "amount" => "22.90213135",
            //                     "type" => "IN",
            //                     "state" => "SUCCESS",
            //                     "createTime" => "1648849076000",
            //                     "updateTime" => "1648849076000"
            //                 ),
            //             )
            //         }
            //     }
            //
        }
        return $this->parse_transfers($resultList, $currency, $since, $limit);
    }

    public function transfer($code, $amount, $fromAccount, $toAccount, $params = array ()) {
        $this->load_markets();
        $currency = $this->currency($code);
        $accounts = array(
            'spot' => 'MAIN',
            'swap' => 'CONTRACT',
        );
        $fromId = $this->safe_string($accounts, $fromAccount);
        $toId = $this->safe_string($accounts, $toAccount);
        if ($fromId === null) {
            $keys = is_array($accounts) ? array_keys($accounts) : array();
            throw new ExchangeError($this->id . ' $fromAccount must be one of ' . implode(', ', $keys));
        }
        if ($toId === null) {
            $keys = is_array($accounts) ? array_keys($accounts) : array();
            throw new ExchangeError($this->id . ' $toAccount must be one of ' . implode(', ', $keys));
        }
        $request = array(
            'currency' => $currency['id'],
            'amount' => $amount,
            'from' => $fromId,
            'to' => $toId,
        );
        $response = $this->spot2PrivatePostAssetInternalTransfer (array_merge($request, $params));
        //
        //     {
        //         $code => '200',
        //         $data => {
        //             $currency => 'USDT',
        //             $amount => '1',
        //             transact_id => 'b60c1df8e7b24b268858003f374ecb75',
        //             from => 'MAIN',
        //             to => 'CONTRACT',
        //             transact_state => 'WAIT'
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_transfer($data, $currency);
    }

    public function parse_transfer($transfer, $currency = null) {
        //
        // spot:
        //
        //     {
        //         $currency => 'USDT',
        //         amount => '1',
        //         transact_id => 'b60c1df8e7b24b268858003f374ecb75',
        //         from => 'MAIN',
        //         to => 'CONTRACT',
        //         transact_state => 'WAIT'
        //     }
        //
        // swap
        //
        //     {
        //         "currency" => "USDT",
        //         "amount" => "22.90213135",
        //         "txid" => "fa8a1e7bf05940a3b7025856dc48d025",
        //         "id" => "2980812",
        //         "type" => "IN",
        //         "state" => "SUCCESS",
        //         "createTime" => "1648849076000",
        //         "updateTime" => "1648849076000"
        //     }
        //
        $currencyId = $this->safe_string($transfer, 'currency');
        $id = $this->safe_string_2($transfer, 'transact_id', 'txid');
        $timestamp = $this->safe_integer($transfer, 'createTime');
        $datetime = ($timestamp !== null) ? $this->iso8601($timestamp) : null;
        $direction = $this->safe_string($transfer, 'type');
        $accountFrom = null;
        $accountTo = null;
        if ($direction !== null) {
            $accountFrom = ($direction === 'IN') ? 'MAIN' : 'CONTRACT';
            $accountTo = ($direction === 'IN') ? 'CONTRACT' : 'MAIN';
        } else {
            $accountFrom = $this->safe_string($transfer, 'from');
            $accountTo = $this->safe_string($transfer, 'to');
        }
        return array(
            'info' => $transfer,
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $datetime,
            'currency' => $this->safe_currency_code($currencyId, $currency),
            'amount' => $this->safe_number($transfer, 'amount'),
            'fromAccount' => $this->parse_account_id($accountFrom),
            'toAccount' => $this->parse_account_id($accountTo),
            'status' => $this->parse_transfer_status($this->safe_string_2($transfer, 'transact_state', 'state')),
        );
    }

    public function parse_account_id($status) {
        $statuses = array(
            'MAIN' => 'spot',
            'CONTRACT' => 'swap',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transfer_status($status) {
        $statuses = array(
            'SUCCESS' => 'ok',
            'FAILED' => 'failed',
            'WAIT' => 'pending',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
        $networks = $this->safe_value($this->options, 'networks', array());
        $network = $this->safe_string_2($params, 'network', 'chain'); // this line allows the user to specify either ERC20 or ETH
        $network = $this->safe_string($networks, $network, $network); // handle ETH > ERC-20 alias
        $this->check_address($address);
        $this->load_markets();
        $currency = $this->currency($code);
        if ($tag !== null) {
            $address .= ':' . $tag;
        }
        $request = array(
            'currency' => $currency['id'],
            'address' => $address,
            'amount' => $amount,
        );
        if ($network !== null) {
            $request['chain'] = $network;
            $params = $this->omit($params, array( 'network', 'chain' ));
        }
        $response = $this->spot2PrivatePostAssetWithdraw (array_merge($request, $params));
        //
        //     {
        //         "code":200,
        //         "data" => {
        //             "withdrawId":"25fb2831fb6d4fc7aa4094612a26c81d"
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_transaction($data, $currency);
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        list($section, $access) = $api;
        list($path, $params) = $this->resolve_path($path, $params);
        $url = null;
        if ($section === 'spot') {
            $url = $this->urls['api'][$section][$access] . '/api/' . $this->version . '/' . $path;
            $paramsEncoded = '';
            if ($access === 'private') {
                $params['timestamp'] = $this->milliseconds();
                $params['recvWindow'] = $this->safe_integer($this->options, 'recvWindow', 5000);
            }
            if ($params) {
                $paramsEncoded = $this->urlencode($params);
                $url .= '?' . $paramsEncoded;
            }
            if ($access === 'private') {
                $this->check_required_credentials();
                $signature = $this->hmac($this->encode($paramsEncoded), $this->encode($this->secret), 'sha256');
                $url .= '&' . 'signature=' . $signature;
                $headers = array(
                    'X-MEXC-APIKEY' => $this->apiKey,
                );
            }
            if ($method === 'POST') {
                $headers['Content-Type'] = 'application/json';
            }
        } elseif ($section === 'contract' || $section === 'spot2') {
            $url = $this->urls['api'][$section][$access] . '/' . $this->implode_params($path, $params);
            $params = $this->omit($params, $this->extract_params($path));
            if ($access === 'public') {
                if ($params) {
                    $url .= '?' . $this->urlencode($params);
                }
            } else {
                $this->check_required_credentials();
                $timestamp = (string) $this->milliseconds();
                $auth = '';
                $headers = array(
                    'ApiKey' => $this->apiKey,
                    'Request-Time' => $timestamp,
                    'Content-Type' => 'application/json',
                );
                if ($method === 'POST') {
                    $auth = $this->json($params);
                    $body = $auth;
                } else {
                    $params = $this->keysort($params);
                    if ($params) {
                        $auth .= $this->urlencode($params);
                        $url .= '?' . $auth;
                    }
                }
                $auth = $this->apiKey . $timestamp . $auth;
                $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256');
                $headers['Signature'] = $signature;
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return;
        }
        // spot
        //     array("code":-1128,"msg":"Combination of optional parameters invalid.","_extend":null)
        //     array("success":false,"code":123456,"message":"Order quantity error....")
        //
        // contract
        //
        //     array("code":10232,"msg":"The currency not exist")
        //     array("code":10216,"msg":"No available deposit address")
        //     array("success":true, "code":0, "data":1634095541710)
        //
        $success = $this->safe_value($response, 'success', false); // v1
        if ($success === true) {
            return;
        }
        $responseCode = $this->safe_string($response, 'code', null);
        if (($responseCode !== null) && ($responseCode !== '200') && ($responseCode !== '0')) {
            $feedback = $this->id . ' ' . $body;
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $body, $feedback);
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $responseCode, $feedback);
            throw new ExchangeError($feedback);
        }
    }
}
